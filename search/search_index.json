{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Fractal Tasks Core's documentation!","text":"<p>Fractal is a framework to process high content imaging data at scale and prepare it for interactive visualization.</p> <p>This project is under active development \ud83d\udd28. If you need help or found a bug, open an issue here.</p> <p>Fractal provides distributed workflows that convert TBs of image data into OME-Zar files. The platform then processes the 3D image data by applying tasks like illumination correction, maximum intensity projection, 3D segmentation using cellpose and measurements using napari workflows. The pyramidal OME-Zarr files enable interactive visualization in the napari viewer.</p> <p></p> <p>The fractal-tasks-core package contains the python tasks that parse Yokogawa CV7000 images into OME-Zarr and process OME-Zarr files. Find more information about Fractal in general and the other repositories at this link. All tasks are written as Python functions and are optimized for usage in Fractal workflows, but they can also be used as standalone functions to parse data or process OME-Zarr files. We heavily use regions of interest (ROIs) in our OME-Zarr files to store the positions of field of views. ROIs are saved as AnnData tables following this spec proposal. We save wells as large Zarr arrays instead of a collection of arrays for each field of view (see details here).</p> <p>Here is an example of the interactive visualization in napari using the newly-proposed async loading in NAP4 and the napari-ome-zarr plugin:</p> <p></p>"},{"location":"#available-tasks","title":"Available tasks","text":"<p>Currently, the following tasks are available:</p> <ul> <li>Create Zarr Structure: Task to generate the zarr structure based on Yokogawa metadata files</li> <li>Yokogawa to Zarr: Parses the Yokogawa CV7000 image data and saves it to the Zarr file</li> <li>Illumination Correction: Applies an illumination correction based on a flatfield image &amp; subtracts a background from the image.</li> <li>Image Labeling (&amp; Image Labeling Whole Well): Applies a cellpose network to the image of a single ROI or the whole well. cellpose parameters can be tuned for optimal performance.</li> <li>Maximum Intensity Projection: Creates a maximum intensity projection of the whole plate.</li> <li>Measurement: Make some standard measurements (intensity &amp; morphology) using napari workflows, saving results to AnnData tables.</li> </ul> <p>Some additional tasks are currently being worked on and some older tasks are still present in the <code>fractal_tasks_core</code> folder. See the package page for the detailed description of all tasks.</p>"},{"location":"#contributors","title":"Contributors","text":"<p>Fractal was conceived in the Liberali Lab at the Friedrich Miescher Institute for Biomedical Research and in the Pelkmans Lab at the University of Zurich by @jluethi and @gusqgm. The Fractal project is now developed at the BioVisionCenter at the University of Zurich and the project lead is with @jluethi. The core development is done under contract by eXact lab S.r.l..</p>"},{"location":"#license","title":"License","text":"<p>Fractal is released according to a BSD 3-Clause License, see LICENSE.</p>"},{"location":"all_tasks/","title":"Task list","text":"<p>Here is a list of tasks that are available within Fractal-compatible packages, including both <code>fractal-tasks-core</code> and others.</p> <p>These are the tasks that we are aware of (on December 5th, 2023); if you created your own package of Fractal tasks, reach out to have it listed here (or, if you want to build your own tasks, follow these instructions).</p> <p>Package fractal-tasks-core:</p> <ul> <li>Create OME-Zarr structure</li> <li>Convert Yokogawa to OME-Zarr</li> <li>Copy OME-Zarr structure</li> <li>Maximum Intensity Projection</li> <li>Cellpose Segmentation</li> <li>Illumination correction</li> <li>Napari workflows wrapper</li> <li>Create OME-ZARR structure (multiplexing)</li> <li>Calculate registration (image-based)</li> <li>Apply Registration to ROI Tables</li> <li>Apply Registration to Image</li> <li>Import OME-Zarr</li> </ul> <p>Package scMultiplex:</p> <ul> <li>scMultipleX Measurements</li> </ul> <p>Package fractal-faim-hcs:</p> <ul> <li>Create OME-Zarr MD</li> <li>Convert MD to OME-Zarr</li> </ul> <p>Package abbott:</p> <ul> <li>Compute Registration Elastix</li> </ul>"},{"location":"changelog/","title":"Changelog","text":"<p>Note: Numbers like (#123) point to closed Pull Requests on the fractal-tasks-core repository.</p>"},{"location":"changelog/#0142","title":"0.14.2","text":"<ul> <li>Add custom normalization options to the Cellpose task (#650)</li> <li>Add more options to the Cellpose task to control model behavior (#650)</li> <li>For Cellpose task, switch to using Enums for model_type (see issue #401)</li> </ul>"},{"location":"changelog/#0141","title":"0.14.1","text":"<ul> <li>Fix bug in <code>cellpose_segmentation</code> upon using masked loading and setting <code>channel2</code> (#639). Thanks @FranziskaMoos-FMI and @enricotagliavini.</li> <li>Improve handling of potential race condition in \"Apply Registration to image\" task (#638).</li> </ul>"},{"location":"changelog/#0140","title":"0.14.0","text":"<ul> <li>Breaking changes in tasks:<ul> <li>Make <code>NapariWorkflowsOutput.label_name</code> attribute required, and use it to fill the <code>region[\"path\"]</code> table attribute (#613).</li> </ul> </li> <li>Breaking changes in core library:<ul> <li>\u26a0\ufe0f Refactor the whole package structure, leading to breaking changes for most imports (#613); more details at this page.</li> <li>In <code>prepare_label_group</code> helper function:<ul> <li>Make <code>label_attrs</code> function argument required (#613).</li> <li>Validate <code>label_attrs</code> with <code>NgffImageMeta</code> model (#613).</li> <li>Override multiscale name in <code>label_attrs</code> with <code>label_name</code> (#613).</li> </ul> </li> <li>In <code>write_table</code> helper function:<ul> <li>Drop <code>logger</code> function argument (#613).</li> <li>Add <code>table_name</code> function argument, taking priority over <code>table_attrs</code> (#613).</li> <li>Raise an error if no table type is not provided (#613).</li> <li>Raise an error if table attributes do not comply with table specs (#613).</li> </ul> </li> </ul> </li> <li>Other internal changes:<ul> <li>Comply with table specs V1, by writing all required Zarr attributes (#613).</li> <li>Remove <code>has_args_schema</code> obsolete property from manifest (#603).</li> <li>Handle <code>GroupNotFoundError</code> in <code>load_NgffImageMeta</code> and <code>load_NgffWellMeta</code> (#622).</li> </ul> </li> <li>Bug fixes:<ul> <li>Fix table selection in calculate registration image-based (#615).</li> </ul> </li> <li>Documentation<ul> <li>Clarify table specs V1 (#613).</li> </ul> </li> <li>Testing:<ul> <li>Use more recent Zenodo datasets, created with <code>fractal-tasks-core&gt;=0.12</code> (#623).</li> <li>Use poetry 1.7.1 in GitHub actions (#620).</li> <li>Align with new Zenodo API (#601).</li> <li>Update <code>test_valid_manifest</code> (#606).</li> <li>Use pooch to download test files (#610).</li> </ul> </li> <li>Documentation:<ul> <li>Add list of tasks (#625).</li> </ul> </li> <li>Dependencies:<ul> <li>Remove Pillow <code>&lt;10.1.0</code> constraint (#626).</li> </ul> </li> </ul>"},{"location":"changelog/#0131","title":"0.13.1","text":"<ul> <li>Always use <code>write_table</code> in tasks, rather than AnnData <code>write_elem</code> (#581).</li> <li>Remove assumptions on ROI-table columns from <code>get_ROI_table_with_translation</code> helper function of <code>calculate_registration_image_based</code> task (#591).</li> <li>Testing:<ul> <li>Cache Zenodo data, within GitHub actions (#585).</li> </ul> </li> <li>Documentation:<ul> <li>Define V1 of table specs (#582).</li> <li>Add mathjax support (#582).</li> <li>Add cross-reference inventories to external APIs (#582).</li> </ul> </li> </ul>"},{"location":"changelog/#0130","title":"0.13.0","text":"<ul> <li>Tasks:<ul> <li>New task and helper functions:<ul> <li>Introduce <code>import_ome_zarr</code> task (#557, #579).</li> <li>Introduce <code>get_single_image_ROI</code> and <code>get_image_grid_ROIs</code> (#557).</li> <li>Introduce <code>detect_ome_ngff_type</code> (#557).</li> <li>Introduce <code>update_omero_channels</code> (#579).</li> </ul> </li> <li>Make <code>maximum_intensity_projection</code> independent from ROI tables (#557).</li> <li>Make Cellpose task work when <code>input_ROI_table</code> is empty (#566).</li> <li>Fix bug of missing attributes in ROI-table Zarr group (#573).</li> </ul> </li> <li>Dependencies:<ul> <li>Restrict <code>Pillow</code> version to <code>&lt;10.1</code> (#571).</li> <li>Support AnnData <code>0.10</code> (#574).</li> </ul> </li> <li>Testing:<ul> <li>Align with new Zenodo API (#568).</li> <li>Use ubuntu-22 for GitHub CI (#576).</li> </ul> </li> </ul>"},{"location":"changelog/#0122","title":"0.12.2","text":"<ul> <li>Relax <code>check_valid_ROI_indices</code> to support search-first scenario (#555).</li> <li>Do not install <code>docs</code> dependencies in GitHub CI (#551).</li> </ul>"},{"location":"changelog/#0121","title":"0.12.1","text":"<ul> <li>Make <code>Channel.window</code> attribute optional in <code>lib_ngff.py</code> (#548).</li> <li>Automate procedure for publishing package to PyPI (#545).</li> </ul>"},{"location":"changelog/#0120","title":"0.12.0","text":"<p>This release includes work on Pydantic models for NGFF specs and on ROI tables.</p> <ul> <li>NGFF Pydantic models:<ul> <li>Introduce Pydantic models for NGFF metadata in <code>lib_ngff.py</code> (#528).</li> <li>Extract <code>num_levels</code> and <code>coarsening_xy</code> parameters from NGFF objects, rather than from <code>metadata</code> task input (#528).</li> <li>Transform several <code>lib_zattrs_utils.py</code> functions (<code>get_axes_names</code>, <code>extract_zyx_pixel_sizes</code> and <code>get_acquisition_paths</code>) into <code>lib_ngff.py</code> methods (#528).</li> <li>Load Zarr attributes from groups, rather than from <code>.zattrs</code> files (#528).</li> </ul> </li> <li>Regions of interest:<ul> <li>Set <code>FOV_ROI_table</code> and <code>well_ROI_table</code> ZYX origin to zero (#524).</li> <li>Remove heuristics to determine whether to reset origin, in <code>cellpose_segmentation</code> task (#524).</li> <li>Remove obsolete <code>reset_origin</code> argument from <code>convert_ROI_table_to_indices</code> function (#524).</li> <li>Remove redundant <code>reset_origin</code> call from <code>apply_registration_to_ROI_tables</code> task (#524).</li> <li>Add check on non-negative ROI indices (#534).</li> <li>Add check on ROI indices not starting at <code>(0,0,0)</code>, to highlight v0.12/v0.11 incompatibility (#534).</li> <li>Fix bug in creation of bounding-box ROIs when <code>cellpose_segmentation</code> loops of FOVs (#524).</li> <li>Update type of <code>metadata</code> parameter of <code>prepare_FOV_ROI_table</code> and <code>prepare_well_ROI_table</code> functions (#524).</li> <li>Fix <code>reset_origin</code> so that it returns an updated copy of its input (#524).</li> </ul> </li> <li>Dependencies:<ul> <li>Relax <code>fsspec&lt;=2023.6</code> constraint into <code>fsspec!=2023.9.0</code> (#539).</li> </ul> </li> </ul>"},{"location":"changelog/#0110","title":"0.11.0","text":"<ul> <li>Tasks:<ul> <li>(major) Introduce new tasks for registration of multiplexing cycles: <code>calculate_registration_image_based</code>, <code>apply_registration_to_ROI_tables</code>, <code>apply_registration_to_image</code> (#487).</li> <li>(major) Introduce new <code>overwrite</code> argument for tasks <code>create_ome_zarr</code>, <code>create_ome_zarr_multiplex</code>, <code>yokogawa_to_ome_zarr</code>, <code>copy_ome_zarr</code>, <code>maximum_intensity_projection</code>, <code>cellpose_segmentation</code>, <code>napari_workflows_wrapper</code> (#499).</li> <li>(major) Rename <code>illumination_correction</code> parameter from <code>overwrite</code> to <code>overwrite_input</code> (#499).</li> <li>Fix plate-selection bug in <code>copy_ome_zarr</code> task (#513).</li> <li>Fix bug in definition of <code>metadata[\"plate\"]</code> in <code>create_ome_zarr_multiplex</code> task (#513).</li> <li>Introduce new helper functions <code>write_table</code>, <code>prepare_label_group</code> and <code>open_zarr_group_with_overwrite</code> (#499).</li> <li>Introduce new helper functions <code>are_ROI_table_columns_valid</code>, <code>convert_indices_to_regions</code>, <code>reset_origin</code>, <code>is_standard_roi_table</code>, <code>get_acquisition_paths</code>, <code>get_table_path_dict</code>, <code>get_axes_names</code>, <code>add_zero_translation_columns</code>, <code>calculate_min_max_across_dfs</code>, <code>apply_registration_to_single_ROI_table</code>, <code>write_registered_zarr</code>, <code>calculate_physical_shifts</code>, <code>get_ROI_table_with_translation</code> (#487).</li> </ul> </li> <li>Testing:<ul> <li>Add tests for <code>overwrite</code>-related task behaviors (#499).</li> <li>Introduce mock-up of <code>napari_skimage_regionprops</code> package, for testing of   <code>napari_workflows_wrapper</code> task (#499).</li> </ul> </li> <li>Dependencies:<ul> <li>Require <code>fsspec</code> version to be <code>&lt;=2023.6</code> (#509).</li> </ul> </li> </ul>"},{"location":"changelog/#0101","title":"0.10.1","text":"<ul> <li>Tasks:<ul> <li>Improve validation for <code>OmeroChannel.color</code> field (#488).</li> <li>Include <code>image-label/source/image</code> OME-NGFF attribute when creating labels (#478).</li> <li>Update default values for tolerance (<code>tol</code>) in <code>lib_ROI_overlaps.py</code> functions (#466).</li> </ul> </li> <li>Development tools:<ul> <li>Include <code>docs_info</code> and <code>docs_link</code> attributes in manifest tasks (#486).</li> <li>Rename and revamp scripts to update/check the manifest (#486).</li> <li>Improve logging and error-handling in tools for args-schema creation (#469).</li> </ul> </li> <li>Documentation:<ul> <li>Convert docstrings to Google style (#473, #479).</li> <li>Switch from sphinx to mkdocs for documentation (#479).</li> <li>Update generic type hints (#462, #479).</li> <li>Align examples to recent package version, and mention them in the documentation (#470).</li> </ul> </li> <li>Testing:<ul> <li>Improve coverage of core library (#459, #467, #468).</li> <li>Update Zenodo datasets used in tests (#454).</li> <li>Run tests both for the poetry-installed and pip-installed package (#455).</li> </ul> </li> <li>Dependencies:<ul> <li>Relax <code>numpy</code> required version to <code>&lt;2</code> (#477).</li> <li>Relax <code>dask</code> required version to <code>&gt;=2023.1.0</code> (#455).</li> <li>Relax <code>zarr</code> required version to <code>&gt;=2.13.6,&lt;3</code> (#455).</li> <li>Relax <code>pandas</code> required version to <code>&gt;=1.2.0,&lt;2</code> (#455).</li> <li>Relax <code>Pillow</code> required version to <code>&gt;=9.1.1,&lt;10.0.0</code> (#455).</li> <li>Full update of <code>poetry.lock</code> file (mutiple PRs, e.g. #472).</li> <li>Include <code>requests</code> and <code>wget</code> in the <code>dev</code> poetry dependency group (#455).</li> </ul> </li> </ul>"},{"location":"changelog/#0100","title":"0.10.0","text":"<ul> <li>Restructure the package and repository:<ul> <li>Move tasks to <code>tasks</code> subpackage (#390)</li> <li>Create new <code>dev</code> subpackage (#384).</li> <li>Make tasks-related dependencies optional, and installable via <code>fractal-tasks</code> extra (#390).</li> <li>Remove <code>tools</code> package extra (#384), and split the subpackage content into <code>lib_ROI_overlaps</code> and <code>examples</code> (#390).</li> </ul> </li> <li>(major) Modify task arguments<ul> <li>Add Pydantic model <code>lib_channels.OmeroChannel</code> (#410, #422);</li> <li>Add Pydantic model <code>tasks._input_models.Channel</code> (#422);</li> <li>Add Pydantic model <code>tasks._input_models.NapariWorkflowsInput</code> (#422);</li> <li>Add Pydantic model <code>tasks._input_models.NapariWorkflowsOutput</code> (#422);</li> <li>Move all Pydantic models to main package (#438).</li> <li>Modify arguments of <code>illumination_correction</code> task (#431);</li> <li>Modify arguments of <code>create_ome_zarr</code> and <code>create_ome_zarr_multiplex</code> (#433).</li> <li>Modify argument default for <code>ROI_table_names</code>, in <code>copy_ome_zarr</code> (#449).</li> <li>Remove the delete option from yokogawa to ome zarr (#443).</li> <li>Reorder task inputs (#451).</li> </ul> </li> <li>JSON Schemas for task arguments:<ul> <li>Add JSON Schemas for task arguments in the package manifest (#369, #384).</li> <li>Add JSON Schemas for attributes of custom task-argument Pydantic models (#436).</li> <li>Make schema-generation tools more general, when handling custom Pydantic models (#445).</li> <li>Include titles for custom-model-typed arguments and argument attributes (#447).</li> <li>Remove <code>TaskArguments</code> models and switch to Pydantic V1 <code>validate_arguments</code> (#369).</li> <li>Make coercing&amp;validating task arguments required, rather than optional (#408).</li> <li>Remove <code>default_args</code> from manifest (#379, #393).</li> </ul> </li> <li>Other:<ul> <li>Make pydantic dependency required for running tasks, and pin it to V1 (#408).</li> <li>Remove legacy executor definitions from manifest (#361).</li> <li>Add GitHub action for testing <code>pip install</code> with/without <code>fractal-tasks</code> extra (#390).</li> <li>Remove <code>sqlmodel</code> from dev dependencies (#374).</li> <li>Relax constraint on torch version, from <code>==1.12.1</code> to <code>&lt;=2.0.0</code> (#406).</li> <li>Review task docstrings and improve documentation (#413, #416).</li> <li>Update <code>anndata</code> dependency requirements (from <code>^0.8.0</code> to <code>&gt;=0.8.0,&lt;=0.9.1</code>), and replace <code>anndata.experimental.write_elem</code> with <code>anndata._io.specs.write_elem</code> (#428).</li> </ul> </li> </ul>"},{"location":"changelog/#094","title":"0.9.4","text":"<ul> <li>Relax constraint on <code>scikit-image</code> version, by only requiring a version <code>&gt;=0.19</code> (#367).</li> </ul>"},{"location":"changelog/#093","title":"0.9.3","text":"<ul> <li>For labeling tasks (<code>cellpose_segmentation</code> or <code>napari_worfklows_wrapper</code>), allow empty ROI tables as input or output (#365).</li> <li>Relax constraint related to the presence of channels in <code>create_zarr_structure_multiplex</code> task (#365).</li> </ul>"},{"location":"changelog/#092","title":"0.9.2","text":"<ul> <li>Increase memory requirements for some tasks in manifest (#363).</li> </ul>"},{"location":"changelog/#091","title":"0.9.1","text":"<ul> <li>Add <code>use_gpu</code> argument for <code>cellpose_segmentation</code> task (#350).</li> <li>Add dummy return object to napari-workflows task (#359).</li> <li>Include memory/cpu/gpu requirements in manifest, in view of new fractal-server SLURM backend (#360).</li> </ul>"},{"location":"changelog/#090","title":"0.9.0","text":"<ul> <li>Introduce a module for masked loading of ROIs, and update the <code>cellpose_segmentation</code> task accordingly (#306).</li> <li>Rename task arguments: <code>ROI_table_name-&gt;input_ROI_table</code> and <code>bounding_box_ROI_table_name-&gt;output_ROI_table</code> (#306).</li> <li>Implement part of the proposed table support in OME-NGFF specs, both for the <code>tables</code> zarr group and then for each table subgroup (#306).</li> <li>Rename module: <code>lib_remove_FOV_overlaps.py-&gt;lib_ROI_overlaps.py</code> (#306).</li> <li>Add new functions to existing modules: <code>lib_regions_of_interest.convert_region_to_low_res</code>, <code>lib_ROI_overlaps.find_overlaps_in_ROI_indices</code> (#306).</li> </ul>"},{"location":"changelog/#081","title":"0.8.1","text":"<ul> <li>Disable bugged validation of <code>model_type</code> argument in <code>cellpose_segmentation</code> (#344).</li> <li>Raise an error if the user provides an unexpected argument to a task (#337); this applies to the case of running a task as a script, with a pydantic model for task-argument validation.</li> </ul>"},{"location":"changelog/#080","title":"0.8.0","text":"<ul> <li>(major) Update task interface: remove filename extension from <code>input_paths</code> and <code>output_path</code> for all tasks, and add new arguments <code>(image_extension,image_glob_pattern)</code> to <code>create_ome_zarr</code> task (#323).</li> <li>Implement logic for handling <code>image_glob_patterns</code> argument, both when globbing images and in Yokogawa metadata parsing (#326).</li> <li>Fix minor bugs in task arguments (#329).</li> </ul>"},{"location":"changelog/#075","title":"0.7.5","text":"<ul> <li>Update <code>cellpose_segmentation</code> defaults and parse additional parameters (#316).</li> <li>Add dual-channel input for <code>cellpose_segmentation</code> task (#315).</li> </ul>"},{"location":"changelog/#074","title":"0.7.4","text":"<ul> <li>Add tests for python 3.10 (#309).</li> <li>Drop support for python 3.8 (#319).</li> <li>Update task interface: use string arguments instead of <code>pathlib.Path</code>, and only set defaults in function call signatures (#303).</li> </ul>"},{"location":"changelog/#073","title":"0.7.3","text":"<ul> <li>Add <code>reset_origin</code> argument to <code>convert_ROI_table_to_indices</code> (#305).</li> <li>Do not overwrite existing labels in <code>cellpose_segmentation</code> task (#308).</li> </ul>"},{"location":"changelog/#072","title":"0.7.2","text":"<ul> <li>Remove pyqt5-related dependencies (#288).</li> </ul>"},{"location":"changelog/#071","title":"0.7.1","text":"<p>Missing</p>"},{"location":"changelog/#070","title":"0.7.0","text":"<ul> <li>Replace <code>dask.array.core.get_mapper()</code> with <code>zarr.storage.FSStore()</code> (#282).</li> <li>Pin dask version to &gt;=2023.1.0, &lt;2023.2.</li> <li>Pin zarr version to &gt;=2.13.6, &lt;2.14.</li> <li>Pin numpy version to &gt;=1.23.5,&lt;1.24.</li> <li>Pin cellpose version to &gt;=2.2,&lt;2.3.</li> </ul>"},{"location":"changelog/#065","title":"0.6.5","text":"<ul> <li>Remove FOV overlaps with more flexibility (#265).</li> </ul>"},{"location":"changelog/#064","title":"0.6.4","text":"<ul> <li>Created <code>tools</code> submodule and installation extra (#262).</li> </ul>"},{"location":"changelog/#063","title":"0.6.3","text":"<ul> <li>Added napari dependency, pinned to 0.4.16 version.</li> <li>Fixed type-hinting bug in task to create multiplexing OME-Zarr structure (#258).</li> </ul>"},{"location":"changelog/#062","title":"0.6.2","text":"<ul> <li>Support passing a pre-made metadata table to tasks creating the OME-Zarr structure (#252).</li> </ul>"},{"location":"changelog/#061","title":"0.6.1","text":"<ul> <li>Add option for padding an array with zeros in <code>upscale_array</code> (#251).</li> <li>Simplified <code>imagecodecs</code> and <code>PyQt5</code> dependencies (#248).</li> </ul>"},{"location":"changelog/#060","title":"0.6.0","text":"<ul> <li>(major) Refactor of how to address channels (#239).</li> <li>Fix bug in well ROI table (#245).</li> </ul>"},{"location":"changelog/#051","title":"0.5.1","text":"<ul> <li>Fix sorting of image files when number of Z planes passes 100 (#237).</li> </ul>"},{"location":"changelog/#050","title":"0.5.0","text":"<ul> <li>(major) Deprecate <code>measurement</code> task (#235).</li> <li>(major) Use more uniform names for tasks, both in python modules and manifest (#235).</li> <li>Remove deprecated manifest from <code>__init__.py</code> (#233).</li> </ul>"},{"location":"changelog/#046","title":"0.4.6","text":"<ul> <li>Skip image files if filename is not parsable (#219).</li> <li>Preserve order of <code>input_paths</code> for multiplexing subfolders (#222).</li> <li>Major refactor of <code>replicate_zarr_structure</code>, also enabling support for zarr files with multiple images (#223).</li> </ul>"},{"location":"changelog/#045","title":"0.4.5","text":"<ul> <li>Replace <code>Cellpose</code> wrapper with <code>CellposeModel</code>, to support <code>pretrained_model</code> argument (#218).</li> <li>Update cellpose version (it was pinned to 2.0, in previous versions) (#218).</li> <li>Pin <code>torch</code> dependency to version 1.12.1, to support CUDA version 10.2 (#218).</li> </ul>"},{"location":"changelog/#044","title":"0.4.4","text":"<p>Missing due to releasing error.</p>"},{"location":"changelog/#043","title":"0.4.3","text":"<ul> <li>In <code>create_zarr_structure_multiplex</code>, always use/require strings for <code>acquisition</code> field (#217).</li> </ul>"},{"location":"changelog/#042","title":"0.4.2","text":"<ul> <li>Bugfixes</li> </ul>"},{"location":"changelog/#041","title":"0.4.1","text":"<ul> <li>Only use strings as keys of <code>channel_parameters</code> (in <code>create_zarr_structure_multiplex</code>).</li> </ul>"},{"location":"changelog/#040","title":"0.4.0","text":"<ul> <li>(major) Rename <code>well</code> to <code>image</code> (both in metadata list and in manifest) and add an actual <code>well</code> field (#210).</li> <li>Add <code>create_ome_zarr_multiplexing</code>, and adapt <code>yokogawa_to_zarr</code> (#210).</li> <li>Relax constraint about outputs in <code>napari_worfklows_wrapper</code> (#209).</li> </ul>"},{"location":"changelog/#034","title":"0.3.4","text":"<ul> <li>Always log START/END times for each task (#204).</li> <li>Add <code>label_name</code> argument to <code>cellpose_segmentation</code> (#207).</li> <li>Add <code>pretrained_model</code> argument to <code>cellpose_segmentation</code> (#207).</li> </ul>"},{"location":"changelog/#033","title":"0.3.3","text":"<ul> <li>Added <code>napari_worfklows_wrapper</code> to manifest.</li> </ul>"},{"location":"changelog/#032","title":"0.3.2","text":"<ul> <li>Compute bounding boxes of labels, in <code>cellpose_segmentation</code> (#192).</li> <li>Parse image filenames in a more robust way (#191).</li> <li>Update manifest, moving <code>parallelization_level</code> and <code>executor</code> to <code>meta</code> attribute.</li> </ul>"},{"location":"changelog/#031","title":"0.3.1","text":"<ul> <li>Fix <code>executable</code> fields in manifest.</li> <li>Remove <code>graphviz</code> dependency.</li> </ul>"},{"location":"changelog/#030","title":"0.3.0","text":"<ul> <li>Conform to Fractal v1, through new task manifest (#162) and standard input/output interface (#155, #157).</li> <li>Add several type hints (#148) and validate them in the standard task interface (#175).</li> <li>Update <code>napari_worfklows_wrapper</code>: pyramid level for labeling worfklows (#148), label-only inputs (#163, #171), relabeling (#167), 2D/3D handling (#166).</li> <li>Deprecate <code>dummy</code> and <code>dummy_fail</code> tasks.</li> </ul>"},{"location":"changelog/#026","title":"0.2.6","text":"<ul> <li>Setup sphinx docs, to be built and hosted on https://fractal-tasks-core.readthedocs.io; include some preliminary updates of docstrings (#143).</li> <li>Dependency cleanup via deptry (#144).</li> </ul>"},{"location":"changelog/#025","title":"0.2.5","text":"<ul> <li>Add <code>napari_workflows_wrapper</code> task (#141).</li> <li>Add <code>lib_upscale_array.py</code> module (#141).</li> </ul>"},{"location":"changelog/#024","title":"0.2.4","text":"<ul> <li>Major updates to <code>metadata_parsing.py</code> (#136).</li> </ul>"},{"location":"custom_task/","title":"How to write a Fractal-compatible custom task","text":"<p>The <code>fractal-tasks-core</code> repository is the reference implementation for Fractal tasks and for Fractal task packages, but the Fractal platform can also be used to execute custom tasks. This page lists the Fractal-compatibility requirements, for a single custom task or for a task package.</p> <p>Note that these specifications evolve frequently, see e.g. discussion at https://github.com/fractal-analytics-platform/fractal-tasks-core/issues/151.</p> <p>Note: While the contents of this page remain valid, the recommended procedure to get up to speed and build a Python package of Fractal-compatible tasks is to use the template available at https://github.com/fractal-analytics-platform/fractal-tasks-template.</p> <p>A Fractal task is mainly formed by two components:</p> <ol> <li>A set of metadata, which are stored in the <code>task</code> table of the database of a    <code>fractal-server</code> instance, see Task metadata.</li> <li>An executable command, which can take some specific command-line arguments    (see Command-line interface); the standard    example is a Python script.</li> </ol> <p>In the following we explain what are the Fractal-compatibility requirements for a single task, and then for a task package.</p>"},{"location":"custom_task/#single-custom-task","title":"Single custom task","text":"<p>We describe how to define the multiple aspects of a task, and provide a Full task example.</p>"},{"location":"custom_task/#task-metadata","title":"Task metadata","text":"<p>Each task must be associated to some metadata, so that it can be used in Fractal. The full specification is here, and the required attributes are:</p> <ul> <li><code>name</code>: the task name, e.g. <code>\"Create OME-Zarr structure\"</code>;</li> <li><code>command</code>: a command that can be executed from the command line;</li> <li><code>input_type</code>: this can be any string (typical examples: <code>\"image\"</code> or <code>\"zarr\"</code>);   the special value <code>\"Any\"</code> means that Fractal won't perform any check of the   <code>input_type</code> when applying the task to a dataset.</li> <li><code>output_type</code>: same logic as <code>input_type</code>.</li> <li><code>source</code>: this is meant to be as close as possible to unique task identifier;   for custom tasks, it can be anything (e.g. <code>\"my_task\"</code>), but for task that   are collected automatically from a package (see Task package this    attribute will have a very specific form (e.g.    <code>\"pip_remote:fractal_tasks_core:0.10.0:fractal-tasks::convert_yokogawa_to_ome-zarr\"</code>).</li> <li><code>meta</code>: a JSON object (similar to a Python dictionary) with some additional   information, see Task meta-parameters.</li> </ul> <p>There are multiple ways to get the appropriate metadata into the database, including a POST request to the <code>fractal-server</code> API (see <code>Tasks</code> section in the <code>fractal-server</code> API documentation) or the automated addition of a whole set of tasks through specific API endpoints (see Task package).</p>"},{"location":"custom_task/#command-line-interface","title":"Command-line interface","text":"<p>Some examples of task commands may look like</p> <ul> <li><code>python3 /some/path/my_task.py</code>,</li> <li><code>/some/absolute/path/python3.10 /some/other/absolute/path/my_task.py</code>,</li> <li><code>/some/path/my_executable_task.py</code>,</li> <li>any other executable command (not necessarily based on Python).</li> </ul> <p>Given a task command, Fractal will add two additional command-line arguments to it:</p> <ul> <li><code>-j /some/path/input-arguments.json</code></li> <li><code>--metadata-out /some/path/output-metadata-update.json</code></li> </ul> <p>Therefore the task command must accept these additional command-line arguments. If the task is a Python script, this can be achieved easily by using the <code>run_fractal_task</code> function - which is available as part of <code>fractal_tasks_core.tasks._utils</code>.</p>"},{"location":"custom_task/#task-meta-parameters","title":"Task meta-parameters","text":"<p>The <code>meta</code> attribute of tasks (see the corresponding item in Task metadata) is where we specify some requirements on how the task should be run. This notably includes:</p> <ul> <li>If the task has to be run in parallel (e.g. over multiple wells of an   OME-Zarr dataset), then <code>meta</code> should include a key-value pair like   <code>{\"parallelization_level\": \"well\"}</code>. If the <code>parallelization_level</code> key is   missing, the task is considered as non-parallel.</li> <li>If Fractal is configured to run on a SLURM cluster, <code>meta</code> may include   additional information on the SLRUM requirements (more info on the Fractal   SLURM backend   here).</li> </ul>"},{"location":"custom_task/#task-input-parameters","title":"Task input parameters","text":"<p>When a task is run via Fractal, its input parameters (i.e. the ones in the file specified via the <code>-j</code> command-line otion) will always include a set of keyword arguments with specific names:</p> <ul> <li><code>input_paths</code></li> <li><code>output_path</code></li> <li><code>metadata</code></li> <li><code>component</code> (only for parallel tasks)</li> </ul>"},{"location":"custom_task/#task-output","title":"Task output","text":"<p>The only task output which will be visible to Fractal is what goes in the output metadata-update file (i.e. the one specified through the <code>--metadata-out</code> command-line option). Note that this only holds for non-parallel tasks, while (for the moment) Fractal fully ignores the output of parallel tasks.</p> <p>IMPORTANT: This means that each task must always write any output to disk, before ending.</p>"},{"location":"custom_task/#advanced-features","title":"Advanced features","text":"<p>The description of other advanced features is not yet available in this page.</p> <ol> <li>Also other attributes of the Task metadata exist, and they    would be recognized by other Fractal components (e.g.  <code>fractal-server</code> or    <code>fractal-web</code>). These include JSON Schemas for input parameters and additional    documentation-related attributes.</li> <li>In <code>fractal-tasks-core</code>, we use <code>pydantic    v1</code> to fully coerce and validate the input    parameters into a set of given types.</li> </ol>"},{"location":"custom_task/#full-task-example","title":"Full task example","text":"<p>Here we describe a simplified example of a Fractal-compatible Python task (for more realistic examples see the <code>fractal-task-core</code> tasks folder).</p> <p>The script <code>/some/path/my_task.py</code> may look like <pre><code># Import a helper function from fractal_tasks_core\nfrom fractal_tasks_core.tasks._utils import run_fractal_task\n\ndef my_task_function(\n    # Reserved Fractal arguments\n    input_paths,\n    output_path,\n    metadata,\n    # Task-specific arguments\n    argument_A,\n    argument_B = \"default_B_value\",\n):\n    # Do something, based on the task parameters\n    print(\"Here we go, we are in `my_task_function`\")\n    with open(f\"{output_path}/output.txt\", \"w\") as f:\n        f.write(f\"argument_A={argument_A}\\n\")\n        f.write(f\"argument_B={argument_B}\\n\")\n    # Compile the output metadata update and return\n    output_metadata_update = {\"nothing\": \"to add\"}\n    return output_metadata_update\n\n# Thi block is executed when running the Python script directly\nif __name__ == \"__main__\":\n    run_fractal_task(task_function=my_task_function)\n</code></pre> where we use <code>run_fractal_task</code> so that we don't have to take care of the command-line arguments.</p> <p>Some valid metadata attributes for this task would be: <pre><code>name=\"My Task\"\ncommand=\"python3 /some/path/my_task.py\"\ninput_type=\"Any\"\noutput_type=\"Any\"\nsource=\"my_custom_task\"\nmeta={}\n</code></pre></p> <p>Note that this was an example of a non-parallel tasks; to have a parallel one, we would also need to:</p> <ol> <li>Set <code>meta={\"parallelization_level\": \"something\"}</code>;</li> <li>Include <code>component</code> in the input arguments of <code>my_task_function</code>.</li> </ol>"},{"location":"custom_task/#task-package","title":"Task package","text":"<p>Given a set of Python scripts corresponding to Fractal tasks, it is useful to combine them into a single Python package, using the standard tools or other options (e.g. for <code>fractal-tasks-core</code> we use poetry).</p>"},{"location":"custom_task/#reasons","title":"Reasons","text":"<p>Creating a package is often a good practice, for reasons unrelated to Fractal:</p> <ol> <li>It makes it simple to assign a global version to the package, and to host it    on a public index like PyPI;</li> <li>It may reduce code duplication:<ul> <li>The scripts may have a shared set of external dependencies, which are   defined in a single place for a package.</li> <li>The scripts may import functions from a shared set of auxiliary Python   modules, which can be included in the package.</li> </ul> </li> </ol> <p>Moreover, having a single package also streamlines some Fractal-related operations. Given the package <code>MyTasks</code> (available on PyPI, or locally), the Fractal platform offers a feature that automatically:</p> <ol> <li>Downloads the wheel file of package <code>MyTasks</code> (if it's on a public index,    rather than a local file);</li> <li>Creates a Python virtual environment (venv) which is specific for a given    version of the <code>MyTasks</code> package, and installs the <code>MyTasks</code> package in that    venv;</li> <li>Populates all the corresponding entries in the <code>task</code> database table with    the appropriate Task metadata, which are extracted from    the package manifest.</li> </ol> <p>This feature is currently exposed in the <code>/api/v1/task/collect/pip/</code> endpoint of <code>fractal-server</code> (see API documentation).</p>"},{"location":"custom_task/#requirements","title":"Requirements","text":"<p>To be compatible with Fractal, a task package must satisfy some additional requirements:</p> <ul> <li>The package is built as a a wheel file, and can be installed via <code>pip</code>.</li> <li>The <code>__FRACTAL_MANIFEST__.json</code> file is bundled in the package, in its root   folder. If you are using <code>poetry</code>, no special operation is needed. If you   are using a <code>setup.cfg</code> file, see   this   comment.</li> <li>Include JSON Schemas. The tools in <code>fractal_tasks_core.dev</code> are used to   generate JSON Schema's for the input parameters of each task in   <code>fractal-tasks-core</code>. They are meant to be flexible and re-usable to perform   the same operation on an independent package, but they are not thoroughly   documented/tested for more general use; feel free to open an issue if something   is not clear.</li> <li>Include additional task metadata like <code>docs_info</code> or <code>docs_link</code>, which will   be displayed in the Fractal web-client. Note: this feature is not yet   implemented.</li> </ul> <p>The ones in the list are the main requirements; if you hit unexpected behaviors, also have a look at https://github.com/fractal-analytics-platform/fractal-tasks-core/issues/151 or open a new issue.</p>"},{"location":"development/","title":"Development","text":""},{"location":"development/#setting-up-environment","title":"Setting up environment","text":"<p>We use poetry to manage the development environment and the dependencies. A simple way to install it is <code>pipx install poetry==1.7.1</code>, or you can look at the installation section here.</p> <p>Running any of <pre><code># Install the core library only\npoetry install\n\n# Install the core library and the tasks\npoetry install -E fractal-tasks\n\n# Install the core library and the development/documentation dependencies\npoetry install --with dev --with docs\n</code></pre> will take care of installing all the dependencies in a separate environment, optionally installing also the dependencies for developement and to build the documentation.</p>"},{"location":"development/#testing","title":"Testing","text":"<p>We use pytest for unit and integration testing of Fractal. If you installed the development dependencies, you may run the test suite by invoking: <pre><code>poetry run pytest\n</code></pre></p> <p>The tests files are in the <code>tests</code> folder of the repository, and they are also run through GitHub Actions; both the main fractal_tasks_core tests (in <code>tests/</code>) and the fractal_tasks_core.tasks tests (in <code>tests/tasks/</code>) are run with Python 3.9, 3.10 and 3.11.</p>"},{"location":"development/#documentation","title":"Documentation","text":"<p>The documentations is built with mkdocs. To build the documentation locally, setup a development python environment (e.g. with <code>poetry install --with docs</code>) and then run one of these commands: <pre><code>poetry run mkdocs serve --config-file mkdocs.yml  # serves the docs at http://127.0.0.1:8000\npoetry run mkdocs build --config-file mkdocs.yml  # creates a build in the `site` folder\n</code></pre></p>"},{"location":"development/#mypy","title":"Mypy","text":"<p>We do not enforce strict <code>mypy</code> compliance, but we do run it as part of a specific GitHub Action. You can run <code>mypy</code> locally for instance as: <pre><code>poetry run mypy --package fractal_tasks_core --ignore-missing-imports --warn-redundant-casts --warn-unused-ignores --warn-unreachable --pretty\n</code></pre></p>"},{"location":"development/#how-to-release","title":"How to release","text":"<p>Preliminary check-list:</p> <ol> <li>The <code>main</code> branch is checked out.</li> <li>You reviewed dependencies and dev dependencies and the lock file is up to date with <code>pyproject.toml</code>.</li> <li>The current HEAD of the main branch passes all the tests (note: make sure that you are using the poetry-installed local package).</li> <li><code>CHANGELOG.md</code> is up to date.</li> <li>If appropriate (e.g. if you added some new task arguments, or if you modified some of their descriptions), update the JSON Schemas in the manifest via: <pre><code>poetry run python fractal_tasks_core/dev/update_manifest.py\n</code></pre> (note: in principle this issue is covered by tests, but it is good to be aware of it)</li> </ol> <p>Actual release</p> <ol> <li>Use: <pre><code>poetry run bumpver update --[tag-num|patch|minor] --dry\n</code></pre> to test updating the version bump</li> <li>If the previous step looks good, remove the <code>--dry</code> and re-run the same command. This will commit both the edited files and the new tag, and push.</li> <li>Approve (or have approved) the new version at Publish package to PyPI.</li> </ol>"},{"location":"install/","title":"How to install","text":"<p>The <code>fractal_tasks_core</code> Python package is hosted on PyPI (https://pypi.org/project/fractal-tasks-core), and can be installed via <code>pip</code>. It includes three (sub)packages:</p> <ol> <li>The main <code>fractal_tasks_core</code> package: a set of helper functions to be used in the Fractal tasks (and possibly in other independent packages).</li> <li>The <code>fractal_tasks_core.tasks</code> subpackage: a set of standard Fractal tasks.</li> <li>The <code>fractal_tasks_core.dev</code> subpackage: a set of developement tools (mostly related to creation of JSON Schemas for task arguments).</li> </ol>"},{"location":"install/#minimal-installation","title":"Minimal installation","text":"<p>The minimal installation command is <pre><code>pip install fractal-tasks-core\n</code></pre> which only installs the dependencies necessary for the main package and for the <code>dev</code> subpackage.</p>"},{"location":"install/#full-installation","title":"Full installation","text":"<p>In order to also use the <code>tasks</code> subpackage, the additional extra <code>fractal-tasks</code> must be included, as in <pre><code>pip install fractal-tasks-core[fractal-tasks]\n</code></pre> Warning: This command installs heavier dependencies (e.g. <code>torch</code>).</p>"},{"location":"tables/","title":"Table specifcations","text":"<p>Within <code>fractal-tasks-core</code>, we make use of tables which are <code>AnnData</code> objects stored within OME-Zarr image groups. This page describes the different kinds of tables we use, and it includes:</p> <ul> <li>A core table specification, valid for all tables;</li> <li>The definition of tables for regions of interests (ROIs);</li> <li>The definition of masking ROI tables, namely ROI tables that are linked e.g. to labels;</li> <li>A feature-table specification, to store measurements.</li> </ul> <p>Note: The specifications below are largely inspired by a proposed update to OME-NGFF specs. This update is currently on hold, and <code>fractal-tasks-core</code> will evolve as soon as an official NGFF table specs is adopted - see also the Outlook section.</p>"},{"location":"tables/#specifications-v1","title":"Specifications (V1)","text":"<p>In this section we describe version 1 (V1) of the Fractal table specifications; for the moment, only V1 exists. Note that V1 specifications are only implemented as os of version 0.14.0 of <code>fractal-tasks-core</code>.</p>"},{"location":"tables/#core-tables","title":"Core tables","text":"<p>The core-table specification consists in the definition of the required Zarr structure and attributes, and of the <code>AnnData</code> table format.</p> <p><code>AnnData</code> table format</p> <p>We store tabular data into Zarr groups as <code>AnnData</code> (\"Annotated Data\") objects; the <code>anndata</code> Python library provides the definition of this format and the relevant tools. Quoting from the <code>anndata</code> documentation:</p> <p><code>AnnData</code> is specifically designed for matrix-like data. By this we mean that we have \\(n\\) observations, each of which can be represented as \\(d\\)-dimensional vectors, where each dimension corresponds to a variable or feature. Both the rows and columns of this \\(n \\times d\\) matrix are special in the sense that they are indexed.</p> <p>(https://anndata.readthedocs.io/en/latest/tutorials/notebooks/getting-started.html)</p> <p>Note that <code>AnnData</code> tables are easily transformed from/into <code>pandas.DataFrame</code> objects - see e.g. the <code>AnnData.to_df</code> method.</p> <p>Zarr structure and attributes</p> <p>The structure of Zarr groups is based on the <code>image</code> specification in NGFF 0.4, with an additional <code>tables</code> group and the corresponding subgroups (similar to <code>labels</code>): <pre><code>image.zarr        # Zarr group for a NGFF image\n|\n\u251c\u2500\u2500 0             # Zarr array for multiscale level 0\n\u251c\u2500\u2500 ...\n\u251c\u2500\u2500 N             # Zarr array for multiscale level N\n|\n\u251c\u2500\u2500 labels        # Zarr subgroup with a list of labels associated to this image\n|   \u251c\u2500\u2500 label_A   # Zarr subgroup for a given label\n|   \u251c\u2500\u2500 label_B   # Zarr subgroup for a given label\n|   \u2514\u2500\u2500 ...\n|\n\u2514\u2500\u2500 tables        # Zarr subgroup with a list of tables associated to this image\n    \u251c\u2500\u2500 table_1   # Zarr subgroup for a given table\n    \u251c\u2500\u2500 table_2   # Zarr subgroup for a given table\n    \u2514\u2500\u2500 ...\n</code></pre></p> <p>The Zarr attributes of the <code>tables</code> group must include the key <code>tables</code>, pointing to the list of all tables (this simplifies discovery of tables associated to the current NGFF image), as in image.zarr/tables/.zattrs<pre><code>{\n\"tables\": [\"table_1\", \"table_2\"]\n}\n</code></pre></p> <p>The Zarr attributes of each specific-table group must include the version of the table specification (currently version 1), through the <code>fractal_table_version</code> attribute. Also note that the <code>anndata</code> function to write an <code>AnnData</code> object into a Zarr group automatically sets additional attributes. Here is an example of the resulting Zarr attributes: image.zarr/tables/table_1/.zattrs<pre><code>{\n\"fractal_table_version\": \"1\",\n\"encoding-type\": \"anndata\",    // Automatically added by anndata 0.11\n\"encoding-version\": \"0.1.0\",   // Automatically added by anndata 0.11\n}\n</code></pre></p>"},{"location":"tables/#roi-tables","title":"ROI tables","text":"<p>In <code>fractal-tasks-core</code>, a ROI table defines regions of space which are three-dimensional (see also the Outlook section about dimensionality flexibility) and box-shaped. Typical use cases are described here.</p> <p>Zarr attributes</p> <p>The specification of a ROI table is a subset of the core table one. Moreover, the table-group Zarr attributes must include the <code>type</code> attribute with value <code>roi_table</code>, as in image.zarr/tables/table_1/.zattrs<pre><code>{\n\"fractal_table_version\": \"1\",\n\"type\": \"roi_table\",\n\"encoding-type\": \"anndata\",\n\"encoding-version\": \"0.1.0\",\n}\n</code></pre></p> <p>Table columns</p> <p>The <code>var</code> attribute of a given <code>AnnData</code> object indexes the columns of the table. A <code>fractal-tasks-core</code> ROI table must include the following six columns:</p> <ul> <li><code>x_micrometer</code>, <code>y_micrometer</code>, <code>z_micrometer</code>:   the lower bounds of the XYZ intervals defining the ROI, in micrometers;</li> <li><code>len_x_micrometer</code>, <code>len_y_micrometer</code>, <code>len_z_micrometer</code>:   the XYZ edge lengths, in micrometers.</li> </ul> <p>Notes:</p> <ol> <li>The axes origin for the ROI positions (e.g. for <code>x_micrometer</code>)    corresponds to the top-left corner of the image (for the YX axes) and to    the lowest Z plane.</li> <li>ROIs are defined in physical coordinates, and they do not store    information on the number or size of pixels.</li> </ol> <p>ROI tables may also include other columns, beyond the required ones. Here are the ones that are typically used in <code>fractal-tasks-core</code> (see also the Use cases section):</p> <ul> <li><code>x_micrometer_original</code> and <code>y_micrometer_original</code>, which are a copy of   <code>x_micrometer</code> and <code>y_micrometer</code> taken before applying some transformation;</li> <li><code>translation_x</code>, <code>translation_y</code> and <code>translation_z</code>, which are used during   registration of multiplexing cycles;</li> <li><code>label</code>, which is used to link a ROI to a label (either for   masking ROI tables or for   feature tables).</li> </ul>"},{"location":"tables/#masking-roi-tables","title":"Masking ROI tables","text":"<p>Masking ROI tables are a specific instance of the basic ROI tables described above, where each ROI must also be associated to a specific label of a label image.</p> <p>Motivation</p> <p>The motivation for this association is based on the following use case:</p> <ul> <li>By performing segmentation of a NGFF image, we identify N objects and we   store them as a label image (where the value at each pixel correspond to the   label index);</li> <li>We also compute the three-dimensional bounding box of each segmented object,   and store these bounding boxes into a <code>masking</code> ROI table;</li> <li>For each one of these ROIs, we also include information that link it to both   the label image and a specific label index;</li> <li>During further processing we can load/modify specific sub-regions of the ROI,   based on information contained in the label image. This kind of operations   are <code>masked</code>, as they only act on the array elements that match a certain   condition on the label value.</li> </ul> <p>Zarr attributes</p> <p>For this kind of tables, <code>fractal-tasks-core</code> closely follows the proposed NGFF update mentioned above. The requirements on the Zarr attributes of a given table are:</p> <ul> <li>Attributes must contain a <code>type</code> key, with value <code>masking_roi_table</code>2.</li> <li>Attributes must contain a <code>region</code> key; the corresponding value must be an   object with a <code>path</code> key and a string value (i.e. the path to the data the   table is annotating).</li> <li>Attributes must include a key <code>instance_key</code>, which is the key in <code>obs</code> that   denotes which instance in <code>region</code> the row corresponds to.</li> </ul> <p>Here is an example of valid Zarr attributes image.zarr/tables/table_1/.zattrs<pre><code>{\n\"fractal_table_version\": \"1\",\n\"type\": \"masking_roi_table\",\n\"region\": { \"path\": \"../labels/label_DAPI\" },\n\"instance_key\": \"label\",\n\"encoding-type\": \"anndata\",\n\"encoding-version\": \"0.1.0\",\n}\n</code></pre></p> <p><code>AnnData</code> table attributes</p> <p>On top of the required ROI-table colums, the masking-ROI-table <code>AnnData</code> object must have an attribute <code>obs</code> with a key matching to the <code>instance_key</code> zarr attribute. For instance if <code>instance_key=\"label\"</code> then <code>table.obs[\"label\"]</code> must exist, with its items matching the labels in the image in <code>\"../labels/label_DAPI\"</code>.</p>"},{"location":"tables/#feature-tables","title":"Feature tables","text":"<p>Motivation</p> <p>The typical use case for feature tables is to store measurements related to segmented objects, while mantaining a link to the original instances (e.g. labels). Note that the current specification is aligned to the one of masking ROI tables, since they both need to relate a table to a label image, but the two may diverge in the future.</p> <p>As part of the current <code>fractal-tasks-core</code> tasks, measurements can be performed e.g. via <code>regionprops</code> from <code>scikit-image</code>, as wrapped in napari-skimage-regionprops).</p> <p>Zarr attributes</p> <p>For this kind of tables, <code>fractal-tasks-core</code> closely follows the proposed NGFF update mentioned above. The requirements on the Zarr attributes of a given table are:</p> <ul> <li>Attributes must contain a <code>type</code> key, with value <code>feature_table</code>2.</li> <li>Attributes must contain a <code>region</code> key; the corresponding value must be an   object with a <code>path</code> key and a string value (i.e. the path to the data the   table is annotating).</li> <li>Attributes must include a key <code>instance_key</code>, which is the key in <code>obs</code> that   denotes which instance in <code>region</code> the row corresponds to.</li> </ul> <p>Here is an example of valid Zarr attributes image.zarr/tables/table_1/.zattrs<pre><code>{\n\"fractal_table_version\": \"1\",\n\"type\": \"feature_table\",\n\"region\": { \"path\": \"../labels/label_DAPI\" },\n\"instance_key\": \"label\",\n\"encoding-type\": \"anndata\",\n\"encoding-version\": \"0.1.0\",\n}\n</code></pre></p> <p><code>AnnData</code> table attributes</p> <p>The feature-table <code>AnnData</code> object must have an attribute <code>obs</code> with a key matching to the <code>instance_key</code> zarr attribute. For instance if <code>instance_key=\"label\"</code> then <code>table.obs[\"label\"]</code> must exist, with its items matching the labels in the image in <code>\"../labels/label_DAPI\"</code>.</p>"},{"location":"tables/#examples","title":"Examples","text":""},{"location":"tables/#use-cases-for-roi-tables","title":"Use cases for ROI tables","text":""},{"location":"tables/#ome-zarr-creation","title":"OME-Zarr creation","text":"<p>OME-Zarrs created via <code>fractal-tasks-core</code> (e.g. by parsing Yokogawa images via the <code>create_ome_zarr</code> or <code>create_ome_zarr_multiplex</code> tasks) always include two specific ROI tables:</p> <ul> <li>The table named <code>well_ROI_table</code>, which covers the NGFF image corresponding to the whole well1;</li> <li>The table named <code>FOV_ROI_table</code>, which lists all original fields of view (FOVs).</li> </ul> <p>Each one of these two tables includes ROIs that span the whole image size along the Z axis. Note that this differs, e.g., from ROIs which are the bounding boxes of three-dimensional segmented objects, and which may cover only a part of the image Z size.</p>"},{"location":"tables/#ome-zarr-import","title":"OME-Zarr import","text":"<p>When working with an externally-generated OME-Zarr, one may use the <code>import_ome_zarr</code> task to make it compatible with <code>fractal-tasks-core</code>. This task optionally adds two ROI tables to the NGFF images:</p> <ul> <li>The table named <code>image_ROI_table</code>, which covers the whole image;</li> <li>A table named <code>grid_ROI_table</code>, which splits the whole-image ROI into a YX   rectangular grid of smaller ROIs. This may correspond to original FOVs (in   case the image is a tiled well1), or it may simply be useful for applying   downstream processing to smaller arrays and avoid large memory requirements.</li> </ul> <p>As for the case of <code>well_ROI_table</code> and <code>FOV_ROI_table</code> described above, also these two tables include ROIs spanning the whole image extension along the Z axis.</p>"},{"location":"tables/#ome-zarr-processing","title":"OME-Zarr processing","text":"<p>ROI tables are also used and updated during image processing, e.g as in:</p> <ul> <li>The FOV ROI table may undergo transformations during processing, e.g. FOV   ROIs may be shifted to avoid overlaps; in this case, we use the optional   columns <code>x_micrometer_original</code> and <code>y_micrometer_original</code> to store the values   before the transformation.</li> <li>The FOV ROI table is also used to store information on the registration of   multiplexing cycles, via the <code>translation_x</code>, <code>translation_y</code> and   <code>translation_z</code> optional columns.</li> <li>Several tasks in <code>fractal-tasks-core</code> take an existing ROI table as an input   and then loop over the ROIs defined in the table. This makes the task more   flexible, as it can be used to process e.g. a whole well, a set of FOVs, or a   set of custom regions of the array.</li> </ul>"},{"location":"tables/#readingwriting-tables","title":"Reading/writing tables","text":"<p>The <code>anndata</code> library offers a set of functions for input/output of AnnData tables, including functions specifically targeting the Zarr format.</p>"},{"location":"tables/#reading-a-table","title":"Reading a table","text":"<p>To read an <code>AnnData</code> table from a Zarr group, one may use the <code>read_zarr</code> function. In the following example a NGFF image was created by stitching together two field of views, where each one is made of a stack of five Z planes with 1 um spacing between the planes. The <code>FOV_ROI_table</code> has information on the XY position and size of the two original FOVs (named <code>FOV_1</code> and <code>FOV_2</code>): <pre><code>import anndata as ad\n\ntable = ad.read_zarr(\"/somewhere/image.zarr/tables/FOV_ROI_table\")\n\nprint(table)\n# `AnnData` object with n_obs \u00d7 n_vars = 2 \u00d7 8\n\nprint(table.obs_names)\n# Index(['FOV_1', 'FOV_2'], dtype='object', name='FieldIndex')\n\nprint(table.var_names)\n# Index([\n#        'x_micrometer',\n#        'y_micrometer',\n#        'z_micrometer',\n#        'len_x_micrometer',\n#        'len_y_micrometer',\n#        'len_z_micrometer',\n#        'x_micrometer_original',\n#        'y_micrometer_original'\n#       ],\n#       dtype='object')\n\nprint(table.X)\n# [[    0.      0.      0.    416.    351.      5.  -1448.3 -1517.7]\n#  [  416.      0.      0.    416.    351.      5.  -1032.3 -1517.7]]\n\ndf = table.to_df()  # Convert to pandas DataFrame\nprint(df)\n#             x_micrometer  y_micrometer  z_micrometer  ...  len_z_micrometer  x_micrometer_original  y_micrometer_original\n# FieldIndex                                            ...\n# FOV_1                0.0           0.0           0.0  ...               2.0           -1448.300049           -1517.699951\n# FOV_2              416.0           0.0           0.0  ...               2.0           -1032.300049           -1517.699951\n#\n# [2 rows x 8 columns]\n</code></pre></p> <p>In this case, the second FOV (labeled <code>FOV_2</code>) is defined as the three-dimensional region such that</p> <ul> <li>X is between 416 and 832 micrometers;</li> <li>Y is between 0 and 351 micrometers;</li> <li>Z is between 0 and 5 - which means that all the five available Z planes are included.</li> </ul>"},{"location":"tables/#writing-a-table","title":"Writing a table","text":"<p>The <code>anndata.experimental.write_elem</code> function provides the required functionality to write an <code>AnnData</code> object to a Zarr group. In <code>fractal-tasks-core</code>, the <code>write_table</code> helper function wraps the <code>anndata</code> function and includes additional functionalities -- see its documentation.</p> <p>With respect to the wrapped <code>anndata</code> function, the main additional features of <code>write_table</code> are</p> <ul> <li>The boolean parameter <code>overwrite</code> (defaulting to <code>False</code>), that determines the behavior in case of an already-existing table at the given path.</li> <li>The <code>table_attrs</code> parameter, as a shorthand for updating the Zarr attributes of the table group after its creation.</li> </ul> <p>Here is an example of how to use <code>write_table</code>: <pre><code>import numpy as np\nimport zarr\nimport anndata as ad\nfrom fractal_tasks_core.tables import write_table\n\ntable = ad.AnnData(X=np.ones((10, 10)))  # Generate a dummy `AnnData` object\nimage_group = zarr.open_group(\"/tmp/image.zarr\")\ntable_name = \"MyTable\"\ntable_attrs = {\n    \"type\": \"feature_table\",\n    \"region\": {\"path\": \"../labels/MyLabel\"},\n    \"instance_key\": \"label\",\n}\n\nwrite_table(\n    image_group,\n    table_name,\n    table,\n    overwrite=True,\n    table_attrs=table_attrs,\n)\n</code></pre> After running this Python code snippet, the on-disk output  is as follows: <pre><code>$ tree /tmp/image.zarr/tables/                  # View folder structure\n/tmp/image.zarr/tables/\n\u2514\u2500\u2500 MyTable\n    \u251c\u2500\u2500 layers\n    \u251c\u2500\u2500 obs\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 _index\n    \u2502\u00a0\u00a0     \u2514\u2500\u2500 0\n    \u251c\u2500\u2500 obsm\n    \u251c\u2500\u2500 obsp\n    \u251c\u2500\u2500 uns\n    \u251c\u2500\u2500 var\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 _index\n    \u2502\u00a0\u00a0     \u2514\u2500\u2500 0\n    \u251c\u2500\u2500 varm\n    \u251c\u2500\u2500 varp\n    \u2514\u2500\u2500 X\n        \u2514\u2500\u2500 0.0\n\n12 directories, 3 files\n\n$ cat /tmp/image.zarr/tables/.zattrs            # View tables atributes\n{\n    \"tables\": [\n        \"MyTable\"\n    ]\n}\n\n$ cat /tmp/image.zarr/tables/MyTable/.zattrs    # View single-table attributes\n{\n    \"encoding-type\": \"anndata\",\n    \"encoding-version\": \"0.1.0\",\n    \"fractal_table_version\": \"1\",\n    \"instance_key\": \"label\",\n    \"region\": {\n        \"path\": \"../labels/MyLabel\"\n    },\n    \"type\": \"feature_table\"\n}\n</code></pre></p>"},{"location":"tables/#outlook","title":"Outlook","text":"<p>These specifications may evolve (especially based on the future NGFF updates), eventually leading to breaking changes in future versions. <code>fractal-tasks-core</code> will aim at mantaining backwards-compatibility with V1 for a reasonable amount of time.</p> <p>Here is an in-progress list of aspects that may be reviewed:</p> <ul> <li>We aim at removing the use of hard-coded units from the column names (e.g.   <code>x_micrometer</code>), in favor of a more general definition of units.</li> <li>The <code>z_micrometer</code> and <code>len_z_micrometer</code> columns are currently required in   all ROI tables, even when the ROIs actually define a two-dimensional XY   region; in that case, we set <code>z_micrometer=0</code> and <code>len_z_micrometer</code> is such   that the whole Z size is covered (that is, <code>len_z_micrometer</code> is the product   of the spacing between Z planes and the number of planes). In a future   version, we may introduce more flexibility and also accept ROI tables which   only include X and Y axes, and adapt the relevant tools so that they   automatically expand these ROIs into three-dimensions when appropriate.</li> <li>Concerning the use of <code>AnnData</code> tables or other formats for tabular data, our   plan is to follow whatever serialised table specification becomes part of the   NGFF standard. For the record, Zarr does not natively support storage of   dataframes (see e.g.   https://github.com/zarr-developers/numcodecs/issues/452), which is one aspect   in favor of sticking with the <code>anndata</code> library.</li> </ul> <ol> <li> <p>Within <code>fractal-tasks-core</code>, NGFF images represent whole wells; this still complies with the NGFF specifications, as of an approved clarification in the specs. This explains the reason for storing the regions corresponding to the original FOVs in a specific ROI table, since one NGFF image includes a collection of FOVs. Note that this approach does not rely on the assumption that the FOVs constitute a regular tiling of the well, but it also covers the case of irregularly placed FOVs.\u00a0\u21a9\u21a9</p> </li> <li> <p>Note that the table types <code>masking_roi_table</code> and <code>feature_table</code> closely resemble the <code>type=\"ngff:region_table\"</code> specification in the previous proposed NGFF table specs.\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"_tasks/_all/","title":"all","text":"<p>Package fractal-tasks-core:</p> <ul> <li>Create OME-Zarr structure</li> <li>Convert Yokogawa to OME-Zarr</li> <li>Copy OME-Zarr structure</li> <li>Maximum Intensity Projection</li> <li>Cellpose Segmentation</li> <li>Illumination correction</li> <li>Napari workflows wrapper</li> <li>Create OME-ZARR structure (multiplexing)</li> <li>Calculate registration (image-based)</li> <li>Apply Registration to ROI Tables</li> <li>Apply Registration to Image</li> <li>Import OME-Zarr</li> </ul> <p>Package scMultiplex:</p> <ul> <li>scMultipleX Measurements</li> </ul> <p>Package fractal-faim-hcs:</p> <ul> <li>Create OME-Zarr MD</li> <li>Convert MD to OME-Zarr</li> </ul> <p>Package abbott:</p> <ul> <li>Compute Registration Elastix</li> </ul>"},{"location":"reference/fractal_tasks_core/","title":"Index","text":""},{"location":"reference/fractal_tasks_core/SUMMARY/","title":"SUMMARY","text":"<ul> <li>tasks<ul> <li>_utils</li> <li>apply_registration_to_image</li> <li>apply_registration_to_ROI_tables</li> <li>calculate_registration_image_based</li> <li>cellpose_segmentation</li> <li>cellpose_transforms</li> <li>compress_tif</li> <li>copy_ome_zarr</li> <li>create_ome_zarr</li> <li>create_ome_zarr_multiplex</li> <li>illumination_correction</li> <li>import_ome_zarr</li> <li>maximum_intensity_projection</li> <li>napari_workflows_wrapper</li> <li>napari_workflows_wrapper_models</li> <li>yokogawa_to_ome_zarr</li> </ul> </li> <li>dev<ul> <li>check_manifest</li> <li>lib_args_schemas</li> <li>lib_descriptions</li> <li>lib_signature_constraints</li> <li>lib_task_docs</li> <li>lib_titles</li> <li>update_manifest</li> </ul> </li> <li>cellvoyager<ul> <li>filenames</li> <li>metadata</li> </ul> </li> <li>channels</li> <li>labels</li> <li>masked_loading</li> <li>ngff<ul> <li>specs</li> <li>zarr_utils</li> </ul> </li> <li>pyramids</li> <li>roi<ul> <li>_overlaps_common</li> <li>load_region</li> <li>v1</li> <li>v1_checks</li> <li>v1_overlaps</li> </ul> </li> <li>tables<ul> <li>v1</li> </ul> </li> <li>upscale_array</li> <li>utils</li> <li>zarr_utils</li> </ul>"},{"location":"reference/fractal_tasks_core/channels/","title":"channels","text":"<p>Helper functions to address channels via OME-NGFF/OMERO metadata.</p>"},{"location":"reference/fractal_tasks_core/channels/#fractal_tasks_core.channels.ChannelInputModel","title":"<code>ChannelInputModel</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>A channel which is specified by either <code>wavelength_id</code> or <code>label</code>.</p> <p>This model is similar to <code>OmeroChannel</code>, but it is used for task-function arguments (and for generating appropriate JSON schemas).</p> ATTRIBUTE DESCRIPTION <code>wavelength_id</code> <p>Unique ID for the channel wavelength, e.g. <code>A01_C01</code>.</p> <p> TYPE: <code>Optional[str]</code> </p> <code>label</code> <p>Name of the channel.</p> <p> TYPE: <code>Optional[str]</code> </p> Source code in <code>fractal_tasks_core/channels.py</code> <pre><code>class ChannelInputModel(BaseModel):\n\"\"\"\n    A channel which is specified by either `wavelength_id` or `label`.\n\n    This model is similar to `OmeroChannel`, but it is used for\n    task-function arguments (and for generating appropriate JSON schemas).\n\n    Attributes:\n        wavelength_id: Unique ID for the channel wavelength, e.g. `A01_C01`.\n        label: Name of the channel.\n    \"\"\"\n\n    wavelength_id: Optional[str] = None\n    label: Optional[str] = None\n\n    @validator(\"label\", always=True)\n    def mutually_exclusive_channel_attributes(cls, v, values):\n\"\"\"\n        Check that either `label` or `wavelength_id` is set.\n        \"\"\"\n        wavelength_id = values.get(\"wavelength_id\")\n        label = v\n        if wavelength_id and v:\n            raise ValueError(\n                \"`wavelength_id` and `label` cannot be both set \"\n                f\"(given {wavelength_id=} and {label=}).\"\n            )\n        if wavelength_id is None and v is None:\n            raise ValueError(\n                \"`wavelength_id` and `label` cannot be both `None`\"\n            )\n        return v\n</code></pre>"},{"location":"reference/fractal_tasks_core/channels/#fractal_tasks_core.channels.ChannelInputModel.mutually_exclusive_channel_attributes","title":"<code>mutually_exclusive_channel_attributes(v, values)</code>","text":"<p>Check that either <code>label</code> or <code>wavelength_id</code> is set.</p> Source code in <code>fractal_tasks_core/channels.py</code> <pre><code>@validator(\"label\", always=True)\ndef mutually_exclusive_channel_attributes(cls, v, values):\n\"\"\"\n    Check that either `label` or `wavelength_id` is set.\n    \"\"\"\n    wavelength_id = values.get(\"wavelength_id\")\n    label = v\n    if wavelength_id and v:\n        raise ValueError(\n            \"`wavelength_id` and `label` cannot be both set \"\n            f\"(given {wavelength_id=} and {label=}).\"\n        )\n    if wavelength_id is None and v is None:\n        raise ValueError(\n            \"`wavelength_id` and `label` cannot be both `None`\"\n        )\n    return v\n</code></pre>"},{"location":"reference/fractal_tasks_core/channels/#fractal_tasks_core.channels.ChannelNotFoundError","title":"<code>ChannelNotFoundError</code>","text":"<p>             Bases: <code>ValueError</code></p> <p>Custom error for when <code>get_channel_from_list</code> fails, that can be captured and handled upstream if needed.</p> Source code in <code>fractal_tasks_core/channels.py</code> <pre><code>class ChannelNotFoundError(ValueError):\n\"\"\"\n    Custom error for when `get_channel_from_list` fails,\n    that can be captured and handled upstream if needed.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/fractal_tasks_core/channels/#fractal_tasks_core.channels.OmeroChannel","title":"<code>OmeroChannel</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Custom class for Omero channels, based on OME-NGFF v0.4.</p> ATTRIBUTE DESCRIPTION <code>wavelength_id</code> <p>Unique ID for the channel wavelength, e.g. <code>A01_C01</code>.</p> <p> TYPE: <code>str</code> </p> <code>index</code> <p>Do not change. For internal use only.</p> <p> TYPE: <code>Optional[int]</code> </p> <code>label</code> <p>Name of the channel.</p> <p> TYPE: <code>Optional[str]</code> </p> <code>window</code> <p>Optional <code>Window</code> object to set default display settings for napari.</p> <p> TYPE: <code>Optional[Window]</code> </p> <code>color</code> <p>Optional hex colormap to display the channel in napari (it must be of length 6, e.g. <code>00FFFF</code>).</p> <p> TYPE: <code>Optional[str]</code> </p> <code>active</code> <p>Should this channel be shown in the viewer?</p> <p> TYPE: <code>bool</code> </p> <code>coefficient</code> <p>Do not change. Omero-channel attribute.</p> <p> TYPE: <code>int</code> </p> <code>inverted</code> <p>Do not change. Omero-channel attribute.</p> <p> TYPE: <code>bool</code> </p> Source code in <code>fractal_tasks_core/channels.py</code> <pre><code>class OmeroChannel(BaseModel):\n\"\"\"\n    Custom class for Omero channels, based on OME-NGFF v0.4.\n\n    Attributes:\n        wavelength_id: Unique ID for the channel wavelength, e.g. `A01_C01`.\n        index: Do not change. For internal use only.\n        label: Name of the channel.\n        window: Optional `Window` object to set default display settings for\n            napari.\n        color: Optional hex colormap to display the channel in napari (it\n            must be of length 6, e.g. `00FFFF`).\n        active: Should this channel be shown in the viewer?\n        coefficient: Do not change. Omero-channel attribute.\n        inverted: Do not change. Omero-channel attribute.\n    \"\"\"\n\n    # Custom\n\n    wavelength_id: str\n    index: Optional[int]\n\n    # From OME-NGFF v0.4 transitional metadata\n\n    label: Optional[str]\n    window: Optional[Window]\n    color: Optional[str]\n    active: bool = True\n    coefficient: int = 1\n    inverted: bool = False\n\n    @validator(\"color\", always=True)\n    def valid_hex_color(cls, v, values):\n\"\"\"\n        Check that `color` is made of exactly six elements which are letters\n        (a-f or A-F) or digits (0-9).\n        \"\"\"\n        if v is None:\n            return v\n        if len(v) != 6:\n            raise ValueError(f'color must have length 6 (given: \"{v}\")')\n        allowed_characters = \"abcdefABCDEF0123456789\"\n        for character in v:\n            if character not in allowed_characters:\n                raise ValueError(\n                    \"color must only include characters from \"\n                    f'\"{allowed_characters}\" (given: \"{v}\")'\n                )\n        return v\n</code></pre>"},{"location":"reference/fractal_tasks_core/channels/#fractal_tasks_core.channels.OmeroChannel.valid_hex_color","title":"<code>valid_hex_color(v, values)</code>","text":"<p>Check that <code>color</code> is made of exactly six elements which are letters (a-f or A-F) or digits (0-9).</p> Source code in <code>fractal_tasks_core/channels.py</code> <pre><code>@validator(\"color\", always=True)\ndef valid_hex_color(cls, v, values):\n\"\"\"\n    Check that `color` is made of exactly six elements which are letters\n    (a-f or A-F) or digits (0-9).\n    \"\"\"\n    if v is None:\n        return v\n    if len(v) != 6:\n        raise ValueError(f'color must have length 6 (given: \"{v}\")')\n    allowed_characters = \"abcdefABCDEF0123456789\"\n    for character in v:\n        if character not in allowed_characters:\n            raise ValueError(\n                \"color must only include characters from \"\n                f'\"{allowed_characters}\" (given: \"{v}\")'\n            )\n    return v\n</code></pre>"},{"location":"reference/fractal_tasks_core/channels/#fractal_tasks_core.channels.Window","title":"<code>Window</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Custom class for Omero-channel window, based on OME-NGFF v0.4.</p> ATTRIBUTE DESCRIPTION <code>min</code> <p>Do not change. It will be set to <code>0</code> by default.</p> <p> TYPE: <code>Optional[int]</code> </p> <code>max</code> <p>Do not change. It will be set according to bit-depth of the images by default (e.g. 65535 for 16 bit images).</p> <p> TYPE: <code>Optional[int]</code> </p> <code>start</code> <p>Lower-bound rescaling value for visualization.</p> <p> TYPE: <code>int</code> </p> <code>end</code> <p>Upper-bound rescaling value for visualization.</p> <p> TYPE: <code>int</code> </p> Source code in <code>fractal_tasks_core/channels.py</code> <pre><code>class Window(BaseModel):\n\"\"\"\n    Custom class for Omero-channel window, based on OME-NGFF v0.4.\n\n    Attributes:\n        min: Do not change. It will be set to `0` by default.\n        max:\n            Do not change. It will be set according to bit-depth of the images\n            by default (e.g. 65535 for 16 bit images).\n        start: Lower-bound rescaling value for visualization.\n        end: Upper-bound rescaling value for visualization.\n    \"\"\"\n\n    min: Optional[int]\n    max: Optional[int]\n    start: int\n    end: int\n</code></pre>"},{"location":"reference/fractal_tasks_core/channels/#fractal_tasks_core.channels._get_new_unique_value","title":"<code>_get_new_unique_value(value, existing_values)</code>","text":"<p>Produce a string value that is not present in a given list</p> <p>Append <code>_1</code>, <code>_2</code>, ... to a given string, if needed, until finding a value which is not already present in <code>existing_values</code>.</p> PARAMETER  DESCRIPTION <code>value</code> <p>The first guess for the new value</p> <p> TYPE: <code>str</code> </p> <code>existing_values</code> <p>The list of existing values</p> <p> TYPE: <code>list[str]</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string value which is not present in <code>existing_values</code></p> Source code in <code>fractal_tasks_core/channels.py</code> <pre><code>def _get_new_unique_value(\n    value: str,\n    existing_values: list[str],\n) -&gt; str:\n\"\"\"\n    Produce a string value that is not present in a given list\n\n    Append `_1`, `_2`, ... to a given string, if needed, until finding a value\n    which is not already present in `existing_values`.\n\n    Args:\n        value: The first guess for the new value\n        existing_values: The list of existing values\n\n    Returns:\n        A string value which is not present in `existing_values`\n    \"\"\"\n    counter = 1\n    new_value = value\n    while new_value in existing_values:\n        new_value = f\"{value}-{counter}\"\n        counter += 1\n    return new_value\n</code></pre>"},{"location":"reference/fractal_tasks_core/channels/#fractal_tasks_core.channels.check_unique_wavelength_ids","title":"<code>check_unique_wavelength_ids(channels)</code>","text":"<p>Check that the <code>wavelength_id</code> attributes of a channel list are unique.</p> PARAMETER  DESCRIPTION <code>channels</code> <p>TBD</p> <p> TYPE: <code>list[OmeroChannel]</code> </p> Source code in <code>fractal_tasks_core/channels.py</code> <pre><code>def check_unique_wavelength_ids(channels: list[OmeroChannel]):\n\"\"\"\n    Check that the `wavelength_id` attributes of a channel list are unique.\n\n    Args:\n        channels: TBD\n    \"\"\"\n    wavelength_ids = [c.wavelength_id for c in channels]\n    if len(set(wavelength_ids)) &lt; len(wavelength_ids):\n        raise ValueError(\n            f\"Non-unique wavelength_id's in {wavelength_ids}\\n\" f\"{channels=}\"\n        )\n</code></pre>"},{"location":"reference/fractal_tasks_core/channels/#fractal_tasks_core.channels.check_well_channel_labels","title":"<code>check_well_channel_labels(*, well_zarr_path)</code>","text":"<p>Check that the channel labels for a well are unique.</p> <p>First identify the channel-labels list for each image in the well, then compare lists and verify their intersection is empty.</p> PARAMETER  DESCRIPTION <code>well_zarr_path</code> <p>path to an OME-NGFF well zarr group.</p> <p> TYPE: <code>str</code> </p> Source code in <code>fractal_tasks_core/channels.py</code> <pre><code>def check_well_channel_labels(*, well_zarr_path: str) -&gt; None:\n\"\"\"\n    Check that the channel labels for a well are unique.\n\n    First identify the channel-labels list for each image in the well, then\n    compare lists and verify their intersection is empty.\n\n    Args:\n        well_zarr_path: path to an OME-NGFF well zarr group.\n    \"\"\"\n\n    # Iterate over all images (multiplexing cycles, multi-FOVs, ...)\n    group = zarr.open_group(well_zarr_path, mode=\"r+\")\n    image_paths = [image[\"path\"] for image in group.attrs[\"well\"][\"images\"]]\n    list_of_channel_lists = []\n    for image_path in image_paths:\n        channels = get_omero_channel_list(\n            image_zarr_path=f\"{well_zarr_path}/{image_path}\"\n        )\n        list_of_channel_lists.append(channels[:])\n\n    # For each pair of channel-labels lists, verify they do not overlap\n    for ind_1, channels_1 in enumerate(list_of_channel_lists):\n        labels_1 = set([c.label for c in channels_1])\n        for ind_2 in range(ind_1):\n            channels_2 = list_of_channel_lists[ind_2]\n            labels_2 = set([c.label for c in channels_2])\n            intersection = labels_1 &amp; labels_2\n            if intersection:\n                hint = (\n                    \"Are you parsing fields of view into separate OME-Zarr \"\n                    \"images? This could lead to non-unique channel labels, \"\n                    \"and then could be the reason of the error\"\n                )\n                raise ValueError(\n                    \"Non-unique channel labels\\n\"\n                    f\"{labels_1=}\\n{labels_2=}\\n{hint}\"\n                )\n</code></pre>"},{"location":"reference/fractal_tasks_core/channels/#fractal_tasks_core.channels.define_omero_channels","title":"<code>define_omero_channels(*, channels, bit_depth, label_prefix=None)</code>","text":"<p>Update a channel list to use it in the OMERO/channels metadata.</p> <p>Given a list of channel dictionaries, update each one of them by:     1. Adding a label (if missing);     2. Adding a set of OMERO-specific attributes;     3. Discarding all other attributes.</p> <p>The <code>new_channels</code> output can be used in the <code>attrs[\"omero\"][\"channels\"]</code> attribute of an image group.</p> PARAMETER  DESCRIPTION <code>channels</code> <p>A list of channel dictionaries (each one must include the <code>wavelength_id</code> key).</p> <p> TYPE: <code>list[OmeroChannel]</code> </p> <code>bit_depth</code> <p>bit depth.</p> <p> TYPE: <code>int</code> </p> <code>label_prefix</code> <p>TBD</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>list[dict[str, Union[str, int, bool, dict[str, int]]]]</code> <p><code>new_channels</code>, a new list of consistent channel dictionaries that can be written to OMERO metadata.</p> Source code in <code>fractal_tasks_core/channels.py</code> <pre><code>def define_omero_channels(\n    *,\n    channels: list[OmeroChannel],\n    bit_depth: int,\n    label_prefix: Optional[str] = None,\n) -&gt; list[dict[str, Union[str, int, bool, dict[str, int]]]]:\n\"\"\"\n    Update a channel list to use it in the OMERO/channels metadata.\n\n    Given a list of channel dictionaries, update each one of them by:\n        1. Adding a label (if missing);\n        2. Adding a set of OMERO-specific attributes;\n        3. Discarding all other attributes.\n\n    The `new_channels` output can be used in the `attrs[\"omero\"][\"channels\"]`\n    attribute of an image group.\n\n    Args:\n        channels: A list of channel dictionaries (each one must include the\n            `wavelength_id` key).\n        bit_depth: bit depth.\n        label_prefix: TBD\n\n    Returns:\n        `new_channels`, a new list of consistent channel dictionaries that\n            can be written to OMERO metadata.\n    \"\"\"\n\n    new_channels = [c.copy(deep=True) for c in channels]\n    default_colors = [\"00FFFF\", \"FF00FF\", \"FFFF00\"]\n\n    for channel in new_channels:\n        wavelength_id = channel.wavelength_id\n\n        # If channel.label is None, set it to a default value\n        if channel.label is None:\n            default_label = wavelength_id\n            if label_prefix:\n                default_label = f\"{label_prefix}_{default_label}\"\n            logging.warning(\n                f\"Missing label for {channel=}, using {default_label=}\"\n            )\n            channel.label = default_label\n\n        # If channel.color is None, set it to a default value (use the default\n        # ones for the first three channels, or gray otherwise)\n        if channel.color is None:\n            try:\n                channel.color = default_colors.pop()\n            except IndexError:\n                channel.color = \"808080\"\n\n        # Set channel.window attribute\n        if channel.window:\n            channel.window.min = 0\n            channel.window.max = 2**bit_depth - 1\n\n    # Check that channel labels are unique for this image\n    labels = [c.label for c in new_channels]\n    if len(set(labels)) &lt; len(labels):\n        raise ValueError(f\"Non-unique labels in {new_channels=}\")\n\n    new_channels_dictionaries = [\n        c.dict(exclude={\"index\"}, exclude_unset=True) for c in new_channels\n    ]\n\n    return new_channels_dictionaries\n</code></pre>"},{"location":"reference/fractal_tasks_core/channels/#fractal_tasks_core.channels.get_channel_from_image_zarr","title":"<code>get_channel_from_image_zarr(*, image_zarr_path, label=None, wavelength_id=None)</code>","text":"<p>Extract a channel from OME-NGFF zarr attributes.</p> <p>This is a helper function that combines <code>get_omero_channel_list</code> with <code>get_channel_from_list</code>.</p> PARAMETER  DESCRIPTION <code>image_zarr_path</code> <p>Path to an OME-NGFF image zarr group.</p> <p> TYPE: <code>str</code> </p> <code>label</code> <p><code>label</code> attribute of the channel to be extracted.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>wavelength_id</code> <p><code>wavelength_id</code> attribute of the channel to be extracted.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>OmeroChannel</code> <p>A single channel dictionary.</p> Source code in <code>fractal_tasks_core/channels.py</code> <pre><code>def get_channel_from_image_zarr(\n    *,\n    image_zarr_path: str,\n    label: Optional[str] = None,\n    wavelength_id: Optional[str] = None,\n) -&gt; OmeroChannel:\n\"\"\"\n    Extract a channel from OME-NGFF zarr attributes.\n\n    This is a helper function that combines `get_omero_channel_list` with\n    `get_channel_from_list`.\n\n    Args:\n        image_zarr_path: Path to an OME-NGFF image zarr group.\n        label: `label` attribute of the channel to be extracted.\n        wavelength_id: `wavelength_id` attribute of the channel to be\n            extracted.\n\n    Returns:\n        A single channel dictionary.\n    \"\"\"\n    omero_channels = get_omero_channel_list(image_zarr_path=image_zarr_path)\n    channel = get_channel_from_list(\n        channels=omero_channels, label=label, wavelength_id=wavelength_id\n    )\n    return channel\n</code></pre>"},{"location":"reference/fractal_tasks_core/channels/#fractal_tasks_core.channels.get_channel_from_list","title":"<code>get_channel_from_list(*, channels, label=None, wavelength_id=None)</code>","text":"<p>Find matching channel in a list.</p> <p>Find the channel that has the required values of <code>label</code> and/or <code>wavelength_id</code>, and identify its positional index (which also corresponds to its index in the zarr array).</p> PARAMETER  DESCRIPTION <code>channels</code> <p>A list of channel dictionary, where each channel includes (at least) the <code>label</code> and <code>wavelength_id</code> keys.</p> <p> TYPE: <code>list[OmeroChannel]</code> </p> <code>label</code> <p>The label to look for in the list of channels.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>wavelength_id</code> <p>The wavelength_id to look for in the list of channels.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>OmeroChannel</code> <p>A single channel dictionary.</p> Source code in <code>fractal_tasks_core/channels.py</code> <pre><code>def get_channel_from_list(\n    *,\n    channels: list[OmeroChannel],\n    label: Optional[str] = None,\n    wavelength_id: Optional[str] = None,\n) -&gt; OmeroChannel:\n\"\"\"\n    Find matching channel in a list.\n\n    Find the channel that has the required values of `label` and/or\n    `wavelength_id`, and identify its positional index (which also\n    corresponds to its index in the zarr array).\n\n    Args:\n        channels: A list of channel dictionary, where each channel includes (at\n            least) the `label` and `wavelength_id` keys.\n        label: The label to look for in the list of channels.\n        wavelength_id: The wavelength_id to look for in the list of channels.\n\n    Returns:\n        A single channel dictionary.\n    \"\"\"\n\n    # Identify matching channels\n    if label:\n        if wavelength_id:\n            # Both label and wavelength_id are specified\n            matching_channels = [\n                c\n                for c in channels\n                if (c.label == label and c.wavelength_id == wavelength_id)\n            ]\n        else:\n            # Only label is specified\n            matching_channels = [c for c in channels if c.label == label]\n    else:\n        if wavelength_id:\n            # Only wavelength_id is specified\n            matching_channels = [\n                c for c in channels if c.wavelength_id == wavelength_id\n            ]\n        else:\n            # Neither label or wavelength_id are specified\n            raise ValueError(\n                \"get_channel requires at least one in {label,wavelength_id} \"\n                \"arguments\"\n            )\n\n    # Verify that there is one and only one matching channel\n    if len(matching_channels) == 0:\n        required_match = [f\"{label=}\", f\"{wavelength_id=}\"]\n        required_match_string = \" and \".join(\n            [x for x in required_match if \"None\" not in x]\n        )\n        raise ChannelNotFoundError(\n            f\"ChannelNotFoundError: No channel found in {channels}\"\n            f\" for {required_match_string}\"\n        )\n    if len(matching_channels) &gt; 1:\n        raise ValueError(f\"Inconsistent set of channels: {channels}\")\n\n    channel = matching_channels[0]\n    channel.index = channels.index(channel)\n    return channel\n</code></pre>"},{"location":"reference/fractal_tasks_core/channels/#fractal_tasks_core.channels.get_omero_channel_list","title":"<code>get_omero_channel_list(*, image_zarr_path)</code>","text":"<p>Extract the list of channels from OME-NGFF zarr attributes.</p> PARAMETER  DESCRIPTION <code>image_zarr_path</code> <p>Path to an OME-NGFF image zarr group.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[OmeroChannel]</code> <p>A list of channel dictionaries.</p> Source code in <code>fractal_tasks_core/channels.py</code> <pre><code>def get_omero_channel_list(*, image_zarr_path: str) -&gt; list[OmeroChannel]:\n\"\"\"\n    Extract the list of channels from OME-NGFF zarr attributes.\n\n    Args:\n        image_zarr_path: Path to an OME-NGFF image zarr group.\n\n    Returns:\n        A list of channel dictionaries.\n    \"\"\"\n    group = zarr.open_group(image_zarr_path, mode=\"r+\")\n    channels_dicts = group.attrs[\"omero\"][\"channels\"]\n    channels = [OmeroChannel(**c) for c in channels_dicts]\n    return channels\n</code></pre>"},{"location":"reference/fractal_tasks_core/channels/#fractal_tasks_core.channels.update_omero_channels","title":"<code>update_omero_channels(old_channels)</code>","text":"<p>Make an existing list of Omero channels Fractal-compatible</p> <p>The output channels all have keys <code>label</code>, <code>wavelength_id</code> and <code>color</code>; the <code>wavelength_id</code> values are unique across the channel list.</p> <p>See https://ngff.openmicroscopy.org/0.4/index.html#omero-md for the definition of NGFF Omero metadata.</p> PARAMETER  DESCRIPTION <code>old_channels</code> <p>Existing list of Omero-channel dictionaries</p> <p> TYPE: <code>list[dict[str, Any]]</code> </p> RETURNS DESCRIPTION <code>list[dict[str, Any]]</code> <p>New list of Fractal-compatible Omero-channel dictionaries</p> Source code in <code>fractal_tasks_core/channels.py</code> <pre><code>def update_omero_channels(\n    old_channels: list[dict[str, Any]]\n) -&gt; list[dict[str, Any]]:\n\"\"\"\n    Make an existing list of Omero channels Fractal-compatible\n\n    The output channels all have keys `label`, `wavelength_id` and `color`;\n    the `wavelength_id` values are unique across the channel list.\n\n    See https://ngff.openmicroscopy.org/0.4/index.html#omero-md for the\n    definition of NGFF Omero metadata.\n\n    Args:\n        old_channels: Existing list of Omero-channel dictionaries\n\n    Returns:\n        New list of Fractal-compatible Omero-channel dictionaries\n    \"\"\"\n    new_channels = deepcopy(old_channels)\n    existing_wavelength_ids: list[str] = []\n    handled_channels = []\n\n    default_colors = [\"00FFFF\", \"FF00FF\", \"FFFF00\"]\n\n    def _get_next_color() -&gt; str:\n        try:\n            return default_colors.pop(0)\n        except IndexError:\n            return \"808080\"\n\n    # Channels that contain the key \"wavelength_id\"\n    for ind, old_channel in enumerate(old_channels):\n        if \"wavelength_id\" in old_channel.keys():\n            handled_channels.append(ind)\n            existing_wavelength_ids.append(old_channel[\"wavelength_id\"])\n            new_channel = old_channel.copy()\n            try:\n                label = old_channel[\"label\"]\n            except KeyError:\n                label = str(ind + 1)\n            new_channel[\"label\"] = label\n            if \"color\" not in old_channel:\n                new_channel[\"color\"] = _get_next_color()\n            new_channels[ind] = new_channel\n\n    # Channels that contain the key \"label\" but do not contain the key\n    # \"wavelength_id\"\n    for ind, old_channel in enumerate(old_channels):\n        if ind in handled_channels:\n            continue\n        if \"label\" not in old_channel.keys():\n            continue\n        handled_channels.append(ind)\n        label = old_channel[\"label\"]\n        wavelength_id = _get_new_unique_value(\n            label,\n            existing_wavelength_ids,\n        )\n        existing_wavelength_ids.append(wavelength_id)\n        new_channel = old_channel.copy()\n        new_channel[\"wavelength_id\"] = wavelength_id\n        if \"color\" not in old_channel:\n            new_channel[\"color\"] = _get_next_color()\n        new_channels[ind] = new_channel\n\n    # Channels that do not contain the key \"label\" nor the key \"wavelength_id\"\n    # NOTE: these channels must be treated last, as they have lower priority\n    # w.r.t. existing \"wavelength_id\" or \"label\" values\n    for ind, old_channel in enumerate(old_channels):\n        if ind in handled_channels:\n            continue\n        label = str(ind + 1)\n        wavelength_id = _get_new_unique_value(\n            label,\n            existing_wavelength_ids,\n        )\n        existing_wavelength_ids.append(wavelength_id)\n        new_channel = old_channel.copy()\n        new_channel[\"label\"] = label\n        new_channel[\"wavelength_id\"] = wavelength_id\n        if \"color\" not in old_channel:\n            new_channel[\"color\"] = _get_next_color()\n        new_channels[ind] = new_channel\n\n    # Log old/new values of label, wavelength_id and color\n    for ind, old_channel in enumerate(old_channels):\n        label = old_channel.get(\"label\")\n        color = old_channel.get(\"color\")\n        wavelength_id = old_channel.get(\"wavelength_id\")\n        old_attributes = (\n            f\"Old attributes: {label=}, {wavelength_id=}, {color=}\"\n        )\n        label = new_channels[ind][\"label\"]\n        wavelength_id = new_channels[ind][\"wavelength_id\"]\n        color = new_channels[ind][\"color\"]\n        new_attributes = (\n            f\"New attributes: {label=}, {wavelength_id=}, {color=}\"\n        )\n        logging.info(\n            \"Omero channel update:\\n\"\n            f\"    {old_attributes}\\n\"\n            f\"    {new_attributes}\"\n        )\n\n    return new_channels\n</code></pre>"},{"location":"reference/fractal_tasks_core/labels/","title":"labels","text":"<p>Module which currently only hosts <code>prepare_label_group</code>.</p>"},{"location":"reference/fractal_tasks_core/labels/#fractal_tasks_core.labels.prepare_label_group","title":"<code>prepare_label_group(image_group, label_name, label_attrs, overwrite=False, logger=None)</code>","text":"<p>Set the stage for writing labels to a zarr group</p> <p>This helper function is similar to <code>write_table</code>, in that it prepares the appropriate zarr groups (<code>labels</code> and the new-label one) and performs <code>overwrite</code>-dependent checks. At a difference with <code>write_table</code>, this function does not actually write the label array to the new zarr group; such writing operation must take place in the actual task function, since in fractal-tasks-core it is done sequentially on different <code>region</code>s of the zarr array.</p> <p>What this function does is:</p> <ol> <li>Create the <code>labels</code> group, if needed.</li> <li>If <code>overwrite=False</code>, check that the new label does not exist (either in    zarr attributes or as a zarr sub-group).</li> <li>Update the <code>labels</code> attribute of the image group.</li> <li>If <code>label_attrs</code> is set, include this set of attributes in the    new-label zarr group.</li> </ol> PARAMETER  DESCRIPTION <code>image_group</code> <p>The group to write to.</p> <p> TYPE: <code>Group</code> </p> <code>label_name</code> <p>The name of the new label; this name also overrides the multiscale name in NGFF-image Zarr attributes, if needed.</p> <p> TYPE: <code>str</code> </p> <code>overwrite</code> <p>If <code>False</code>, check that the new label does not exist (either in zarr attributes or as a zarr sub-group); if <code>True</code> propagate parameter to <code>create_group</code> method, making it overwrite any existing sub-group with the given name.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>label_attrs</code> <p>Zarr attributes of the label-image group.</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>logger</code> <p>The logger to use (if unset, use <code>logging.getLogger(None)</code>).</p> <p> TYPE: <code>Optional[Logger]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>group</code> <p>Zarr group of the new label.</p> Source code in <code>fractal_tasks_core/labels.py</code> <pre><code>def prepare_label_group(\n    image_group: zarr.hierarchy.Group,\n    label_name: str,\n    label_attrs: dict[str, Any],\n    overwrite: bool = False,\n    logger: Optional[logging.Logger] = None,\n) -&gt; zarr.group:\n\"\"\"\n    Set the stage for writing labels to a zarr group\n\n    This helper function is similar to `write_table`, in that it prepares the\n    appropriate zarr groups (`labels` and the new-label one) and performs\n    `overwrite`-dependent checks. At a difference with `write_table`, this\n    function does not actually write the label array to the new zarr group;\n    such writing operation must take place in the actual task function, since\n    in fractal-tasks-core it is done sequentially on different `region`s of the\n    zarr array.\n\n    What this function does is:\n\n    1. Create the `labels` group, if needed.\n    2. If `overwrite=False`, check that the new label does not exist (either in\n       zarr attributes or as a zarr sub-group).\n    3. Update the `labels` attribute of the image group.\n    4. If `label_attrs` is set, include this set of attributes in the\n       new-label zarr group.\n\n    Args:\n        image_group:\n            The group to write to.\n        label_name:\n            The name of the new label; this name also overrides the multiscale\n            name in NGFF-image Zarr attributes, if needed.\n        overwrite:\n            If `False`, check that the new label does not exist (either in zarr\n            attributes or as a zarr sub-group); if `True` propagate parameter\n            to `create_group` method, making it overwrite any existing\n            sub-group with the given name.\n        label_attrs:\n            Zarr attributes of the label-image group.\n        logger:\n            The logger to use (if unset, use `logging.getLogger(None)`).\n\n    Returns:\n        Zarr group of the new label.\n    \"\"\"\n\n    # Set logger\n    if logger is None:\n        logger = logging.getLogger(None)\n\n    # Create labels group (if needed) and extract current_labels\n    if \"labels\" not in set(image_group.group_keys()):\n        labels_group = image_group.create_group(\"labels\", overwrite=False)\n    else:\n        labels_group = image_group[\"labels\"]\n    current_labels = labels_group.attrs.asdict().get(\"labels\", [])\n\n    # If overwrite=False, check that the new label does not exist (either as a\n    # zarr sub-group or as part of the zarr-group attributes)\n    if not overwrite:\n        if label_name in set(labels_group.group_keys()):\n            error_msg = (\n                f\"Sub-group '{label_name}' of group {image_group.store.path} \"\n                f\"already exists, but `{overwrite=}`.\\n\"\n                \"Hint: try setting `overwrite=True`.\"\n            )\n            logger.error(error_msg)\n            raise OverwriteNotAllowedError(error_msg)\n        if label_name in current_labels:\n            error_msg = (\n                f\"Item '{label_name}' already exists in `labels` attribute of \"\n                f\"group {image_group.store.path}, but `{overwrite=}`.\\n\"\n                \"Hint: try setting `overwrite=True`.\"\n            )\n            logger.error(error_msg)\n            raise OverwriteNotAllowedError(error_msg)\n\n    # Update the `labels` metadata of the image group, if needed\n    if label_name not in current_labels:\n        new_labels = current_labels + [label_name]\n        labels_group.attrs[\"labels\"] = new_labels\n\n    # Define new-label group\n    label_group = labels_group.create_group(label_name, overwrite=overwrite)\n\n    # Validate attrs against NGFF specs 0.4\n    try:\n        meta = NgffImageMeta(**label_attrs)\n    except ValidationError as e:\n        error_msg = (\n            \"Label attributes do not comply with NGFF image \"\n            \"specifications, as encoded in fractal-tasks-core.\\n\"\n            f\"Original error:\\nValidationError: {str(e)}\"\n        )\n        logger.error(error_msg)\n        raise ValueError(error_msg)\n    # Replace multiscale name with label_name, if needed\n    current_multiscale_name = meta.multiscale.name\n    if current_multiscale_name != label_name:\n        logger.warning(\n            f\"Setting multiscale name to '{label_name}' (old value: \"\n            f\"'{current_multiscale_name}') in label-image NGFF \"\n            \"attributes.\"\n        )\n        label_attrs[\"multiscales\"][0][\"name\"] = label_name\n    # Overwrite label_group attributes with label_attrs key/value pairs\n    label_group.attrs.put(label_attrs)\n\n    return label_group\n</code></pre>"},{"location":"reference/fractal_tasks_core/masked_loading/","title":"masked_loading","text":"<p>Functions to use masked loading of ROIs before/after processing.</p>"},{"location":"reference/fractal_tasks_core/masked_loading/#fractal_tasks_core.masked_loading._postprocess_output","title":"<code>_postprocess_output(*, modified_array, original_array, background)</code>","text":"<p>Postprocess cellpose output, mainly to restore its original background.</p> <p>NOTE: The pre/post-processing functions and the masked_loading_wrapper are currently meant to work as part of the cellpose_segmentation task, with the plan of then making them more flexible; see https://github.com/fractal-analytics-platform/fractal-tasks-core/issues/340.</p> PARAMETER  DESCRIPTION <code>modified_array</code> <p>The 3D (ZYX) array with the correct object data and wrong background data.</p> <p> TYPE: <code>ndarray</code> </p> <code>original_array</code> <p>The 3D (ZYX) array with the wrong object data and correct background data.</p> <p> TYPE: <code>ndarray</code> </p> <code>background</code> <p>The 3D (ZYX) boolean array that defines the background.</p> <p> TYPE: <code>ndarray</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>The postprocessed array.</p> Source code in <code>fractal_tasks_core/masked_loading.py</code> <pre><code>def _postprocess_output(\n    *,\n    modified_array: np.ndarray,\n    original_array: np.ndarray,\n    background: np.ndarray,\n) -&gt; np.ndarray:\n\"\"\"\n    Postprocess cellpose output, mainly to restore its original background.\n\n    **NOTE**: The pre/post-processing functions and the\n    masked_loading_wrapper are currently meant to work as part of the\n    cellpose_segmentation task, with the plan of then making them more\n    flexible; see\n    https://github.com/fractal-analytics-platform/fractal-tasks-core/issues/340.\n\n    Args:\n        modified_array: The 3D (ZYX) array with the correct object data and\n            wrong background data.\n        original_array: The 3D (ZYX) array with the wrong object data and\n            correct background data.\n        background: The 3D (ZYX) boolean array that defines the background.\n\n    Returns:\n        The postprocessed array.\n    \"\"\"\n    # Restore background\n    modified_array[background] = original_array[background]\n    return modified_array\n</code></pre>"},{"location":"reference/fractal_tasks_core/masked_loading/#fractal_tasks_core.masked_loading._preprocess_input","title":"<code>_preprocess_input(image_array, *, region, current_label_path, ROI_table_path, ROI_positional_index)</code>","text":"<p>Preprocess a four-dimensional cellpose input.</p> <p>This involves :</p> <ul> <li>Loading the masking label array for the appropriate ROI;</li> <li>Extracting the appropriate label value from the <code>ROI_table.obs</code>   dataframe;</li> <li>Constructing the background mask, where the masking label matches with a   specific label value;</li> <li>Setting the background of <code>image_array</code> to <code>0</code>;</li> <li>Loading the array which will be needed in postprocessing to restore   background.</li> </ul> <p>NOTE 1: This function relies on V1 of the Fractal table specifications, see https://fractal-analytics-platform.github.io/fractal-tasks-core/tables/.</p> <p>NOTE 2: The pre/post-processing functions and the masked_loading_wrapper are currently meant to work as part of the cellpose_segmentation task, with the plan of then making them more flexible; see https://github.com/fractal-analytics-platform/fractal-tasks-core/issues/340.</p> <p>Naming of variables refers to a two-steps labeling, as in \"first identify organoids, then look for nuclei inside each organoid\") :</p> <ul> <li><code>\"masking\"</code> refers to the labels that are used to identify the object   vs background (e.g. the organoid labels); these labels already exist.</li> <li><code>\"current\"</code> refers to the labels that are currently being computed in   the <code>cellpose_segmentation</code> task, e.g. the nuclear labels.</li> </ul> PARAMETER  DESCRIPTION <code>image_array</code> <p>The 4D CZYX array with image data for a specific ROI.</p> <p> TYPE: <code>ndarray</code> </p> <code>region</code> <p>The ZYX indices of the ROI, in a form like <code>(slice(0, 1), slice(1000, 2000), slice(1000, 2000))</code>.</p> <p> TYPE: <code>tuple[slice, ...]</code> </p> <code>current_label_path</code> <p>Path to the image used as current label, in a form like <code>/somewhere/plate.zarr/A/01/0/labels/nuclei_in_organoids/0</code>.</p> <p> TYPE: <code>str</code> </p> <code>ROI_table_path</code> <p>Path of the AnnData table for the masking-label ROIs; this is used (together with <code>ROI_positional_index</code>) to extract <code>label_value</code>.</p> <p> TYPE: <code>str</code> </p> <code>ROI_positional_index</code> <p>Index of the current ROI, which is used to extract <code>label_value</code> from <code>ROI_table_obs</code>.</p> <p> TYPE: <code>int</code> </p> <p>Returns:     A tuple with three arrays: the preprocessed image array, the background         mask, the current label.</p> Source code in <code>fractal_tasks_core/masked_loading.py</code> <pre><code>def _preprocess_input(\n    image_array: np.ndarray,\n    *,\n    region: tuple[slice, ...],\n    current_label_path: str,\n    ROI_table_path: str,\n    ROI_positional_index: int,\n) -&gt; tuple[np.ndarray, np.ndarray, np.ndarray]:\n\"\"\"\n    Preprocess a four-dimensional cellpose input.\n\n    This involves :\n\n    - Loading the masking label array for the appropriate ROI;\n    - Extracting the appropriate label value from the `ROI_table.obs`\n      dataframe;\n    - Constructing the background mask, where the masking label matches with a\n      specific label value;\n    - Setting the background of `image_array` to `0`;\n    - Loading the array which will be needed in postprocessing to restore\n      background.\n\n    **NOTE 1**: This function relies on V1 of the Fractal table specifications,\n    see\n    https://fractal-analytics-platform.github.io/fractal-tasks-core/tables/.\n\n    **NOTE 2**: The pre/post-processing functions and the\n    masked_loading_wrapper are currently meant to work as part of the\n    cellpose_segmentation task, with the plan of then making them more\n    flexible; see\n    https://github.com/fractal-analytics-platform/fractal-tasks-core/issues/340.\n\n    Naming of variables refers to a two-steps labeling, as in \"first identify\n    organoids, then look for nuclei inside each organoid\") :\n\n    - `\"masking\"` refers to the labels that are used to identify the object\n      vs background (e.g. the organoid labels); these labels already exist.\n    - `\"current\"` refers to the labels that are currently being computed in\n      the `cellpose_segmentation` task, e.g. the nuclear labels.\n\n    Args:\n        image_array: The 4D CZYX array with image data for a specific ROI.\n        region: The ZYX indices of the ROI, in a form like\n            `(slice(0, 1), slice(1000, 2000), slice(1000, 2000))`.\n        current_label_path: Path to the image used as current label, in a form\n            like `/somewhere/plate.zarr/A/01/0/labels/nuclei_in_organoids/0`.\n        ROI_table_path: Path of the AnnData table for the masking-label ROIs;\n            this is used (together with `ROI_positional_index`) to extract\n            `label_value`.\n        ROI_positional_index: Index of the current ROI, which is used to\n            extract `label_value` from `ROI_table_obs`.\n    Returns:\n        A tuple with three arrays: the preprocessed image array, the background\n            mask, the current label.\n    \"\"\"\n\n    logger.info(f\"[_preprocess_input] {image_array.shape=}\")\n    logger.info(f\"[_preprocess_input] {region=}\")\n\n    # Check that image data are 4D (CZYX) - FIXME issue 340\n    if not image_array.ndim == 4:\n        raise ValueError(\n            \"_preprocess_input requires a 4D \"\n            f\"image_array argument, but {image_array.shape=}\"\n        )\n\n    # Load the ROI table and its metadata attributes\n    ROI_table = ad.read_zarr(ROI_table_path)\n    attrs = zarr.group(ROI_table_path).attrs\n    logger.info(f\"[_preprocess_input] {ROI_table_path=}\")\n    logger.info(f\"[_preprocess_input] {attrs.asdict()=}\")\n    MaskingROITableAttrs(**attrs.asdict())\n    label_relative_path = attrs[\"region\"][\"path\"]\n    column_name = attrs[\"instance_key\"]\n\n    # Check that ROI_table.obs has the right column and extract label_value\n    if column_name not in ROI_table.obs.columns:\n        raise ValueError(\n            'In _preprocess_input, \"{column_name}\" '\n            f\" missing in {ROI_table.obs.columns=}\"\n        )\n    label_value = int(ROI_table.obs[column_name][ROI_positional_index])\n\n    # Load masking-label array (lazily)\n    masking_label_path = str(\n        Path(ROI_table_path).parent / label_relative_path / \"0\"\n    )\n    logger.info(f\"{masking_label_path=}\")\n    masking_label_array = da.from_zarr(masking_label_path)\n    logger.info(\n        f\"[_preprocess_input] {masking_label_path=}, \"\n        f\"{masking_label_array.shape=}\"\n    )\n\n    # Load current-label array (lazily)\n    current_label_array = da.from_zarr(current_label_path)\n    logger.info(\n        f\"[_preprocess_input] {current_label_path=}, \"\n        f\"{current_label_array.shape=}\"\n    )\n\n    # Load ROI data for current label array\n    current_label_region = current_label_array[region].compute()\n\n    # Load ROI data for masking label array, with or without upscaling\n    if masking_label_array.shape != current_label_array.shape:\n        logger.info(\"Upscaling of masking label is needed\")\n        lowres_region = convert_region_to_low_res(\n            highres_region=region,\n            highres_shape=current_label_array.shape,\n            lowres_shape=masking_label_array.shape,\n        )\n        masking_label_region = masking_label_array[lowres_region].compute()\n        masking_label_region = upscale_array(\n            array=masking_label_region,\n            target_shape=current_label_region.shape,\n        )\n    else:\n        masking_label_region = masking_label_array[region].compute()\n\n    # Check that all shapes match\n    shapes = (\n        masking_label_region.shape,\n        current_label_region.shape,\n        image_array.shape[1:],\n    )\n    if len(set(shapes)) &gt; 1:\n        raise ValueError(\n            \"Shape mismatch:\\n\"\n            f\"{current_label_region.shape=}\\n\"\n            f\"{masking_label_region.shape=}\\n\"\n            f\"{image_array.shape=}\"\n        )\n\n    # Compute background mask\n    background_3D = masking_label_region != label_value\n    if (masking_label_region == label_value).sum() == 0:\n        raise ValueError(\n            f\"Label {label_value} is not present in the extracted ROI\"\n        )\n\n    # Set image background to zero\n    n_channels = image_array.shape[0]\n    for i in range(n_channels):\n        image_array[i, background_3D] = 0\n\n    return (image_array, background_3D, current_label_region)\n</code></pre>"},{"location":"reference/fractal_tasks_core/masked_loading/#fractal_tasks_core.masked_loading.masked_loading_wrapper","title":"<code>masked_loading_wrapper(*, function, image_array, kwargs=None, use_masks, preprocessing_kwargs=None)</code>","text":"<p>Wrap a function with some pre/post-processing functions</p> PARAMETER  DESCRIPTION <code>function</code> <p>The callable function to be wrapped.</p> <p> TYPE: <code>Callable</code> </p> <code>image_array</code> <p>The image array to be preprocessed and then used as positional argument for <code>function</code>.</p> <p> TYPE: <code>ndarray</code> </p> <code>kwargs</code> <p>Keyword arguments for <code>function</code>.</p> <p> TYPE: <code>Optional[dict]</code> DEFAULT: <code>None</code> </p> <code>use_masks</code> <p>If <code>False</code>, the wrapper only calls <code>function(*args, **kwargs)</code>.</p> <p> TYPE: <code>bool</code> </p> <code>preprocessing_kwargs</code> <p>Keyword arguments for the preprocessing function (see call signature of <code>_preprocess_input()</code>).</p> <p> TYPE: <code>Optional[dict]</code> DEFAULT: <code>None</code> </p> Source code in <code>fractal_tasks_core/masked_loading.py</code> <pre><code>def masked_loading_wrapper(\n    *,\n    function: Callable,\n    image_array: np.ndarray,\n    kwargs: Optional[dict] = None,\n    use_masks: bool,\n    preprocessing_kwargs: Optional[dict] = None,\n):\n\"\"\"\n    Wrap a function with some pre/post-processing functions\n\n    Args:\n        function: The callable function to be wrapped.\n        image_array: The image array to be preprocessed and then used as\n            positional argument for `function`.\n        kwargs: Keyword arguments for `function`.\n        use_masks: If `False`, the wrapper only calls\n            `function(*args, **kwargs)`.\n        preprocessing_kwargs: Keyword arguments for the preprocessing function\n            (see call signature of `_preprocess_input()`).\n    \"\"\"\n    # Optional preprocessing\n    if use_masks:\n        preprocessing_kwargs = preprocessing_kwargs or {}\n        (\n            image_array,\n            background_3D,\n            current_label_region,\n        ) = _preprocess_input(image_array, **preprocessing_kwargs)\n    # Run function\n    kwargs = kwargs or {}\n    new_label_img = function(image_array, **kwargs)\n    # Optional postprocessing\n    if use_masks:\n        new_label_img = _postprocess_output(\n            modified_array=new_label_img,\n            original_array=current_label_region,\n            background=background_3D,\n        )\n    return new_label_img\n</code></pre>"},{"location":"reference/fractal_tasks_core/pyramids/","title":"pyramids","text":"<p>Construct and write pyramid of lower-resolution levels.</p>"},{"location":"reference/fractal_tasks_core/pyramids/#fractal_tasks_core.pyramids.build_pyramid","title":"<code>build_pyramid(*, zarrurl, overwrite=False, num_levels=2, coarsening_xy=2, chunksize=None, aggregation_function=None)</code>","text":"<p>Starting from on-disk highest-resolution data, build and write to disk a pyramid with <code>(num_levels - 1)</code> coarsened levels. This function works for 2D, 3D or 4D arrays.</p> PARAMETER  DESCRIPTION <code>zarrurl</code> <p>Path of the image zarr group, not including the multiscale-level path (e.g. <code>\"some/path/plate.zarr/B/03/0\"</code>).</p> <p> TYPE: <code>Union[str, Path]</code> </p> <code>overwrite</code> <p>Whether to overwrite existing pyramid levels.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>num_levels</code> <p>Total number of pyramid levels (including 0).</p> <p> TYPE: <code>int</code> DEFAULT: <code>2</code> </p> <code>coarsening_xy</code> <p>Linear coarsening factor between subsequent levels.</p> <p> TYPE: <code>int</code> DEFAULT: <code>2</code> </p> <code>chunksize</code> <p>Shape of a single chunk.</p> <p> TYPE: <code>Optional[Sequence[int]]</code> DEFAULT: <code>None</code> </p> <code>aggregation_function</code> <p>Function to be used when downsampling.</p> <p> TYPE: <code>Optional[Callable]</code> DEFAULT: <code>None</code> </p> Source code in <code>fractal_tasks_core/pyramids.py</code> <pre><code>def build_pyramid(\n    *,\n    zarrurl: Union[str, pathlib.Path],\n    overwrite: bool = False,\n    num_levels: int = 2,\n    coarsening_xy: int = 2,\n    chunksize: Optional[Sequence[int]] = None,\n    aggregation_function: Optional[Callable] = None,\n) -&gt; None:\n\n\"\"\"\n    Starting from on-disk highest-resolution data, build and write to disk a\n    pyramid with `(num_levels - 1)` coarsened levels.\n    This function works for 2D, 3D or 4D arrays.\n\n    Args:\n        zarrurl: Path of the image zarr group, not including the\n            multiscale-level path (e.g. `\"some/path/plate.zarr/B/03/0\"`).\n        overwrite: Whether to overwrite existing pyramid levels.\n        num_levels: Total number of pyramid levels (including 0).\n        coarsening_xy: Linear coarsening factor between subsequent levels.\n        chunksize: Shape of a single chunk.\n        aggregation_function: Function to be used when downsampling.\n    \"\"\"\n\n    # Clean up zarrurl\n    zarrurl = str(pathlib.Path(zarrurl))  # FIXME\n\n    # Select full-resolution multiscale level\n    zarrurl_highres = f\"{zarrurl}/0\"\n    logger.info(f\"[build_pyramid] High-resolution path: {zarrurl_highres}\")\n\n    # Lazily load highest-resolution data\n    data_highres = da.from_zarr(zarrurl_highres)\n    logger.info(f\"[build_pyramid] High-resolution data: {str(data_highres)}\")\n\n    # Check the number of axes and identify YX dimensions\n    ndims = len(data_highres.shape)\n    if ndims not in [2, 3, 4]:\n        raise ValueError(f\"{data_highres.shape=}, ndims not in [2,3,4]\")\n    y_axis = ndims - 2\n    x_axis = ndims - 1\n\n    # Set aggregation_function\n    if aggregation_function is None:\n        aggregation_function = np.mean\n\n    # Compute and write lower-resolution levels\n    previous_level = data_highres\n    for ind_level in range(1, num_levels):\n        # Verify that coarsening is doable\n        if min(previous_level.shape[-2:]) &lt; coarsening_xy:\n            raise ValueError(\n                f\"ERROR: at {ind_level}-th level, \"\n                f\"coarsening_xy={coarsening_xy} \"\n                f\"but previous level has shape {previous_level.shape}\"\n            )\n        # Apply coarsening\n        newlevel = da.coarsen(\n            aggregation_function,\n            previous_level,\n            {y_axis: coarsening_xy, x_axis: coarsening_xy},\n            trim_excess=True,\n        ).astype(data_highres.dtype)\n\n        # Apply rechunking\n        if chunksize is None:\n            newlevel_rechunked = newlevel\n        else:\n            newlevel_rechunked = newlevel.rechunk(chunksize)\n        logger.info(\n            f\"[build_pyramid] Level {ind_level} data: \"\n            f\"{str(newlevel_rechunked)}\"\n        )\n\n        # Write zarr and store output (useful to construct next level)\n        previous_level = newlevel_rechunked.to_zarr(\n            zarrurl,\n            component=f\"{ind_level}\",\n            overwrite=overwrite,\n            compute=True,\n            return_stored=True,\n            write_empty_chunks=False,\n            dimension_separator=\"/\",\n        )\n</code></pre>"},{"location":"reference/fractal_tasks_core/upscale_array/","title":"upscale_array","text":"<p>Function to increase the shape of an array by replicating it.</p>"},{"location":"reference/fractal_tasks_core/upscale_array/#fractal_tasks_core.upscale_array.convert_region_to_low_res","title":"<code>convert_region_to_low_res(*, highres_region, lowres_shape, highres_shape)</code>","text":"<p>Convert a region defined for a high-resolution array to the corresponding region for a low-resolution array.</p> PARAMETER  DESCRIPTION <code>highres_region</code> <p>A region of the high-resolution array, defined in a form like <code>(slice(0, 2), slice(1000, 2000), slice(1000, 2000))</code>.</p> <p> TYPE: <code>tuple[slice, ...]</code> </p> <code>highres_shape</code> <p>The shape of the high-resolution array.</p> <p> TYPE: <code>tuple[int, ...]</code> </p> <code>lowres_shape</code> <p>The shape of the low-resolution array.</p> <p> TYPE: <code>tuple[int, ...]</code> </p> RETURNS DESCRIPTION <code>tuple[slice, ...]</code> <p>Region for low-resolution array.</p> Source code in <code>fractal_tasks_core/upscale_array.py</code> <pre><code>def convert_region_to_low_res(\n    *,\n    highres_region: tuple[slice, ...],\n    lowres_shape: tuple[int, ...],\n    highres_shape: tuple[int, ...],\n) -&gt; tuple[slice, ...]:\n\"\"\"\n    Convert a region defined for a high-resolution array to the corresponding\n    region for a low-resolution array.\n\n    Args:\n        highres_region: A region of the high-resolution array, defined in a\n            form like `(slice(0, 2), slice(1000, 2000), slice(1000, 2000))`.\n        highres_shape: The shape of the high-resolution array.\n        lowres_shape: The shape of the low-resolution array.\n\n    Returns:\n        Region for low-resolution array.\n    \"\"\"\n\n    error_msg = (\n        f\"Cannot convert {highres_region=}, \"\n        f\"given {lowres_shape=} and {highres_shape=}.\"\n    )\n\n    ndim = len(lowres_shape)\n    if len(highres_shape) != ndim:\n        raise ValueError(f\"{error_msg} Dimension mismatch.\")\n\n    # Loop over dimensions to construct lowres_region, after some relevant\n    # checks\n    lowres_region = []\n    for ind, lowres_size in enumerate(lowres_shape):\n        # Check that the high-resolution size is not smaller than the\n        # low-resolution size\n        highres_size = highres_shape[ind]\n        if highres_size &lt; lowres_size:\n            raise ValueError(\n                f\"{error_msg} High-res size smaller than low-res size.\"\n            )\n        # Check that sizes are commensurate\n        if highres_size % lowres_size &gt; 0:\n            raise ValueError(\n                f\"{error_msg} Incommensurable sizes \"\n                f\"{highres_size=} and {lowres_size=}.\"\n            )\n        factor = highres_size // lowres_size\n        # Convert old_slice's start/stop attributes\n        old_slice = highres_region[ind]\n        if old_slice.start % factor &gt; 0 or old_slice.stop % factor &gt; 0:\n            raise ValueError(\n                f\"{error_msg} Cannot transform {old_slice=} \"\n                f\"with {factor=}.\"\n            )\n        new_slice_start = old_slice.start // factor\n        new_slice_stop = old_slice.stop // factor\n        new_slice_step = None\n        # Covert old_slice's step attribute\n        if old_slice.step:\n            if old_slice.step % factor &gt; 0:\n                raise ValueError(\n                    f\"{error_msg} Cannot transform {old_slice=} \"\n                    f\"with {factor=}.\"\n                )\n            new_slice_step = old_slice.step // factor\n        # Append new slice\n        lowres_region.append(\n            slice(new_slice_start, new_slice_stop, new_slice_step)\n        )\n\n    return tuple(lowres_region)\n</code></pre>"},{"location":"reference/fractal_tasks_core/upscale_array/#fractal_tasks_core.upscale_array.upscale_array","title":"<code>upscale_array(*, array, target_shape, axis=None, pad_with_zeros=False, warn_if_inhomogeneous=False)</code>","text":"<p>Upscale an array along a given list of axis (through repeated application of <code>np.repeat</code>), to match a target shape.</p> PARAMETER  DESCRIPTION <code>array</code> <p>The array to be upscaled.</p> <p> TYPE: <code>ndarray</code> </p> <code>target_shape</code> <p>The shape of the rescaled array.</p> <p> TYPE: <code>tuple[int, ...]</code> </p> <code>axis</code> <p>The axis along which to upscale the array (if <code>None</code>, then all axis are used).</p> <p> TYPE: <code>Optional[Sequence[int]]</code> DEFAULT: <code>None</code> </p> <code>pad_with_zeros</code> <p>If <code>True</code>, pad the upscaled array with zeros to match <code>target_shape</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>warn_if_inhomogeneous</code> <p>If <code>True</code>, raise a warning when the conversion factors are not identical across all dimensions.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>The upscaled array, with shape <code>target_shape</code>.</p> Source code in <code>fractal_tasks_core/upscale_array.py</code> <pre><code>def upscale_array(\n    *,\n    array: np.ndarray,\n    target_shape: tuple[int, ...],\n    axis: Optional[Sequence[int]] = None,\n    pad_with_zeros: bool = False,\n    warn_if_inhomogeneous: bool = False,\n) -&gt; np.ndarray:\n\"\"\"\n    Upscale an array along a given list of axis (through repeated application\n    of `np.repeat`), to match a target shape.\n\n    Args:\n        array: The array to be upscaled.\n        target_shape: The shape of the rescaled array.\n        axis: The axis along which to upscale the array (if `None`, then all\n            axis are used).\n        pad_with_zeros: If `True`, pad the upscaled array with zeros to match\n            `target_shape`.\n        warn_if_inhomogeneous: If `True`, raise a warning when the conversion\n            factors are not identical across all dimensions.\n\n    Returns:\n        The upscaled array, with shape `target_shape`.\n    \"\"\"\n\n    # Default behavior: use all axis\n    if axis is None:\n        axis = list(range(len(target_shape)))\n\n    array_shape = array.shape\n    info = (\n        f\"Trying to upscale from {array_shape=} to {target_shape=}, \"\n        f\"acting on {axis=}.\"\n    )\n\n    if len(array_shape) != len(target_shape):\n        raise ValueError(f\"{info} Dimensions-number mismatch.\")\n    if axis == []:\n        raise ValueError(f\"{info} Empty axis list\")\n    if min(axis) &lt; 0:\n        raise ValueError(f\"{info} Negative axis specification not allowed.\")\n\n    # Check that upscale is doable\n    for ind, dim in enumerate(array_shape):\n        # Check that array is not larger than target (downscaling)\n        if dim &gt; target_shape[ind]:\n            raise ValueError(\n                f\"{info} {ind}-th array dimension is larger than target.\"\n            )\n        # Check that all relevant axis are included in axis\n        if dim != target_shape[ind] and ind not in axis:\n            raise ValueError(\n                f\"{info} {ind}-th array dimension differs from \"\n                f\"target, but {ind} is not included in \"\n                f\"{axis=}.\"\n            )\n\n    # Compute upscaling factors\n    upscale_factors = {}\n    for ax in axis:\n        if (target_shape[ax] % array_shape[ax]) &gt; 0 and not pad_with_zeros:\n            raise ValueError(\n                \"Incommensurable upscale attempt, \"\n                f\"from {array_shape=} to {target_shape=}.\"\n            )\n        upscale_factors[ax] = target_shape[ax] // array_shape[ax]\n        # Check that this is not downscaling\n        if upscale_factors[ax] &lt; 1:\n            raise ValueError(info)\n    info = f\"{info} Upscale factors: {upscale_factors}\"\n\n    # Raise a warning if upscaling is non-homogeneous across all axis\n    if warn_if_inhomogeneous:\n        if len(set(upscale_factors.values())) &gt; 1:\n            warnings.warn(f\"{info} (inhomogeneous)\")\n\n    # Upscale array, via np.repeat\n    upscaled_array = array\n    for ax in axis:\n        upscaled_array = np.repeat(\n            upscaled_array, upscale_factors[ax], axis=ax\n        )\n\n    # Check that final shape is correct\n    if not upscaled_array.shape == target_shape:\n        if pad_with_zeros:\n            pad_width = []\n            for ax in list(range(len(target_shape))):\n                missing = target_shape[ax] - upscaled_array.shape[ax]\n                if missing &lt; 0 or (missing &gt; 0 and ax not in axis):\n                    raise ValueError(\n                        f\"{info} \" \"Something wrong during zero-padding\"\n                    )\n                pad_width.append([0, missing])\n            upscaled_array = np.pad(\n                upscaled_array,\n                pad_width=pad_width,\n                mode=\"constant\",\n                constant_values=0,\n            )\n            logging.warning(f\"{info} {upscaled_array.shape=}.\")\n            logging.warning(\n                f\"Padding upscaled_array with zeros with {pad_width=}\"\n            )\n        else:\n            raise ValueError(f\"{info} {upscaled_array.shape=}.\")\n\n    return upscaled_array\n</code></pre>"},{"location":"reference/fractal_tasks_core/utils/","title":"utils","text":"<p>Helper functions for operations on Zarr attributes and OME-NGFF metadata.</p>"},{"location":"reference/fractal_tasks_core/utils/#fractal_tasks_core.utils._find_omengff_acquisition","title":"<code>_find_omengff_acquisition(image_zarr_path)</code>","text":"<p>Discover the acquisition index based on OME-NGFF metadata.</p> <p>Given the path to a zarr image folder (e.g. <code>/path/plate.zarr/B/03/0</code>), extract the acquisition index from the <code>.zattrs</code> file of the parent folder (i.e. at the well level), or return <code>None</code> if acquisition is not specified.</p> <p>Notes:</p> <ol> <li>For non-multiplexing datasets, acquisition is not a required    information in the metadata. If it is not there, this function    returns <code>None</code>.</li> <li>This function fails if we use an image that does not belong to    an OME-NGFF well.</li> </ol> PARAMETER  DESCRIPTION <code>image_zarr_path</code> <p>Full path to an OME-NGFF image folder.</p> <p> TYPE: <code>Path</code> </p> Source code in <code>fractal_tasks_core/utils.py</code> <pre><code>def _find_omengff_acquisition(image_zarr_path: Path) -&gt; Union[int, None]:\n\"\"\"\n    Discover the acquisition index based on OME-NGFF metadata.\n\n    Given the path to a zarr image folder (e.g. `/path/plate.zarr/B/03/0`),\n    extract the acquisition index from the `.zattrs` file of the parent\n    folder (i.e. at the well level), or return `None` if acquisition is not\n    specified.\n\n    Notes:\n\n    1. For non-multiplexing datasets, acquisition is not a required\n       information in the metadata. If it is not there, this function\n       returns `None`.\n    2. This function fails if we use an image that does not belong to\n       an OME-NGFF well.\n\n    Args:\n        image_zarr_path: Full path to an OME-NGFF image folder.\n    \"\"\"\n\n    # Identify well path and attrs\n    well_zarr_path = image_zarr_path.parent\n    if not (well_zarr_path / \".zattrs\").exists():\n        raise ValueError(\n            f\"{str(well_zarr_path)} must be an OME-NGFF well \"\n            \"folder, but it does not include a .zattrs file.\"\n        )\n    well_group = zarr.open_group(str(well_zarr_path))\n    attrs_images = well_group.attrs[\"well\"][\"images\"]\n\n    # Loook for the acquisition of the current image (if any)\n    acquisition = None\n    for img_dict in attrs_images:\n        if (\n            img_dict[\"path\"] == image_zarr_path.name\n            and \"acquisition\" in img_dict.keys()\n        ):\n            acquisition = img_dict[\"acquisition\"]\n            break\n\n    return acquisition\n</code></pre>"},{"location":"reference/fractal_tasks_core/utils/#fractal_tasks_core.utils.get_parameters_from_metadata","title":"<code>get_parameters_from_metadata(*, keys, metadata, image_zarr_path)</code>","text":"<p>Flexibly extract parameters from metadata dictionary</p> <p>This covers both parameters which are acquisition-specific (if the image belongs to an OME-NGFF array and its acquisition is specified) or simply available in the dictionary. The two cases are handled as: <pre><code>metadata[acquisition][\"some_parameter\"]  # acquisition available\nmetadata[\"some_parameter\"]               # acquisition not available\n</code></pre></p> PARAMETER  DESCRIPTION <code>keys</code> <p>list of required parameters.</p> <p> TYPE: <code>Sequence[str]</code> </p> <code>metadata</code> <p>metadata dictionary.</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>image_zarr_path</code> <p>full path to image, e.g. <code>/path/plate.zarr/B/03/0</code>.</p> <p> TYPE: <code>Path</code> </p> Source code in <code>fractal_tasks_core/utils.py</code> <pre><code>def get_parameters_from_metadata(\n    *,\n    keys: Sequence[str],\n    metadata: dict[str, Any],\n    image_zarr_path: Path,\n) -&gt; dict[str, Any]:\n\"\"\"\n    Flexibly extract parameters from metadata dictionary\n\n    This covers both parameters which are acquisition-specific (if the image\n    belongs to an OME-NGFF array and its acquisition is specified) or simply\n    available in the dictionary.\n    The two cases are handled as:\n    ```\n    metadata[acquisition][\"some_parameter\"]  # acquisition available\n    metadata[\"some_parameter\"]               # acquisition not available\n    ```\n\n    Args:\n        keys: list of required parameters.\n        metadata: metadata dictionary.\n        image_zarr_path: full path to image, e.g. `/path/plate.zarr/B/03/0`.\n    \"\"\"\n\n    parameters = {}\n    acquisition = _find_omengff_acquisition(image_zarr_path)\n    if acquisition is not None:\n        parameters[\"acquisition\"] = acquisition\n\n    for key in keys:\n        if acquisition is None:\n            parameter = metadata[key]\n        else:\n            try:\n                parameter = metadata[key][str(acquisition)]\n            except TypeError:\n                parameter = metadata[key]\n            except KeyError:\n                parameter = metadata[key]\n        parameters[key] = parameter\n    return parameters\n</code></pre>"},{"location":"reference/fractal_tasks_core/utils/#fractal_tasks_core.utils.get_table_path_dict","title":"<code>get_table_path_dict(input_path, component)</code>","text":"<p>Compile dictionary of (table name, table path) key/value pairs.</p> PARAMETER  DESCRIPTION <code>input_path</code> <p>Path to the parent folder of a plate zarr group (e.g. <code>/some/path/</code>).</p> <p> TYPE: <code>Path</code> </p> <code>component</code> <p>Path (relative to <code>input_path</code>) to an image zarr group (e.g. <code>plate.zarr/B/03/0</code>).</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>dict[str, str]</code> <p>Dictionary with table names as keys and table paths as values. If <code>tables</code> Zarr group is missing, or if it does not have a <code>tables</code> key, then return an empty dictionary.</p> Source code in <code>fractal_tasks_core/utils.py</code> <pre><code>def get_table_path_dict(input_path: Path, component: str) -&gt; dict[str, str]:\n\"\"\"\n    Compile dictionary of (table name, table path) key/value pairs.\n\n\n    Args:\n        input_path:\n            Path to the parent folder of a plate zarr group (e.g.\n            `/some/path/`).\n        component:\n            Path (relative to `input_path`) to an image zarr group (e.g.\n            `plate.zarr/B/03/0`).\n\n    Returns:\n        Dictionary with table names as keys and table paths as values. If\n            `tables` Zarr group is missing, or if it does not have a `tables`\n            key, then return an empty dictionary.\n    \"\"\"\n\n    try:\n        tables_group = zarr.open_group(f\"{input_path / component}/tables\", \"r\")\n        table_list = tables_group.attrs[\"tables\"]\n    except (zarr.errors.GroupNotFoundError, KeyError):\n        table_list = []\n\n    table_path_dict = {}\n    for table in table_list:\n        table_path_dict[table] = f\"{input_path / component}/tables/{table}\"\n\n    return table_path_dict\n</code></pre>"},{"location":"reference/fractal_tasks_core/utils/#fractal_tasks_core.utils.rescale_datasets","title":"<code>rescale_datasets(*, datasets, coarsening_xy, reference_level, remove_channel_axis=False)</code>","text":"<p>Given a set of datasets (as per OME-NGFF specs), update their \"scale\" transformations in the YX directions by including a prefactor (coarsening_xy**reference_level).</p> PARAMETER  DESCRIPTION <code>datasets</code> <p>list of datasets (as per OME-NGFF specs).</p> <p> TYPE: <code>list[dict]</code> </p> <code>coarsening_xy</code> <p>linear coarsening factor between subsequent levels.</p> <p> TYPE: <code>int</code> </p> <code>reference_level</code> <p>TBD</p> <p> TYPE: <code>int</code> </p> <code>remove_channel_axis</code> <p>If <code>True</code>, remove the first item of all <code>scale</code> transformations.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>fractal_tasks_core/utils.py</code> <pre><code>def rescale_datasets(\n    *,\n    datasets: list[dict],\n    coarsening_xy: int,\n    reference_level: int,\n    remove_channel_axis: bool = False,\n) -&gt; list[dict]:\n\"\"\"\n    Given a set of datasets (as per OME-NGFF specs), update their \"scale\"\n    transformations in the YX directions by including a prefactor\n    (coarsening_xy**reference_level).\n\n    Args:\n        datasets: list of datasets (as per OME-NGFF specs).\n        coarsening_xy: linear coarsening factor between subsequent levels.\n        reference_level: TBD\n        remove_channel_axis: If `True`, remove the first item of all `scale`\n            transformations.\n    \"\"\"\n\n    # Construct rescaled datasets\n    new_datasets = []\n    for ds in datasets:\n        new_ds = {}\n\n        # Copy all keys that are not coordinateTransformations (e.g. path)\n        for key in ds.keys():\n            if key != \"coordinateTransformations\":\n                new_ds[key] = ds[key]\n\n        # Update coordinateTransformations\n        old_transformations = ds[\"coordinateTransformations\"]\n        new_transformations = []\n        for t in old_transformations:\n            if t[\"type\"] == \"scale\":\n                new_t: dict[str, Any] = t.copy()\n                # Rescale last two dimensions (that is, Y and X)\n                prefactor = coarsening_xy**reference_level\n                new_t[\"scale\"][-2] = new_t[\"scale\"][-2] * prefactor\n                new_t[\"scale\"][-1] = new_t[\"scale\"][-1] * prefactor\n                if remove_channel_axis:\n                    new_t[\"scale\"].pop(0)\n                new_transformations.append(new_t)\n            else:\n                new_transformations.append(t)\n        new_ds[\"coordinateTransformations\"] = new_transformations\n        new_datasets.append(new_ds)\n\n    return new_datasets\n</code></pre>"},{"location":"reference/fractal_tasks_core/zarr_utils/","title":"zarr_utils","text":"<p>Module with custom wrappers of the Zarr API.</p>"},{"location":"reference/fractal_tasks_core/zarr_utils/#fractal_tasks_core.zarr_utils.open_zarr_group_with_overwrite","title":"<code>open_zarr_group_with_overwrite(path, *, overwrite, logger=None, **open_group_kwargs)</code>","text":"<p>Wrap <code>zarr.open_group</code> and add <code>overwrite</code> argument.</p> <p>This wrapper sets <code>mode=\"w\"</code> for <code>overwrite=True</code> and <code>mode=\"w-\"</code> for <code>overwrite=False</code>.</p> <p>The expected behavior is</p> <ul> <li>if the group does not exist, create it (independently on <code>overwrite</code>);</li> <li>if the group already exists and <code>overwrite=True</code>, replace the group with   an empty one;</li> <li>if the group already exists and <code>overwrite=False</code>, fail.</li> </ul> <p>From the <code>zarr.open_group</code> docs:</p> <ul> <li><code>mode=\"r\"</code> means read only (must exist);</li> <li><code>mode=\"r+\"</code> means read/write (must exist);</li> <li><code>mode=\"a\"</code> means read/write (create if doesn\u2019t exist);</li> <li><code>mode=\"w\"</code> means create (overwrite if exists);</li> <li><code>mode=\"w-\"</code> means create (fail if exists).</li> </ul> PARAMETER  DESCRIPTION <code>path</code> <p>Store or path to directory in file system or name of zip file (<code>zarr.open_group</code> parameter).</p> <p> TYPE: <code>Union[str, MutableMapping]</code> </p> <code>overwrite</code> <p>Determines the <code>mode</code> parameter of <code>zarr.open_group</code>, which is <code>\"w\"</code> (if <code>overwrite=True</code>) or <code>\"w-\"</code> (if <code>overwrite=False</code>).</p> <p> TYPE: <code>bool</code> </p> <code>logger</code> <p>The logger to use (if unset, use <code>logging.getLogger(None)</code>)</p> <p> TYPE: <code>Optional[Logger]</code> DEFAULT: <code>None</code> </p> <code>open_group_kwargs</code> <p>Keyword arguments of <code>zarr.open_group</code>.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Group</code> <p>The zarr group.</p> RAISES DESCRIPTION <code>OverwriteNotAllowedError</code> <p>If <code>overwrite=False</code> and the group already exists.</p> Source code in <code>fractal_tasks_core/zarr_utils.py</code> <pre><code>def open_zarr_group_with_overwrite(\n    path: Union[str, MutableMapping],\n    *,\n    overwrite: bool,\n    logger: Optional[logging.Logger] = None,\n    **open_group_kwargs: Any,\n) -&gt; zarr.hierarchy.Group:\n\"\"\"\n    Wrap `zarr.open_group` and add `overwrite` argument.\n\n    This wrapper sets `mode=\"w\"` for `overwrite=True` and `mode=\"w-\"` for\n    `overwrite=False`.\n\n    The expected behavior is\n\n\n    * if the group does not exist, create it (independently on `overwrite`);\n    * if the group already exists and `overwrite=True`, replace the group with\n      an empty one;\n    * if the group already exists and `overwrite=False`, fail.\n\n    From the [`zarr.open_group`\n    docs](https://zarr.readthedocs.io/en/stable/api/hierarchy.html#zarr.hierarchy.open_group):\n\n    * `mode=\"r\"` means read only (must exist);\n    * `mode=\"r+\"` means read/write (must exist);\n    * `mode=\"a\"` means read/write (create if doesn\u2019t exist);\n    * `mode=\"w\"` means create (overwrite if exists);\n    * `mode=\"w-\"` means create (fail if exists).\n\n\n    Args:\n        path:\n            Store or path to directory in file system or name of zip file\n            (`zarr.open_group` parameter).\n        overwrite:\n            Determines the `mode` parameter of `zarr.open_group`, which is\n            `\"w\"` (if `overwrite=True`) or `\"w-\"` (if `overwrite=False`).\n        logger:\n            The logger to use (if unset, use `logging.getLogger(None)`)\n        open_group_kwargs:\n            Keyword arguments of `zarr.open_group`.\n\n    Returns:\n        The zarr group.\n\n    Raises:\n        OverwriteNotAllowedError:\n            If `overwrite=False` and the group already exists.\n    \"\"\"\n\n    # Set logger\n    if logger is None:\n        logger = logging.getLogger(None)\n\n    # Set mode for zarr.open_group\n    if overwrite:\n        new_mode = \"w\"\n    else:\n        new_mode = \"w-\"\n\n    # Write log about current status\n    logger.info(f\"Start open_zarr_group_with_overwrite ({overwrite=}).\")\n    try:\n        # Call `zarr.open_group` with `mode=\"r\"`, which fails for missing group\n        current_group = zarr.open_group(path, mode=\"r\")\n        keys = list(current_group.group_keys())\n        logger.info(f\"Zarr group {path} already exists, with {keys=}\")\n    except GroupNotFoundError:\n        logger.info(f\"Zarr group {path} does not exist yet.\")\n\n    # Raise warning if we are overriding an existing value of `mode`\n    if \"mode\" in open_group_kwargs.keys():\n        mode = open_group_kwargs.pop(\"mode\")\n        logger.warning(\n            f\"Overriding {mode=} with {new_mode=}, \"\n            \"in open_zarr_group_with_overwrite\"\n        )\n\n    # Call zarr.open_group\n    try:\n        return zarr.open_group(path, mode=new_mode, **open_group_kwargs)\n    except ContainsGroupError:\n        # Re-raise error with custom message and type\n        error_msg = (\n            f\"Cannot create zarr group at {path=} with `{overwrite=}` \"\n            \"(original error: `zarr.errors.ContainsGroupError`).\\n\"\n            \"Hint: try setting `overwrite=True`.\"\n        )\n        logger.error(error_msg)\n        raise OverwriteNotAllowedError(error_msg)\n</code></pre>"},{"location":"reference/fractal_tasks_core/cellvoyager/","title":"cellvoyager","text":"<p>Subpackage with utilities for tasks converting CellVoyager images to OME-Zarr.</p>"},{"location":"reference/fractal_tasks_core/cellvoyager/filenames/","title":"filenames","text":"<p>Auxiliary functions related to filenames of Yokogawa-microscope images.</p>"},{"location":"reference/fractal_tasks_core/cellvoyager/filenames/#fractal_tasks_core.cellvoyager.filenames._get_plate_name","title":"<code>_get_plate_name(plate_prefix)</code>","text":"<p>Two kinds of plate_prefix values are handled in a special way:</p> <ol> <li>Filenames from FMI, with successful barcode reading:    <code>210305NAR005AAN_210416_164828</code> with plate name <code>210305NAR005AAN</code>;</li> <li>Filenames from FMI, with failed barcode reading:    <code>yymmdd_hhmmss_210416_164828</code> with plate name <code>RS{yymmddhhmmss}</code>.</li> </ol> <p>For all non-matching filenames, plate name is <code>plate_prefix</code>.</p> PARAMETER  DESCRIPTION <code>plate_prefix</code> <p>TBD</p> <p> TYPE: <code>str</code> </p> Source code in <code>fractal_tasks_core/cellvoyager/filenames.py</code> <pre><code>def _get_plate_name(plate_prefix: str) -&gt; str:\n\"\"\"\n    Two kinds of plate_prefix values are handled in a special way:\n\n    1. Filenames from FMI, with successful barcode reading:\n       `210305NAR005AAN_210416_164828` with plate name `210305NAR005AAN`;\n    2. Filenames from FMI, with failed barcode reading:\n       `yymmdd_hhmmss_210416_164828` with plate name `RS{yymmddhhmmss}`.\n\n    For all non-matching filenames, plate name is `plate_prefix`.\n\n    Args:\n        plate_prefix: TBD\n    \"\"\"\n\n    fields = plate_prefix.split(\"_\")\n\n    # FMI (successful barcode reading)\n    if (\n        len(fields) == 3\n        and len(fields[1]) == 6\n        and len(fields[2]) == 6\n        and fields[1].isdigit()\n        and fields[2].isdigit()\n    ):\n        barcode, img_date, img_time = fields[:]\n        plate = barcode\n    # FMI (failed barcode reading)\n    elif (\n        len(fields) == 4\n        and len(fields[0]) == 6\n        and len(fields[1]) == 6\n        and len(fields[2]) == 6\n        and len(fields[3]) == 6\n        and fields[0].isdigit()\n        and fields[1].isdigit()\n        and fields[2].isdigit()\n        and fields[3].isdigit()\n    ):\n        scan_date, scan_time, img_date, img_time = fields[:]\n        plate = f\"RS{scan_date + scan_time}\"\n    # All non-matching cases\n    else:\n        plate = plate_prefix\n\n    return plate\n</code></pre>"},{"location":"reference/fractal_tasks_core/cellvoyager/filenames/#fractal_tasks_core.cellvoyager.filenames.glob_with_multiple_patterns","title":"<code>glob_with_multiple_patterns(*, folder, patterns=None)</code>","text":"<p>List all the items (files and folders) in a given folder that simultaneously match a series of glob patterns.</p> PARAMETER  DESCRIPTION <code>folder</code> <p>Base folder where items will be searched.</p> <p> TYPE: <code>str</code> </p> <code>patterns</code> <p>If specified, the list of patterns (defined as in https://docs.python.org/3/library/fnmatch.html) that item names will match with.</p> <p> TYPE: <code>Sequence[str]</code> DEFAULT: <code>None</code> </p> Source code in <code>fractal_tasks_core/cellvoyager/filenames.py</code> <pre><code>def glob_with_multiple_patterns(\n    *,\n    folder: str,\n    patterns: Sequence[str] = None,\n) -&gt; set[str]:\n\"\"\"\n    List all the items (files and folders) in a given folder that\n    simultaneously match a series of glob patterns.\n\n    Args:\n        folder: Base folder where items will be searched.\n        patterns: If specified, the list of patterns (defined as in\n            https://docs.python.org/3/library/fnmatch.html) that item\n            names will match with.\n    \"\"\"\n\n    # Sanitize base-folder path\n    if folder.endswith(\"/\"):\n        actual_folder = folder[:-1]\n    else:\n        actual_folder = folder[:]\n\n    # If not pattern is specified, look for *all* items in the base folder\n    if not patterns:\n        patterns = [\"*\"]\n\n    # Combine multiple glob searches (via set intersection)\n    logging.info(f\"[glob_with_multiple_patterns] {patterns=}\")\n    items = None\n    for pattern in patterns:\n        new_matches = glob(f\"{actual_folder}/{pattern}\")\n        if items is None:\n            items = set(new_matches)\n        else:\n            items = items.intersection(new_matches)\n    items = items or set()\n    logging.info(f\"[glob_with_multiple_patterns] Found {len(items)} items\")\n\n    return items\n</code></pre>"},{"location":"reference/fractal_tasks_core/cellvoyager/filenames/#fractal_tasks_core.cellvoyager.filenames.parse_filename","title":"<code>parse_filename(filename)</code>","text":"<p>Parse image metadata from filename.</p> PARAMETER  DESCRIPTION <code>filename</code> <p>Name of the image.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>dict[str, str]</code> <p>Metadata dictionary.</p> Source code in <code>fractal_tasks_core/cellvoyager/filenames.py</code> <pre><code>def parse_filename(filename: str) -&gt; dict[str, str]:\n\"\"\"\n    Parse image metadata from filename.\n\n    Args:\n        filename: Name of the image.\n\n    Returns:\n        Metadata dictionary.\n    \"\"\"\n\n    # Remove extension and folder from filename\n    filename = Path(filename).with_suffix(\"\").name\n\n    output = {}\n\n    # Split filename into plate_prefix + well + TFLAZC\n    filename_fields = filename.split(\"_\")\n    if len(filename_fields) &lt; 3:\n        raise ValueError(f\"{filename} not valid\")\n    output[\"plate_prefix\"] = \"_\".join(filename_fields[:-2])\n    output[\"plate\"] = _get_plate_name(output[\"plate_prefix\"])\n\n    # Assign well\n    output[\"well\"] = filename_fields[-2]\n\n    # Assign TFLAZC\n    TFLAZC = filename_fields[-1]\n    metadata = re.split(r\"([0-9]+)\", TFLAZC)\n    if metadata[-1] != \"\" or len(metadata) != 13:\n        raise ValueError(f\"Something wrong with {filename=}, {TFLAZC=}\")\n    # Remove 13-th (and last) element of the metadata list (an empty string)\n    metadata = metadata[:-1]\n    # Fill output dictionary\n    for ind, key in enumerate(metadata[::2]):\n        value = metadata[2 * ind + 1]\n        if key.isdigit() or not value.isdigit():\n            raise ValueError(\n                f\"Something wrong with {filename=}, for {key=} {value=}\"\n            )\n        output[key] = value\n    return output\n</code></pre>"},{"location":"reference/fractal_tasks_core/cellvoyager/metadata/","title":"metadata","text":"<p>Functions to create a metadata dataframe from Yokogawa files.</p>"},{"location":"reference/fractal_tasks_core/cellvoyager/metadata/#fractal_tasks_core.cellvoyager.metadata.calculate_steps","title":"<code>calculate_steps(site_series)</code>","text":"<p>TBD</p> PARAMETER  DESCRIPTION <code>site_series</code> <p>TBD</p> <p> TYPE: <code>Series</code> </p> Source code in <code>fractal_tasks_core/cellvoyager/metadata.py</code> <pre><code>def calculate_steps(site_series: pd.Series):\n\"\"\"\n    TBD\n\n    Args:\n        site_series: TBD\n    \"\"\"\n\n    # site_series is the z_micrometer series for a given site of a given\n    # channel. This function calculates the step size in Z\n\n    # First diff is always NaN because there is nothing to compare it to\n    steps = site_series.diff().dropna().astype(float)\n    if not np.allclose(steps.iloc[0], np.array(steps)):\n        raise NotImplementedError(\n            \"When parsing the Yokogawa mlf file, some sites \"\n            \"had varying step size in Z. \"\n            \"That is not supported for the OME-Zarr parsing\"\n        )\n    return steps.mean()\n</code></pre>"},{"location":"reference/fractal_tasks_core/cellvoyager/metadata/#fractal_tasks_core.cellvoyager.metadata.check_group_consistency","title":"<code>check_group_consistency(grouped_df, message='')</code>","text":"<p>TBD</p> PARAMETER  DESCRIPTION <code>grouped_df</code> <p>TBD</p> <p> TYPE: <code>DataFrame</code> </p> <code>message</code> <p>TBD</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> Source code in <code>fractal_tasks_core/cellvoyager/metadata.py</code> <pre><code>def check_group_consistency(grouped_df: pd.DataFrame, message: str = \"\"):\n\"\"\"\n    TBD\n\n    Args:\n        grouped_df: TBD\n        message: TBD\n    \"\"\"\n\n    # Check consistency in grouped df for multi-index, multi-column dataframes\n    # raises an exception if there is variability\n    diff_df = grouped_df.max() - grouped_df.min()\n    if not np.isclose(np.sum(np.sum(diff_df)), 0.0):\n        raise ValueError(\n            \"During metadata parsing, a consistency check failed: \\n\"\n            f\"{message}\\n\"\n            f\"Difference dataframe: \\n{diff_df}\"\n        )\n</code></pre>"},{"location":"reference/fractal_tasks_core/cellvoyager/metadata/#fractal_tasks_core.cellvoyager.metadata.get_earliest_time_per_site","title":"<code>get_earliest_time_per_site(mlf_frame)</code>","text":"<p>TBD</p> PARAMETER  DESCRIPTION <code>mlf_frame</code> <p>TBD</p> <p> TYPE: <code>DataFrame</code> </p> Source code in <code>fractal_tasks_core/cellvoyager/metadata.py</code> <pre><code>def get_earliest_time_per_site(mlf_frame: pd.DataFrame) -&gt; pd.DataFrame:\n\"\"\"\n    TBD\n\n    Args:\n        mlf_frame: TBD\n    \"\"\"\n\n    # Get the time information per site\n    # Because a site will contain time information for each plane\n    # of each channel, we just return the earliest time infromation\n    # per site.\n    return pd.to_datetime(\n        mlf_frame.groupby([\"well_id\", \"FieldIndex\"]).min()[\"Time\"], utc=True\n    )\n</code></pre>"},{"location":"reference/fractal_tasks_core/cellvoyager/metadata/#fractal_tasks_core.cellvoyager.metadata.get_z_steps","title":"<code>get_z_steps(mlf_frame)</code>","text":"<p>TBD</p> PARAMETER  DESCRIPTION <code>mlf_frame</code> <p>TBD</p> <p> TYPE: <code>DataFrame</code> </p> Source code in <code>fractal_tasks_core/cellvoyager/metadata.py</code> <pre><code>def get_z_steps(mlf_frame: pd.DataFrame) -&gt; pd.DataFrame:\n\"\"\"\n    TBD\n\n    Args:\n        mlf_frame: TBD\n    \"\"\"\n\n    # Process mlf_frame to extract Z information (pixel size &amp; steps).\n    # Run checks on consistencies &amp; return site-based z step dataframe\n    # Group by well, field &amp; channel\n    grouped_sites_z = (\n        mlf_frame.loc[\n            :,\n            [\"well_id\", \"FieldIndex\", \"ActionIndex\", \"Ch\", \"Z\"],\n        ]\n        .set_index([\"well_id\", \"FieldIndex\", \"ActionIndex\", \"Ch\"])\n        .groupby(level=[0, 1, 2, 3])\n    )\n\n    # If there is only 1 Z step, set the Z spacing to the count of planes =&gt; 1\n    if grouped_sites_z.count()[\"Z\"].max() == 1:\n        z_data = grouped_sites_z.count().groupby([\"well_id\", \"FieldIndex\"])\n    else:\n        # Group the whole site (combine channels), because Z steps need to be\n        # consistent between channels for OME-Zarr.\n        z_data = grouped_sites_z.apply(calculate_steps).groupby(\n            [\"well_id\", \"FieldIndex\"]\n        )\n\n    check_group_consistency(\n        z_data, message=\"Comparing Z steps between channels\"\n    )\n\n    # Ensure that channels have the same number of z planes and\n    # reduce it to one value.\n    # Only check if there is more than one channel available\n    if any(\n        grouped_sites_z.count().groupby([\"well_id\", \"FieldIndex\"]).count() &gt; 1\n    ):\n        check_group_consistency(\n            grouped_sites_z.count().groupby([\"well_id\", \"FieldIndex\"]),\n            message=\"Checking number of Z steps between channels\",\n        )\n\n    z_steps = (\n        grouped_sites_z.count()\n        .groupby([\"well_id\", \"FieldIndex\"])\n        .mean()\n        .astype(int)\n    )\n\n    # Combine the two dataframes\n    z_frame = pd.concat([z_data.mean(), z_steps], axis=1)\n    z_frame.columns = [\"pixel_size_z\", \"z_pixel\"]\n    return z_frame\n</code></pre>"},{"location":"reference/fractal_tasks_core/cellvoyager/metadata/#fractal_tasks_core.cellvoyager.metadata.parse_yokogawa_metadata","title":"<code>parse_yokogawa_metadata(mrf_path, mlf_path, *, filename_patterns=None)</code>","text":"<p>Parse Yokogawa CV7000 metadata files and prepare site-level metadata.</p> PARAMETER  DESCRIPTION <code>mrf_path</code> <p>Full path to MeasurementDetail.mrf metadata file.</p> <p> TYPE: <code>Union[str, Path]</code> </p> <code>mlf_path</code> <p>Full path to MeasurementData.mlf metadata file.</p> <p> TYPE: <code>Union[str, Path]</code> </p> <code>filename_patterns</code> <p>List of patterns to filter the image filenames in the mlf metadata table. Patterns must be defined as in https://docs.python.org/3/library/fnmatch.html</p> <p> TYPE: <code>Optional[list[str]]</code> DEFAULT: <code>None</code> </p> Source code in <code>fractal_tasks_core/cellvoyager/metadata.py</code> <pre><code>def parse_yokogawa_metadata(\n    mrf_path: Union[str, Path],\n    mlf_path: Union[str, Path],\n    *,\n    filename_patterns: Optional[list[str]] = None,\n) -&gt; tuple[pd.DataFrame, dict[str, int]]:\n\"\"\"\n    Parse Yokogawa CV7000 metadata files and prepare site-level metadata.\n\n    Args:\n        mrf_path: Full path to MeasurementDetail.mrf metadata file.\n        mlf_path: Full path to MeasurementData.mlf metadata file.\n        filename_patterns:\n            List of patterns to filter the image filenames in the mlf metadata\n            table. Patterns must be defined as in\n            https://docs.python.org/3/library/fnmatch.html\n    \"\"\"\n\n    # Convert paths to strings\n    mrf_str = Path(mrf_path).as_posix()\n    mlf_str = Path(mlf_path).as_posix()\n\n    mrf_frame, mlf_frame, error_count = read_metadata_files(\n        mrf_str, mlf_str, filename_patterns\n    )\n\n    # Aggregate information from the mlf file\n    per_site_parameters = [\"X\", \"Y\"]\n\n    grouping_params = [\"well_id\", \"FieldIndex\"]\n    grouped_sites = mlf_frame.loc[\n        :, grouping_params + per_site_parameters\n    ].groupby(by=grouping_params)\n\n    check_group_consistency(grouped_sites, message=\"X &amp; Y stage positions\")\n    site_metadata = grouped_sites.mean()\n    site_metadata.columns = [\"x_micrometer\", \"y_micrometer\"]\n    site_metadata[\"z_micrometer\"] = 0\n\n    site_metadata = pd.concat(\n        [\n            site_metadata,\n            get_z_steps(mlf_frame),\n            get_earliest_time_per_site(mlf_frame),\n        ],\n        axis=1,\n    )\n\n    # Aggregate information from the mrf file\n    mrf_columns = [\n        \"horiz_pixel_dim\",\n        \"vert_pixel_dim\",\n        \"horiz_pixels\",\n        \"vert_pixels\",\n        \"bit_depth\",\n    ]\n    check_group_consistency(\n        mrf_frame.loc[:, mrf_columns], message=\"Image dimensions\"\n    )\n    site_metadata[\"pixel_size_x\"] = mrf_frame.loc[:, \"horiz_pixel_dim\"].max()\n    site_metadata[\"pixel_size_y\"] = mrf_frame.loc[:, \"vert_pixel_dim\"].max()\n    site_metadata[\"x_pixel\"] = int(mrf_frame.loc[:, \"horiz_pixels\"].max())\n    site_metadata[\"y_pixel\"] = int(mrf_frame.loc[:, \"vert_pixels\"].max())\n    site_metadata[\"bit_depth\"] = int(mrf_frame.loc[:, \"bit_depth\"].max())\n\n    if error_count &gt; 0:\n        logger.info(\n            f\"There were {error_count} ERR entries in the metadatafile. \"\n            f\"Still succesfully parsed {len(site_metadata)} sites. \"\n        )\n\n    # Compute expected number of image files for each well\n    list_of_wells = set(site_metadata.index.get_level_values(\"well_id\"))\n    number_of_files = {}\n    for this_well_id in list_of_wells:\n        num_images = (mlf_frame.well_id == this_well_id).sum()\n        logger.info(\n            f\"Expected number of images for well {this_well_id}: {num_images}\"\n        )\n        number_of_files[this_well_id] = num_images\n    # Check that the sum of per-well file numbers correspond to the total\n    # file number\n    if not sum(number_of_files.values()) == len(mlf_frame):\n        raise ValueError(\n            \"Error while counting the number of image files per well.\\n\"\n            f\"{len(mlf_frame)=}\\n\"\n            f\"{number_of_files=}\"\n        )\n\n    return site_metadata, number_of_files\n</code></pre>"},{"location":"reference/fractal_tasks_core/cellvoyager/metadata/#fractal_tasks_core.cellvoyager.metadata.read_metadata_files","title":"<code>read_metadata_files(mrf_path, mlf_path, filename_patterns=None)</code>","text":"<p>TBD</p> PARAMETER  DESCRIPTION <code>mrf_path</code> <p>Full path to MeasurementDetail.mrf metadata file.</p> <p> TYPE: <code>str</code> </p> <code>mlf_path</code> <p>Full path to MeasurementData.mlf metadata file.</p> <p> TYPE: <code>str</code> </p> <code>filename_patterns</code> <p>List of patterns to filter the image filenames in the mlf metadata table. Patterns must be defined as in https://docs.python.org/3/library/fnmatch.html.</p> <p> TYPE: <code>Optional[list[str]]</code> DEFAULT: <code>None</code> </p> Source code in <code>fractal_tasks_core/cellvoyager/metadata.py</code> <pre><code>def read_metadata_files(\n    mrf_path: str,\n    mlf_path: str,\n    filename_patterns: Optional[list[str]] = None,\n) -&gt; tuple[pd.DataFrame, pd.DataFrame, int]:\n\"\"\"\n    TBD\n\n    Args:\n        mrf_path: Full path to MeasurementDetail.mrf metadata file.\n        mlf_path: Full path to MeasurementData.mlf metadata file.\n        filename_patterns: List of patterns to filter the image filenames in\n            the mlf metadata table. Patterns must be defined as in\n            https://docs.python.org/3/library/fnmatch.html.\n    \"\"\"\n\n    # parsing of mrf &amp; mlf files are based on the\n    # yokogawa_image_collection_task v0.5 in drogon, written by Dario Vischi.\n    # https://github.com/fmi-basel/job-system-workflows/blob/00bbf34448972d27f258a2c28245dd96180e8229/src/gliberal_workflows/tasks/yokogawa_image_collection_task/versions/version_0_5.py  # noqa\n    # Now modified for Fractal use\n\n    mrf_frame = read_mrf_file(mrf_path)\n    # TODO: filter_position &amp; filter_wheel_position are parsed, but not\n    # processed further. Figure out how to save them as relevant metadata for\n    # use e.g. during illumination correction\n\n    mlf_frame, error_count = read_mlf_file(mlf_path, filename_patterns)\n    # TODO: Time points are parsed as part of the mlf_frame, but currently not\n    # processed further. Once we tackle time-resolved data, parse from here.\n\n    return mrf_frame, mlf_frame, error_count\n</code></pre>"},{"location":"reference/fractal_tasks_core/cellvoyager/metadata/#fractal_tasks_core.cellvoyager.metadata.read_mlf_file","title":"<code>read_mlf_file(mlf_path, filename_patterns=None)</code>","text":"<p>TBD</p> PARAMETER  DESCRIPTION <code>mlf_path</code> <p>Full path to MeasurementData.mlf metadata file.</p> <p> TYPE: <code>str</code> </p> <code>filename_patterns</code> <p>List of patterns to filter the image filenames in the mlf metadata table. Patterns must be defined as in https://docs.python.org/3/library/fnmatch.html.</p> <p> TYPE: <code>Optional[list[str]]</code> DEFAULT: <code>None</code> </p> Source code in <code>fractal_tasks_core/cellvoyager/metadata.py</code> <pre><code>def read_mlf_file(\n    mlf_path: str,\n    filename_patterns: Optional[list[str]] = None,\n) -&gt; tuple[pd.DataFrame, int]:\n\"\"\"\n    TBD\n\n    Args:\n        mlf_path: Full path to MeasurementData.mlf metadata file.\n        filename_patterns: List of patterns to filter the image filenames in\n            the mlf metadata table. Patterns must be defined as in\n            https://docs.python.org/3/library/fnmatch.html.\n    \"\"\"\n\n    # Load the whole MeasurementData.mlf file\n    mlf_frame_raw = pd.read_xml(mlf_path)\n\n    # Remove all rows that do not match the given patterns\n    logger.info(\n        f\"Read {mlf_path}, and apply following patterns to \"\n        f\"image filenames: {filename_patterns}\"\n    )\n    if filename_patterns:\n        filenames = mlf_frame_raw.MeasurementRecord\n        keep_row = None\n        for pattern in filename_patterns:\n            actual_pattern = fnmatch.translate(pattern)\n            new_matches = filenames.str.fullmatch(actual_pattern)\n            if new_matches.sum() == 0:\n                raise ValueError(\n                    f\"In {mlf_path} there is no image filename \"\n                    f'matching \"{actual_pattern}\".'\n                )\n            if keep_row is None:\n                keep_row = new_matches.copy()\n            else:\n                keep_row = keep_row &amp; new_matches\n        if keep_row.sum() == 0:\n            raise ValueError(\n                f\"In {mlf_path} there is no image filename \"\n                f\"matching {filename_patterns}.\"\n            )\n        mlf_frame_matching = mlf_frame_raw[keep_row.values].copy()\n    else:\n        mlf_frame_matching = mlf_frame_raw.copy()\n\n    # Create a well ID column\n    row_str = [chr(x) for x in (mlf_frame_matching[\"Row\"] + 64)]\n    mlf_frame_matching[\"well_id\"] = [\n        f\"{a}{b:02}\" for a, b in zip(row_str, mlf_frame_matching[\"Column\"])\n    ]\n\n    # Flip Y axis to align to image coordinate system\n    mlf_frame_matching[\"Y\"] = -mlf_frame_matching[\"Y\"]\n\n    # Compute number or errors\n    error_count = (mlf_frame_matching[\"Type\"] == \"ERR\").sum()\n\n    # We're only interested in the image metadata\n    mlf_frame = mlf_frame_matching[mlf_frame_matching[\"Type\"] == \"IMG\"]\n\n    return mlf_frame, error_count\n</code></pre>"},{"location":"reference/fractal_tasks_core/cellvoyager/metadata/#fractal_tasks_core.cellvoyager.metadata.read_mrf_file","title":"<code>read_mrf_file(mrf_path)</code>","text":"<p>TBD</p> PARAMETER  DESCRIPTION <code>mrf_path</code> <p>Full path to MeasurementDetail.mrf metadata file.</p> <p> TYPE: <code>str</code> </p> Source code in <code>fractal_tasks_core/cellvoyager/metadata.py</code> <pre><code>def read_mrf_file(mrf_path: str):\n\"\"\"\n    TBD\n\n    Args:\n        mrf_path: Full path to MeasurementDetail.mrf metadata file.\n    \"\"\"\n\n    # Prepare mrf dataframe\n    mrf_columns = [\n        \"channel_id\",\n        \"horiz_pixel_dim\",\n        \"vert_pixel_dim\",\n        \"camera_no\",\n        \"bit_depth\",\n        \"horiz_pixels\",\n        \"vert_pixels\",\n        \"filter_wheel_position\",\n        \"filter_position\",\n        \"shading_corr_src\",\n    ]\n    mrf_frame = pd.DataFrame(columns=mrf_columns)\n\n    mrf_xml = ElementTree.parse(mrf_path).getroot()\n    # Read mrf file\n    ns = {\"bts\": \"http://www.yokogawa.co.jp/BTS/BTSSchema/1.0\"}\n    for channel in mrf_xml.findall(\"bts:MeasurementChannel\", namespaces=ns):\n        mrf_frame.loc[channel.get(\"{%s}Ch\" % ns[\"bts\"])] = [\n            channel.get(\"{%s}Ch\" % ns[\"bts\"]),\n            float(channel.get(\"{%s}HorizontalPixelDimension\" % ns[\"bts\"])),\n            float(channel.get(\"{%s}VerticalPixelDimension\" % ns[\"bts\"])),\n            int(channel.get(\"{%s}CameraNumber\" % ns[\"bts\"])),\n            int(channel.get(\"{%s}InputBitDepth\" % ns[\"bts\"])),\n            int(channel.get(\"{%s}HorizontalPixels\" % ns[\"bts\"])),\n            int(channel.get(\"{%s}VerticalPixels\" % ns[\"bts\"])),\n            int(channel.get(\"{%s}FilterWheelPosition\" % ns[\"bts\"])),\n            int(channel.get(\"{%s}FilterPosition\" % ns[\"bts\"])),\n            channel.get(\"{%s}ShadingCorrectionSource\" % ns[\"bts\"]),\n        ]\n\n    return mrf_frame\n</code></pre>"},{"location":"reference/fractal_tasks_core/dev/","title":"dev","text":"<p>Development-tools subpackage (e.g. for the creation of JSON Schemas for task parameters).</p>"},{"location":"reference/fractal_tasks_core/dev/check_manifest/","title":"check_manifest","text":"<p>Script to check that JSON schemas for task arguments (as reported in the package manfest) are up-to-date.</p>"},{"location":"reference/fractal_tasks_core/dev/check_manifest/#fractal_tasks_core.dev.check_manifest._compare_dicts","title":"<code>_compare_dicts(old, new, path=[])</code>","text":"<p>Provide more informative comparison of two (possibly nested) dictionaries.</p> PARAMETER  DESCRIPTION <code>old</code> <p>TBD</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>new</code> <p>TBD</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>path</code> <p>TBD</p> <p> TYPE: <code>list[str]</code> DEFAULT: <code>[]</code> </p> Source code in <code>fractal_tasks_core/dev/check_manifest.py</code> <pre><code>def _compare_dicts(\n    old: dict[str, Any], new: dict[str, Any], path: list[str] = []\n):\n\"\"\"\n    Provide more informative comparison of two (possibly nested) dictionaries.\n\n    Args:\n        old: TBD\n        new: TBD\n        path: TBD\n    \"\"\"\n    path_str = \"/\".join(path)\n    keys_old = set(old.keys())\n    keys_new = set(new.keys())\n    if not keys_old == keys_new:\n        msg = (\n            \"\\n\\n\"\n            f\"Dictionaries at path {path_str} have different keys:\\n\\n\"\n            f\"OLD KEYS:\\n{keys_old}\\n\\n\"\n            f\"NEW KEYS:\\n{keys_new}\\n\\n\"\n        )\n        raise ValueError(msg)\n    for key, value_old in old.items():\n        value_new = new[key]\n        if type(value_old) != type(value_new):\n            msg = (\n                \"\\n\\n\"\n                f\"Values at path {path_str}/{key} \"\n                \"have different types:\\n\\n\"\n                f\"OLD TYPE:\\n{type(value_old)}\\n\\n\"\n                f\"NEW TYPE:\\n{type(value_new)}\\n\\n\"\n            )\n            raise ValueError(msg)\n        if isinstance(value_old, dict):\n            _compare_dicts(value_old, value_new, path=path + [key])\n        else:\n            if value_old != value_new:\n                msg = (\n                    \"\\n\\n\"\n                    f\"Values at path {path_str}/{key} \"\n                    \"are different:\\n\\n\"\n                    f\"OLD VALUE:\\n{value_old}\\n\\n\"\n                    f\"NEW VALUE:\\n{value_new}\\n\\n\"\n                )\n                raise ValueError(msg)\n</code></pre>"},{"location":"reference/fractal_tasks_core/dev/lib_args_schemas/","title":"lib_args_schemas","text":"<p>Helper functions to handle JSON schemas for task arguments.</p>"},{"location":"reference/fractal_tasks_core/dev/lib_args_schemas/#fractal_tasks_core.dev.lib_args_schemas._remove_args_kwargs_properties","title":"<code>_remove_args_kwargs_properties(old_schema)</code>","text":"<p>Remove <code>args</code> and <code>kwargs</code> schema properties.</p> <p>Pydantic v1 automatically includes <code>args</code> and <code>kwargs</code> properties in JSON Schemas generated via <code>ValidatedFunction(task_function, config=None).model.schema()</code>, with some default (empty) values -- see see https://github.com/pydantic/pydantic/blob/1.10.X-fixes/pydantic/decorator.py.</p> <p>Verify that these properties match with their expected default values, and then remove them from the schema.</p> PARAMETER  DESCRIPTION <code>old_schema</code> <p>TBD</p> <p> TYPE: <code>_Schema</code> </p> Source code in <code>fractal_tasks_core/dev/lib_args_schemas.py</code> <pre><code>def _remove_args_kwargs_properties(old_schema: _Schema) -&gt; _Schema:\n\"\"\"\n    Remove `args` and `kwargs` schema properties.\n\n    Pydantic v1 automatically includes `args` and `kwargs` properties in\n    JSON Schemas generated via `ValidatedFunction(task_function,\n    config=None).model.schema()`, with some default (empty) values -- see see\n    https://github.com/pydantic/pydantic/blob/1.10.X-fixes/pydantic/decorator.py.\n\n    Verify that these properties match with their expected default values, and\n    then remove them from the schema.\n\n    Args:\n        old_schema: TBD\n    \"\"\"\n    new_schema = old_schema.copy()\n    args_property = new_schema[\"properties\"].pop(\"args\")\n    kwargs_property = new_schema[\"properties\"].pop(\"kwargs\")\n    expected_args_property = {\"title\": \"Args\", \"type\": \"array\", \"items\": {}}\n    expected_kwargs_property = {\"title\": \"Kwargs\", \"type\": \"object\"}\n    if args_property != expected_args_property:\n        raise ValueError(\n            f\"{args_property=}\\ndiffers from\\n{expected_args_property=}\"\n        )\n    if kwargs_property != expected_kwargs_property:\n        raise ValueError(\n            f\"{kwargs_property=}\\ndiffers from\\n\"\n            f\"{expected_kwargs_property=}\"\n        )\n    logging.info(\"[_remove_args_kwargs_properties] END\")\n    return new_schema\n</code></pre>"},{"location":"reference/fractal_tasks_core/dev/lib_args_schemas/#fractal_tasks_core.dev.lib_args_schemas._remove_attributes_from_descriptions","title":"<code>_remove_attributes_from_descriptions(old_schema)</code>","text":"<p>Keeps only the description part of the docstrings: e.g from <pre><code>'Custom class for Omero-channel window, based on OME-NGFF v0.4.\\n'\n'\\n'\n'Attributes:\\n'\n'min: Do not change. It will be set to `0` by default.\\n'\n'max: Do not change. It will be set according to bitdepth of the images\\n'\n'    by default (e.g. 65535 for 16 bit images).\\n'\n'start: Lower-bound rescaling value for visualization.\\n'\n'end: Upper-bound rescaling value for visualization.'\n</code></pre> to <code>'Custom class for Omero-channel window, based on OME-NGFF v0.4.\\n'</code>.</p> PARAMETER  DESCRIPTION <code>old_schema</code> <p>TBD</p> <p> TYPE: <code>_Schema</code> </p> Source code in <code>fractal_tasks_core/dev/lib_args_schemas.py</code> <pre><code>def _remove_attributes_from_descriptions(old_schema: _Schema) -&gt; _Schema:\n\"\"\"\n    Keeps only the description part of the docstrings: e.g from\n    ```\n    'Custom class for Omero-channel window, based on OME-NGFF v0.4.\\\\n'\n    '\\\\n'\n    'Attributes:\\\\n'\n    'min: Do not change. It will be set to `0` by default.\\\\n'\n    'max: Do not change. It will be set according to bitdepth of the images\\\\n'\n    '    by default (e.g. 65535 for 16 bit images).\\\\n'\n    'start: Lower-bound rescaling value for visualization.\\\\n'\n    'end: Upper-bound rescaling value for visualization.'\n    ```\n    to `'Custom class for Omero-channel window, based on OME-NGFF v0.4.\\\\n'`.\n\n    Args:\n        old_schema: TBD\n    \"\"\"\n    new_schema = old_schema.copy()\n    if \"definitions\" in new_schema:\n        for name, definition in new_schema[\"definitions\"].items():\n            parsed_docstring = docparse(definition[\"description\"])\n            new_schema[\"definitions\"][name][\n                \"description\"\n            ] = parsed_docstring.short_description\n    logging.info(\"[_remove_attributes_from_descriptions] END\")\n    return new_schema\n</code></pre>"},{"location":"reference/fractal_tasks_core/dev/lib_args_schemas/#fractal_tasks_core.dev.lib_args_schemas._remove_pydantic_internals","title":"<code>_remove_pydantic_internals(old_schema)</code>","text":"<p>Remove schema properties that are only used internally by Pydantic V1.</p> PARAMETER  DESCRIPTION <code>old_schema</code> <p>TBD</p> <p> TYPE: <code>_Schema</code> </p> Source code in <code>fractal_tasks_core/dev/lib_args_schemas.py</code> <pre><code>def _remove_pydantic_internals(old_schema: _Schema) -&gt; _Schema:\n\"\"\"\n    Remove schema properties that are only used internally by Pydantic V1.\n\n    Args:\n        old_schema: TBD\n    \"\"\"\n    new_schema = old_schema.copy()\n    for key in (\n        V_POSITIONAL_ONLY_NAME,\n        V_DUPLICATE_KWARGS,\n        ALT_V_ARGS,\n        ALT_V_KWARGS,\n    ):\n        new_schema[\"properties\"].pop(key, None)\n    logging.info(\"[_remove_pydantic_internals] END\")\n    return new_schema\n</code></pre>"},{"location":"reference/fractal_tasks_core/dev/lib_args_schemas/#fractal_tasks_core.dev.lib_args_schemas.create_schema_for_single_task","title":"<code>create_schema_for_single_task(executable, package='fractal_tasks_core', custom_pydantic_models=None)</code>","text":"<p>Main function to create a JSON Schema of task arguments</p> Source code in <code>fractal_tasks_core/dev/lib_args_schemas.py</code> <pre><code>def create_schema_for_single_task(\n    executable: str,\n    package: str = \"fractal_tasks_core\",\n    custom_pydantic_models: Optional[list[tuple[str, str, str]]] = None,\n) -&gt; _Schema:\n\"\"\"\n    Main function to create a JSON Schema of task arguments\n    \"\"\"\n\n    logging.info(\"[create_schema_for_single_task] START\")\n\n    # Extract the function name. Note: this could be made more general, but for\n    # the moment we assume the function has the same name as the module)\n    function_name = Path(executable).with_suffix(\"\").name\n    logging.info(f\"[create_schema_for_single_task] {function_name=}\")\n\n    # Extract function from module\n    task_function = _extract_function(\n        package_name=package,\n        module_relative_path=executable,\n        function_name=function_name,\n    )\n\n    logging.info(f\"[create_schema_for_single_task] {task_function=}\")\n\n    # Validate function signature against some custom constraints\n    _validate_function_signature(task_function)\n\n    # Create and clean up schema\n    vf = ValidatedFunction(task_function, config=None)\n    schema = vf.model.schema()\n    schema = _remove_args_kwargs_properties(schema)\n    schema = _remove_pydantic_internals(schema)\n    schema = _remove_attributes_from_descriptions(schema)\n\n    # Include titles for custom-model-typed arguments\n    schema = _include_titles(schema)\n\n    # Include descriptions of function arguments\n    function_args_descriptions = _get_function_args_descriptions(\n        package_name=package,\n        module_relative_path=executable,\n        function_name=function_name,\n    )\n    schema = _insert_function_args_descriptions(\n        schema=schema, descriptions=function_args_descriptions\n    )\n\n    # Merge lists of fractal-tasks-core and user-provided Pydantic models\n    user_provided_models = custom_pydantic_models or []\n    pydantic_models = FRACTAL_TASKS_CORE_PYDANTIC_MODELS + user_provided_models\n\n    # Check that model names are unique\n    pydantic_models_names = [item[2] for item in pydantic_models]\n    duplicate_class_names = [\n        name\n        for name, count in Counter(pydantic_models_names).items()\n        if count &gt; 1\n    ]\n    if duplicate_class_names:\n        pydantic_models_str = \"  \" + \"\\n  \".join(map(str, pydantic_models))\n        raise ValueError(\n            \"Cannot parse docstrings for models with non-unique names \"\n            f\"{duplicate_class_names}, in\\n{pydantic_models_str}\"\n        )\n\n    # Extract model-attribute descriptions and insert them into schema\n    for package_name, module_relative_path, class_name in pydantic_models:\n        attrs_descriptions = _get_class_attrs_descriptions(\n            package_name=package_name,\n            module_relative_path=module_relative_path,\n            class_name=class_name,\n        )\n        schema = _insert_class_attrs_descriptions(\n            schema=schema,\n            class_name=class_name,\n            descriptions=attrs_descriptions,\n        )\n\n    logging.info(\"[create_schema_for_single_task] END\")\n    return schema\n</code></pre>"},{"location":"reference/fractal_tasks_core/dev/lib_descriptions/","title":"lib_descriptions","text":""},{"location":"reference/fractal_tasks_core/dev/lib_descriptions/#fractal_tasks_core.dev.lib_descriptions._get_class_attrs_descriptions","title":"<code>_get_class_attrs_descriptions(package_name, module_relative_path, class_name)</code>","text":"<p>Extract attribute descriptions from a class.</p> PARAMETER  DESCRIPTION <code>package_name</code> <p>Example <code>fractal_tasks_core</code>.</p> <p> TYPE: <code>str</code> </p> <code>module_relative_path</code> <p>Example <code>lib_channels.py</code>.</p> <p> TYPE: <code>str</code> </p> <code>class_name</code> <p>Example <code>OmeroChannel</code>.</p> <p> TYPE: <code>str</code> </p> Source code in <code>fractal_tasks_core/dev/lib_descriptions.py</code> <pre><code>def _get_class_attrs_descriptions(\n    package_name: str, module_relative_path: str, class_name: str\n) -&gt; dict[str, str]:\n\"\"\"\n    Extract attribute descriptions from a class.\n\n    Args:\n        package_name: Example `fractal_tasks_core`.\n        module_relative_path: Example `lib_channels.py`.\n        class_name: Example `OmeroChannel`.\n    \"\"\"\n\n    if not module_relative_path.endswith(\".py\"):\n        raise ValueError(f\"Module {module_relative_path} must end with '.py'\")\n\n    # Get the class ast.ClassDef object\n    package_path = Path(import_module(package_name).__file__).parent\n    module_path = package_path / module_relative_path\n    tree = ast.parse(module_path.read_text())\n    try:\n        _class = next(\n            c\n            for c in ast.walk(tree)\n            if (isinstance(c, ast.ClassDef) and c.name == class_name)\n        )\n    except StopIteration:\n        raise RuntimeError(\n            f\"Cannot find {class_name=} for {package_name=} \"\n            f\"and {module_relative_path=}\"\n        )\n    docstring = ast.get_docstring(_class)\n    parsed_docstring = docparse(docstring)\n    descriptions = {\n        x.arg_name: _sanitize_description(x.description)\n        if x.description\n        else \"Missing description\"\n        for x in parsed_docstring.params\n    }\n    logging.info(f\"[_get_class_attrs_descriptions] END ({class_name=})\")\n    return descriptions\n</code></pre>"},{"location":"reference/fractal_tasks_core/dev/lib_descriptions/#fractal_tasks_core.dev.lib_descriptions._get_function_args_descriptions","title":"<code>_get_function_args_descriptions(package_name, module_relative_path, function_name)</code>","text":"<p>Extract argument descriptions from a function.</p> PARAMETER  DESCRIPTION <code>package_name</code> <p>Example <code>fractal_tasks_core</code>.</p> <p> TYPE: <code>str</code> </p> <code>module_relative_path</code> <p>Example <code>tasks/create_ome_zarr.py</code>.</p> <p> TYPE: <code>str</code> </p> <code>function_name</code> <p>Example <code>create_ome_zarr</code>.</p> <p> TYPE: <code>str</code> </p> Source code in <code>fractal_tasks_core/dev/lib_descriptions.py</code> <pre><code>def _get_function_args_descriptions(\n    package_name: str, module_relative_path: str, function_name: str\n) -&gt; dict[str, str]:\n\"\"\"\n    Extract argument descriptions from a function.\n\n    Args:\n        package_name: Example `fractal_tasks_core`.\n        module_relative_path: Example `tasks/create_ome_zarr.py`.\n        function_name: Example `create_ome_zarr`.\n    \"\"\"\n\n    # Extract docstring from ast.FunctionDef\n    docstring = _get_function_docstring(\n        package_name, module_relative_path, function_name\n    )\n\n    # Parse docstring (via docstring_parser) and prepare output\n    parsed_docstring = docparse(docstring)\n    descriptions = {\n        param.arg_name: _sanitize_description(param.description)\n        for param in parsed_docstring.params\n    }\n    logging.info(f\"[_get_function_args_descriptions] END ({function_name=})\")\n    return descriptions\n</code></pre>"},{"location":"reference/fractal_tasks_core/dev/lib_descriptions/#fractal_tasks_core.dev.lib_descriptions._get_function_docstring","title":"<code>_get_function_docstring(package_name, module_relative_path, function_name)</code>","text":"<p>Extract docstring from a function.</p> PARAMETER  DESCRIPTION <code>package_name</code> <p>Example <code>fractal_tasks_core</code>.</p> <p> TYPE: <code>str</code> </p> <code>module_relative_path</code> <p>Example <code>tasks/create_ome_zarr.py</code>.</p> <p> TYPE: <code>str</code> </p> <code>function_name</code> <p>Example <code>create_ome_zarr</code>.</p> <p> TYPE: <code>str</code> </p> Source code in <code>fractal_tasks_core/dev/lib_descriptions.py</code> <pre><code>def _get_function_docstring(\n    package_name: str, module_relative_path: str, function_name: str\n) -&gt; str:\n\"\"\"\n    Extract docstring from a function.\n\n    Args:\n        package_name: Example `fractal_tasks_core`.\n        module_relative_path: Example `tasks/create_ome_zarr.py`.\n        function_name: Example `create_ome_zarr`.\n    \"\"\"\n\n    if not module_relative_path.endswith(\".py\"):\n        raise ValueError(f\"Module {module_relative_path} must end with '.py'\")\n\n    # Get the function ast.FunctionDef object\n    package_path = Path(import_module(package_name).__file__).parent\n    module_path = package_path / module_relative_path\n    tree = ast.parse(module_path.read_text())\n    _function = next(\n        f\n        for f in ast.walk(tree)\n        if (isinstance(f, ast.FunctionDef) and f.name == function_name)\n    )\n\n    # Extract docstring from ast.FunctionDef\n    return ast.get_docstring(_function)\n</code></pre>"},{"location":"reference/fractal_tasks_core/dev/lib_descriptions/#fractal_tasks_core.dev.lib_descriptions._insert_class_attrs_descriptions","title":"<code>_insert_class_attrs_descriptions(*, schema, class_name, descriptions)</code>","text":"<p>Merge the descriptions obtained via <code>_get_attributes_models_descriptions</code> into the <code>class_name</code> definition, within an existing JSON Schema</p> PARAMETER  DESCRIPTION <code>schema</code> <p>TBD</p> <p> TYPE: <code>dict</code> </p> <code>class_name</code> <p>TBD</p> <p> TYPE: <code>str</code> </p> <code>descriptions</code> <p>TBD</p> <p> TYPE: <code>dict</code> </p> Source code in <code>fractal_tasks_core/dev/lib_descriptions.py</code> <pre><code>def _insert_class_attrs_descriptions(\n    *, schema: dict, class_name: str, descriptions: dict\n):\n\"\"\"\n    Merge the descriptions obtained via `_get_attributes_models_descriptions`\n    into the `class_name` definition, within an existing JSON Schema\n\n    Args:\n        schema: TBD\n        class_name: TBD\n        descriptions: TBD\n    \"\"\"\n    new_schema = schema.copy()\n    if \"definitions\" not in schema:\n        return new_schema\n    else:\n        new_definitions = schema[\"definitions\"].copy()\n    # Loop over existing definitions\n    for name, definition in schema[\"definitions\"].items():\n        if name == class_name:\n            for prop in definition[\"properties\"]:\n                if \"description\" in new_definitions[name][\"properties\"][prop]:\n                    raise ValueError(\n                        f\"Property {name}.{prop} already has description\"\n                    )\n                else:\n                    new_definitions[name][\"properties\"][prop][\n                        \"description\"\n                    ] = descriptions[prop]\n    new_schema[\"definitions\"] = new_definitions\n    logging.info(\"[_insert_class_attrs_descriptions] END\")\n    return new_schema\n</code></pre>"},{"location":"reference/fractal_tasks_core/dev/lib_descriptions/#fractal_tasks_core.dev.lib_descriptions._insert_function_args_descriptions","title":"<code>_insert_function_args_descriptions(*, schema, descriptions)</code>","text":"<p>Merge the descriptions obtained via <code>_get_args_descriptions</code> into the properties of an existing JSON Schema.</p> PARAMETER  DESCRIPTION <code>schema</code> <p>TBD</p> <p> TYPE: <code>dict</code> </p> <code>descriptions</code> <p>TBD</p> <p> TYPE: <code>dict</code> </p> Source code in <code>fractal_tasks_core/dev/lib_descriptions.py</code> <pre><code>def _insert_function_args_descriptions(*, schema: dict, descriptions: dict):\n\"\"\"\n    Merge the descriptions obtained via `_get_args_descriptions` into the\n    properties of an existing JSON Schema.\n\n    Args:\n        schema: TBD\n        descriptions: TBD\n    \"\"\"\n    new_schema = schema.copy()\n    new_properties = schema[\"properties\"].copy()\n    for key, value in schema[\"properties\"].items():\n        if \"description\" in value:\n            raise ValueError(\"Property already has description\")\n        else:\n            if key in descriptions:\n                value[\"description\"] = descriptions[key]\n            else:\n                value[\"description\"] = \"Missing description\"\n            new_properties[key] = value\n    new_schema[\"properties\"] = new_properties\n    logging.info(\"[_insert_function_args_descriptions] END\")\n    return new_schema\n</code></pre>"},{"location":"reference/fractal_tasks_core/dev/lib_descriptions/#fractal_tasks_core.dev.lib_descriptions._sanitize_description","title":"<code>_sanitize_description(string)</code>","text":"<p>Sanitize a description string.</p> <p>This is a provisional helper function that replaces newlines with spaces and reduces multiple contiguous whitespace characters to a single one. Future iterations of the docstrings format/parsing may render this function not-needed or obsolete.</p> PARAMETER  DESCRIPTION <code>string</code> <p>TBD</p> <p> TYPE: <code>str</code> </p> Source code in <code>fractal_tasks_core/dev/lib_descriptions.py</code> <pre><code>def _sanitize_description(string: str) -&gt; str:\n\"\"\"\n    Sanitize a description string.\n\n    This is a provisional helper function that replaces newlines with spaces\n    and reduces multiple contiguous whitespace characters to a single one.\n    Future iterations of the docstrings format/parsing may render this function\n    not-needed or obsolete.\n\n    Args:\n        string: TBD\n    \"\"\"\n    # Replace newline with space\n    new_string = string.replace(\"\\n\", \" \")\n    # Replace N-whitespace characterss with a single one\n    while \"  \" in new_string:\n        new_string = new_string.replace(\"  \", \" \")\n    return new_string\n</code></pre>"},{"location":"reference/fractal_tasks_core/dev/lib_signature_constraints/","title":"lib_signature_constraints","text":""},{"location":"reference/fractal_tasks_core/dev/lib_signature_constraints/#fractal_tasks_core.dev.lib_signature_constraints._extract_function","title":"<code>_extract_function(module_relative_path, function_name, package_name='fractal_tasks_core')</code>","text":"<p>Extract function from a module with the same name.</p> PARAMETER  DESCRIPTION <code>package_name</code> <p>Example <code>fractal_tasks_core</code>.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'fractal_tasks_core'</code> </p> <code>module_relative_path</code> <p>Example <code>tasks/create_ome_zarr.py</code>.</p> <p> TYPE: <code>str</code> </p> <code>function_name</code> <p>Example <code>create_ome_zarr</code>.</p> <p> TYPE: <code>str</code> </p> Source code in <code>fractal_tasks_core/dev/lib_signature_constraints.py</code> <pre><code>def _extract_function(\n    module_relative_path: str,\n    function_name: str,\n    package_name: str = \"fractal_tasks_core\",\n) -&gt; Callable:\n\"\"\"\n    Extract function from a module with the same name.\n\n    Args:\n        package_name: Example `fractal_tasks_core`.\n        module_relative_path: Example `tasks/create_ome_zarr.py`.\n        function_name: Example `create_ome_zarr`.\n    \"\"\"\n    if not module_relative_path.endswith(\".py\"):\n        raise ValueError(f\"{module_relative_path=} must end with '.py'\")\n    module_relative_path_no_py = str(\n        Path(module_relative_path).with_suffix(\"\")\n    )\n    module_relative_path_dots = module_relative_path_no_py.replace(\"/\", \".\")\n    module = import_module(f\"{package_name}.{module_relative_path_dots}\")\n    task_function = getattr(module, function_name)\n    return task_function\n</code></pre>"},{"location":"reference/fractal_tasks_core/dev/lib_signature_constraints/#fractal_tasks_core.dev.lib_signature_constraints._validate_function_signature","title":"<code>_validate_function_signature(function)</code>","text":"<p>Validate the function signature.</p> <p>Implement a set of checks for type hints that do not play well with the creation of JSON Schema, see https://github.com/fractal-analytics-platform/fractal-tasks-core/issues/399.</p> PARAMETER  DESCRIPTION <code>function</code> <p>TBD</p> <p> TYPE: <code>Callable</code> </p> Source code in <code>fractal_tasks_core/dev/lib_signature_constraints.py</code> <pre><code>def _validate_function_signature(function: Callable):\n\"\"\"\n    Validate the function signature.\n\n    Implement a set of checks for type hints that do not play well with the\n    creation of JSON Schema, see\n    https://github.com/fractal-analytics-platform/fractal-tasks-core/issues/399.\n\n    Args:\n        function: TBD\n    \"\"\"\n    sig = signature(function)\n    for param in sig.parameters.values():\n\n        # CASE 1: Check that name is not forbidden\n        if param.name in FORBIDDEN_PARAM_NAMES:\n            raise ValueError(\n                f\"Function {function} has argument with name {param.name}\"\n            )\n\n        # CASE 2: Raise an error for unions\n        if str(param.annotation).startswith((\"typing.Union[\", \"Union[\")):\n            raise ValueError(\"typing.Union is not supported\")\n\n        # CASE 3: Raise an error for \"|\"\n        if \"|\" in str(param.annotation):\n            raise ValueError('Use of \"|\" in type hints is not supported')\n\n        # CASE 4: Raise an error for optional parameter with given (non-None)\n        # default, e.g. Optional[str] = \"asd\"\n        is_annotation_optional = str(param.annotation).startswith(\n            (\"typing.Optional[\", \"Optional[\")\n        )\n        default_given = (param.default is not None) and (\n            param.default != inspect._empty\n        )\n        if default_given and is_annotation_optional:\n            raise ValueError(\"Optional parameter has non-None default value\")\n\n    logging.info(\"[_validate_function_signature] END\")\n    return sig\n</code></pre>"},{"location":"reference/fractal_tasks_core/dev/lib_task_docs/","title":"lib_task_docs","text":""},{"location":"reference/fractal_tasks_core/dev/lib_task_docs/#fractal_tasks_core.dev.lib_task_docs._get_function_description","title":"<code>_get_function_description(package_name, module_relative_path, function_name)</code>","text":"<p>Extract function description from its docstring.</p> PARAMETER  DESCRIPTION <code>package_name</code> <p>Example <code>fractal_tasks_core</code>.</p> <p> TYPE: <code>str</code> </p> <code>module_relative_path</code> <p>Example <code>tasks/create_ome_zarr.py</code>.</p> <p> TYPE: <code>str</code> </p> <code>function_name</code> <p>Example <code>create_ome_zarr</code>.</p> <p> TYPE: <code>str</code> </p> Source code in <code>fractal_tasks_core/dev/lib_task_docs.py</code> <pre><code>def _get_function_description(\n    package_name: str, module_relative_path: str, function_name: str\n) -&gt; str:\n\"\"\"\n    Extract function description from its docstring.\n\n    Args:\n        package_name: Example `fractal_tasks_core`.\n        module_relative_path: Example `tasks/create_ome_zarr.py`.\n        function_name: Example `create_ome_zarr`.\n    \"\"\"\n    # Extract docstring from ast.FunctionDef\n    docstring = _get_function_docstring(\n        package_name, module_relative_path, function_name\n    )\n    # Parse docstring (via docstring_parser)\n    parsed_docstring = docparse(docstring)\n    # Combine short/long descriptions (if present)\n    short_description = parsed_docstring.short_description\n    long_description = parsed_docstring.long_description\n    items = []\n    if short_description:\n        items.append(short_description)\n    if long_description:\n        items.append(long_description)\n    if items:\n        if parsed_docstring.blank_after_short_description:\n            return \"\\n\\n\".join(items)\n        else:\n            return \"\\n\".join(items)\n    else:\n        return \"\"\n</code></pre>"},{"location":"reference/fractal_tasks_core/dev/lib_task_docs/#fractal_tasks_core.dev.lib_task_docs.create_docs_info","title":"<code>create_docs_info(executable, package='fractal_tasks_core')</code>","text":"<p>Return task description based on function docstring.</p> Source code in <code>fractal_tasks_core/dev/lib_task_docs.py</code> <pre><code>def create_docs_info(\n    executable: str,\n    package: str = \"fractal_tasks_core\",\n) -&gt; str:\n\"\"\"\n    Return task description based on function docstring.\n    \"\"\"\n    logging.info(\"[create_docs_info] START\")\n    # Extract the function name. Note: this could be made more general, but for\n    # the moment we assume the function has the same name as the module)\n    function_name = Path(executable).with_suffix(\"\").name\n    logging.info(f\"[create_docs_info] {function_name=}\")\n    # Get function description\n    docs_info = _get_function_description(\n        package_name=package,\n        module_relative_path=executable,\n        function_name=function_name,\n    )\n    logging.info(\"[create_docs_info] END\")\n    return docs_info\n</code></pre>"},{"location":"reference/fractal_tasks_core/dev/lib_task_docs/#fractal_tasks_core.dev.lib_task_docs.create_docs_link","title":"<code>create_docs_link(executable)</code>","text":"<p>Return link to docs page for a fractal_tasks_core task.</p> Source code in <code>fractal_tasks_core/dev/lib_task_docs.py</code> <pre><code>def create_docs_link(executable: str) -&gt; str:\n\"\"\"\n    Return link to docs page for a fractal_tasks_core task.\n    \"\"\"\n    logging.info(\"[create_docs_link] START\")\n\n    # Extract the function name. Note: this could be made more general, but for\n    # the moment we assume the function has the same name as the module)\n    function_name = Path(executable).with_suffix(\"\").name\n    logging.info(f\"[create_docs_link] {function_name=}\")\n    # Define docs_link\n    docs_link = (\n        \"https://fractal-analytics-platform.github.io/fractal-tasks-core/\"\n        f\"reference/fractal_tasks_core/tasks/{function_name}/\"\n        f\"#fractal_tasks_core.tasks.{function_name}.{function_name}\"\n    )\n    logging.info(\"[create_docs_link] END\")\n    return docs_link\n</code></pre>"},{"location":"reference/fractal_tasks_core/dev/lib_titles/","title":"lib_titles","text":"<p>Module to include titles in JSON Schema properties.</p>"},{"location":"reference/fractal_tasks_core/dev/lib_titles/#fractal_tasks_core.dev.lib_titles._include_titles","title":"<code>_include_titles(schema)</code>","text":"<p>Include property titles, when missing.</p> <p>This handles both:</p> <ul> <li>first-level JSON Schema properties (corresponding to task     arguments);</li> <li>properties of JSON Schema definitions (corresponding to     task-argument attributes).</li> </ul> PARAMETER  DESCRIPTION <code>schema</code> <p>TBD</p> <p> TYPE: <code>_Schema</code> </p> Source code in <code>fractal_tasks_core/dev/lib_titles.py</code> <pre><code>def _include_titles(schema: _Schema) -&gt; _Schema:\n\"\"\"\n    Include property titles, when missing.\n\n    This handles both:\n\n    - first-level JSON Schema properties (corresponding to task\n        arguments);\n    - properties of JSON Schema definitions (corresponding to\n        task-argument attributes).\n\n    Args:\n        schema: TBD\n    \"\"\"\n    new_schema = schema.copy()\n\n    # Update first-level properties (that is, task arguments)\n    new_properties = _include_titles_for_properties(schema[\"properties\"])\n    new_schema[\"properties\"] = new_properties\n\n    # Update properties of definitions\n    if \"definitions\" in schema.keys():\n        new_definitions = schema[\"definitions\"].copy()\n        for def_name, def_schema in new_definitions.items():\n            new_properties = _include_titles_for_properties(\n                def_schema[\"properties\"]\n            )\n            new_definitions[def_name][\"properties\"] = new_properties\n        new_schema[\"definitions\"] = new_definitions\n\n    logging.info(\"[_include_titles] END\")\n    return new_schema\n</code></pre>"},{"location":"reference/fractal_tasks_core/dev/lib_titles/#fractal_tasks_core.dev.lib_titles._include_titles_for_properties","title":"<code>_include_titles_for_properties(properties)</code>","text":"<p>Scan through properties of a JSON Schema, and set their title when it is missing.</p> <p>The title is set to <code>name.title()</code>, where <code>title</code> is a standard string method - see https://docs.python.org/3/library/stdtypes.html#str.title.</p> PARAMETER  DESCRIPTION <code>properties</code> <p>TBD</p> <p> TYPE: <code>dict[str, dict]</code> </p> Source code in <code>fractal_tasks_core/dev/lib_titles.py</code> <pre><code>def _include_titles_for_properties(\n    properties: dict[str, dict]\n) -&gt; dict[str, dict]:\n\"\"\"\n    Scan through properties of a JSON Schema, and set their title when it is\n    missing.\n\n    The title is set to `name.title()`, where `title` is a standard string\n    method - see https://docs.python.org/3/library/stdtypes.html#str.title.\n\n    Args:\n        properties: TBD\n    \"\"\"\n    new_properties = properties.copy()\n    for prop_name, prop in properties.items():\n        if \"title\" not in prop.keys():\n            new_prop = prop.copy()\n            new_prop[\"title\"] = prop_name.title()\n            new_properties[prop_name] = new_prop\n    return new_properties\n</code></pre>"},{"location":"reference/fractal_tasks_core/dev/update_manifest/","title":"update_manifest","text":"<p>Script to generate JSON schemas for task arguments afresh, and write them to the package manifest.</p>"},{"location":"reference/fractal_tasks_core/ngff/","title":"ngff","text":"<p>Subpackage encoding OME-NGFF specifications 0.4 and providing Zarr-related tools.</p> <p>Note: this <code>__init__.py</code> file only exports the most relevant symbols, that is, the ones that are used outside this subpackage.</p>"},{"location":"reference/fractal_tasks_core/ngff/specs/","title":"specs","text":"<p>Pydantic models related to OME-NGFF 0.4 specs, as implemented in fractal-tasks-core.</p>"},{"location":"reference/fractal_tasks_core/ngff/specs/#fractal_tasks_core.ngff.specs.Axis","title":"<code>Axis</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Model for an element of <code>Multiscale.axes</code>.</p> <p>See https://ngff.openmicroscopy.org/0.4/#axes-md.</p> Source code in <code>fractal_tasks_core/ngff/specs.py</code> <pre><code>class Axis(BaseModel):\n\"\"\"\n    Model for an element of `Multiscale.axes`.\n\n    See https://ngff.openmicroscopy.org/0.4/#axes-md.\n    \"\"\"\n\n    name: str\n    type: Optional[str] = None\n    unit: Optional[str] = None\n</code></pre>"},{"location":"reference/fractal_tasks_core/ngff/specs/#fractal_tasks_core.ngff.specs.Channel","title":"<code>Channel</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Model for an element of <code>Omero.channels</code>.</p> <p>See https://ngff.openmicroscopy.org/0.4/#omero-md.</p> Source code in <code>fractal_tasks_core/ngff/specs.py</code> <pre><code>class Channel(BaseModel):\n\"\"\"\n    Model for an element of `Omero.channels`.\n\n    See https://ngff.openmicroscopy.org/0.4/#omero-md.\n    \"\"\"\n\n    window: Optional[Window] = None\n    label: Optional[str] = None\n    family: Optional[str] = None\n    color: str\n    active: Optional[bool] = None\n</code></pre>"},{"location":"reference/fractal_tasks_core/ngff/specs/#fractal_tasks_core.ngff.specs.Dataset","title":"<code>Dataset</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Model for an element of <code>Multiscale.datasets</code>.</p> <p>See https://ngff.openmicroscopy.org/0.4/#multiscale-md</p> Source code in <code>fractal_tasks_core/ngff/specs.py</code> <pre><code>class Dataset(BaseModel):\n\"\"\"\n    Model for an element of `Multiscale.datasets`.\n\n    See https://ngff.openmicroscopy.org/0.4/#multiscale-md\n    \"\"\"\n\n    path: str\n    coordinateTransformations: list[\n        Union[\n            ScaleCoordinateTransformation, TranslationCoordinateTransformation\n        ]\n    ] = Field(..., min_items=1)\n\n    @property\n    def scale_transformation(self) -&gt; ScaleCoordinateTransformation:\n\"\"\"\n        Extract the unique scale transformation, or fail otherwise.\n        \"\"\"\n        _transformations = [\n            t for t in self.coordinateTransformations if t.type == \"scale\"\n        ]\n        if len(_transformations) == 0:\n            raise ValueError(\n                \"Missing scale transformation in dataset.\\n\"\n                \"Current coordinateTransformations:\\n\"\n                f\"{self.coordinateTransformations}\"\n            )\n        elif len(_transformations) &gt; 1:\n            raise ValueError(\n                \"More than one scale transformation in dataset.\\n\"\n                \"Current coordinateTransformations:\\n\"\n                f\"{self.coordinateTransformations}\"\n            )\n        else:\n            return _transformations[0]\n</code></pre>"},{"location":"reference/fractal_tasks_core/ngff/specs/#fractal_tasks_core.ngff.specs.Dataset.scale_transformation","title":"<code>scale_transformation: ScaleCoordinateTransformation</code>  <code>property</code>","text":"<p>Extract the unique scale transformation, or fail otherwise.</p>"},{"location":"reference/fractal_tasks_core/ngff/specs/#fractal_tasks_core.ngff.specs.ImageInWell","title":"<code>ImageInWell</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Model for an element of <code>Well.images</code>.</p> <p>Note 1: The NGFF image is defined in a different model (<code>NgffImageMeta</code>), while the <code>Image</code> model only refere to an item of <code>Well.images</code>.</p> <p>Note 2: We deviate from NGFF specs, since we allow <code>path</code> to be an arbitrary string. TODO: include a check like <code>constr(regex=r'^[A-Za-z0-9]+$')</code>, through a Pydantic validator.</p> <p>See https://ngff.openmicroscopy.org/0.4/#well-md.</p> Source code in <code>fractal_tasks_core/ngff/specs.py</code> <pre><code>class ImageInWell(BaseModel):\n\"\"\"\n    Model for an element of `Well.images`.\n\n    **Note 1:** The NGFF image is defined in a different model\n    (`NgffImageMeta`), while the `Image` model only refere to an item of\n    `Well.images`.\n\n    **Note 2:** We deviate from NGFF specs, since we allow `path` to be an\n    arbitrary string.\n    TODO: include a check like `constr(regex=r'^[A-Za-z0-9]+$')`, through a\n    Pydantic validator.\n\n    See https://ngff.openmicroscopy.org/0.4/#well-md.\n    \"\"\"\n\n    acquisition: Optional[int] = Field(\n        None, description=\"A unique identifier within the context of the plate\"\n    )\n    path: str = Field(\n        ..., description=\"The path for this field of view subgroup\"\n    )\n</code></pre>"},{"location":"reference/fractal_tasks_core/ngff/specs/#fractal_tasks_core.ngff.specs.Multiscale","title":"<code>Multiscale</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Model for an element of <code>NgffImageMeta.multiscales</code>.</p> <p>See https://ngff.openmicroscopy.org/0.4/#multiscale-md.</p> Source code in <code>fractal_tasks_core/ngff/specs.py</code> <pre><code>class Multiscale(BaseModel):\n\"\"\"\n    Model for an element of `NgffImageMeta.multiscales`.\n\n    See https://ngff.openmicroscopy.org/0.4/#multiscale-md.\n    \"\"\"\n\n    name: Optional[str] = None\n    datasets: list[Dataset] = Field(..., min_items=1)\n    version: Optional[str] = None\n    axes: list[Axis] = Field(..., max_items=5, min_items=2, unique_items=True)\n    coordinateTransformations: Optional[\n        list[\n            Union[\n                ScaleCoordinateTransformation,\n                TranslationCoordinateTransformation,\n            ]\n        ]\n    ] = None\n\n    @validator(\"coordinateTransformations\", always=True)\n    def _no_global_coordinateTransformations(cls, v):\n\"\"\"\n        Fail if Multiscale has a (global) coordinateTransformations attribute.\n        \"\"\"\n        if v is not None:\n            raise NotImplementedError(\n                \"Global coordinateTransformations at the multiscales \"\n                \"level are not currently supported in the fractal-tasks-core \"\n                \"model for the NGFF multiscale.\"\n            )\n</code></pre>"},{"location":"reference/fractal_tasks_core/ngff/specs/#fractal_tasks_core.ngff.specs.Multiscale._no_global_coordinateTransformations","title":"<code>_no_global_coordinateTransformations(v)</code>","text":"<p>Fail if Multiscale has a (global) coordinateTransformations attribute.</p> Source code in <code>fractal_tasks_core/ngff/specs.py</code> <pre><code>@validator(\"coordinateTransformations\", always=True)\ndef _no_global_coordinateTransformations(cls, v):\n\"\"\"\n    Fail if Multiscale has a (global) coordinateTransformations attribute.\n    \"\"\"\n    if v is not None:\n        raise NotImplementedError(\n            \"Global coordinateTransformations at the multiscales \"\n            \"level are not currently supported in the fractal-tasks-core \"\n            \"model for the NGFF multiscale.\"\n        )\n</code></pre>"},{"location":"reference/fractal_tasks_core/ngff/specs/#fractal_tasks_core.ngff.specs.NgffImageMeta","title":"<code>NgffImageMeta</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Model for the metadata of a NGFF image.</p> <p>See https://ngff.openmicroscopy.org/0.4/#image-layout.</p> Source code in <code>fractal_tasks_core/ngff/specs.py</code> <pre><code>class NgffImageMeta(BaseModel):\n\"\"\"\n    Model for the metadata of a NGFF image.\n\n    See https://ngff.openmicroscopy.org/0.4/#image-layout.\n    \"\"\"\n\n    multiscales: list[Multiscale] = Field(\n        ...,\n        description=\"The multiscale datasets for this image\",\n        min_items=1,\n        unique_items=True,\n    )\n    omero: Optional[Omero] = None\n\n    @property\n    def multiscale(self) -&gt; Multiscale:\n\"\"\"\n        The single element of `self.multiscales`.\n\n        Raises:\n            NotImplementedError:\n                If there are no multiscales or more than one.\n        \"\"\"\n        if len(self.multiscales) &gt; 1:\n            raise NotImplementedError(\n                \"Only images with one multiscale are supported \"\n                f\"(given: {len(self.multiscales)}\"\n            )\n        return self.multiscales[0]\n\n    @property\n    def datasets(self) -&gt; list[Dataset]:\n\"\"\"\n        The `datasets` attribute of `self.multiscale`.\n        \"\"\"\n        return self.multiscale.datasets\n\n    @property\n    def num_levels(self) -&gt; int:\n        return len(self.datasets)\n\n    @property\n    def axes_names(self) -&gt; list[str]:\n\"\"\"\n        List of axes names.\n        \"\"\"\n        return [ax.name for ax in self.multiscale.axes]\n\n    @property\n    def pixel_sizes_zyx(self) -&gt; list[list[float]]:\n\"\"\"\n        Pixel sizes extracted from scale transformations of datasets.\n\n        Raises:\n            ValueError:\n                If pixel sizes are below a given threshold (1e-9).\n        \"\"\"\n        x_index = self.axes_names.index(\"x\")\n        y_index = self.axes_names.index(\"y\")\n        try:\n            z_index = self.axes_names.index(\"z\")\n        except ValueError:\n            z_index = None\n            logging.warning(\n                f\"Z axis is not present (axes: {self.axes_names}), and Z pixel\"\n                \" size is set to 1. This may work, by accident, but it is \"\n                \"not fully supported.\"\n            )\n        _pixel_sizes_zyx = []\n        for level in range(self.num_levels):\n            scale = self.datasets[level].scale_transformation.scale\n            pixel_size_x = scale[x_index]\n            pixel_size_y = scale[y_index]\n            if z_index is not None:\n                pixel_size_z = scale[z_index]\n            else:\n                pixel_size_z = 1.0\n            _pixel_sizes_zyx.append([pixel_size_z, pixel_size_y, pixel_size_x])\n            if min(_pixel_sizes_zyx[-1]) &lt; 1e-9:\n                raise ValueError(\n                    f\"Pixel sizes at level {level} are too small: \"\n                    f\"{_pixel_sizes_zyx[-1]}\"\n                )\n\n        return _pixel_sizes_zyx\n\n    def get_pixel_sizes_zyx(self, *, level: int = 0) -&gt; list[float]:\n        return self.pixel_sizes_zyx[level]\n\n    @property\n    def coarsening_xy(self) -&gt; int:\n\"\"\"\n        Linear coarsening factor in the YX plane.\n\n        We only support coarsening factors that are homogeneous (both in the\n        X/Y directions and across pyramid levels).\n\n        Raises:\n            NotImplementedError:\n                If coarsening ratios are not homogeneous.\n        \"\"\"\n        current_ratio = None\n        for ind in range(1, self.num_levels):\n            ratio_x = round(\n                self.pixel_sizes_zyx[ind][2] / self.pixel_sizes_zyx[ind - 1][2]\n            )\n            ratio_y = round(\n                self.pixel_sizes_zyx[ind][1] / self.pixel_sizes_zyx[ind - 1][1]\n            )\n            if ratio_x != ratio_y:\n                raise NotImplementedError(\n                    \"Inhomogeneous coarsening in X/Y directions \"\n                    \"is not supported.\\n\"\n                    f\"ZYX pixel sizes:\\n {self.pixel_sizes_zyx}\"\n                )\n            if current_ratio is None:\n                current_ratio = ratio_x\n            else:\n                if current_ratio != ratio_x:\n                    raise NotImplementedError(\n                        \"Inhomogeneous coarsening across levels \"\n                        \"is not supported.\\n\"\n                        f\"ZYX pixel sizes:\\n {self.pixel_sizes_zyx}\"\n                    )\n\n        return current_ratio\n</code></pre>"},{"location":"reference/fractal_tasks_core/ngff/specs/#fractal_tasks_core.ngff.specs.NgffImageMeta.axes_names","title":"<code>axes_names: list[str]</code>  <code>property</code>","text":"<p>List of axes names.</p>"},{"location":"reference/fractal_tasks_core/ngff/specs/#fractal_tasks_core.ngff.specs.NgffImageMeta.coarsening_xy","title":"<code>coarsening_xy: int</code>  <code>property</code>","text":"<p>Linear coarsening factor in the YX plane.</p> <p>We only support coarsening factors that are homogeneous (both in the X/Y directions and across pyramid levels).</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If coarsening ratios are not homogeneous.</p>"},{"location":"reference/fractal_tasks_core/ngff/specs/#fractal_tasks_core.ngff.specs.NgffImageMeta.datasets","title":"<code>datasets: list[Dataset]</code>  <code>property</code>","text":"<p>The <code>datasets</code> attribute of <code>self.multiscale</code>.</p>"},{"location":"reference/fractal_tasks_core/ngff/specs/#fractal_tasks_core.ngff.specs.NgffImageMeta.multiscale","title":"<code>multiscale: Multiscale</code>  <code>property</code>","text":"<p>The single element of <code>self.multiscales</code>.</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If there are no multiscales or more than one.</p>"},{"location":"reference/fractal_tasks_core/ngff/specs/#fractal_tasks_core.ngff.specs.NgffImageMeta.pixel_sizes_zyx","title":"<code>pixel_sizes_zyx: list[list[float]]</code>  <code>property</code>","text":"<p>Pixel sizes extracted from scale transformations of datasets.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If pixel sizes are below a given threshold (1e-9).</p>"},{"location":"reference/fractal_tasks_core/ngff/specs/#fractal_tasks_core.ngff.specs.NgffWellMeta","title":"<code>NgffWellMeta</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Model for the metadata of a NGFF well.</p> <p>See https://ngff.openmicroscopy.org/0.4/#well-md.</p> Source code in <code>fractal_tasks_core/ngff/specs.py</code> <pre><code>class NgffWellMeta(BaseModel):\n\"\"\"\n    Model for the metadata of a NGFF well.\n\n    See https://ngff.openmicroscopy.org/0.4/#well-md.\n    \"\"\"\n\n    well: Optional[Well] = None\n\n    def get_acquisition_paths(self) -&gt; dict[int, str]:\n\"\"\"\n        Create mapping from acquisition indices to corresponding paths.\n\n        Runs on the well zarr attributes and loads the relative paths in the\n        well.\n\n        Returns:\n            Dictionary with `(acquisition index: image path)` key/value pairs.\n\n        Raises:\n            ValueError:\n                If an element of `self.well.images` has no `acquisition`\n                    attribute.\n            NotImplementedError:\n                If acquisitions are not unique.\n        \"\"\"\n        acquisition_dict = {}\n        for image in self.well.images:\n            if image.acquisition is None:\n                raise ValueError(\n                    \"Cannot get acquisition paths for Zarr files without \"\n                    \"'acquisition' metadata at the well level\"\n                )\n            if image.acquisition in acquisition_dict:\n                raise NotImplementedError(\n                    \"The `NgffWellMeta.get_acquisition_paths` method (in \"\n                    \"fractal-tasks-core) does not support wells with \"\n                    \"multiple images of the same acquisition.\"\n                )\n            acquisition_dict[image.acquisition] = image.path\n        return acquisition_dict\n</code></pre>"},{"location":"reference/fractal_tasks_core/ngff/specs/#fractal_tasks_core.ngff.specs.NgffWellMeta.get_acquisition_paths","title":"<code>get_acquisition_paths()</code>","text":"<p>Create mapping from acquisition indices to corresponding paths.</p> <p>Runs on the well zarr attributes and loads the relative paths in the well.</p> RETURNS DESCRIPTION <code>dict[int, str]</code> <p>Dictionary with <code>(acquisition index: image path)</code> key/value pairs.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If an element of <code>self.well.images</code> has no <code>acquisition</code>     attribute.</p> <code>NotImplementedError</code> <p>If acquisitions are not unique.</p> Source code in <code>fractal_tasks_core/ngff/specs.py</code> <pre><code>def get_acquisition_paths(self) -&gt; dict[int, str]:\n\"\"\"\n    Create mapping from acquisition indices to corresponding paths.\n\n    Runs on the well zarr attributes and loads the relative paths in the\n    well.\n\n    Returns:\n        Dictionary with `(acquisition index: image path)` key/value pairs.\n\n    Raises:\n        ValueError:\n            If an element of `self.well.images` has no `acquisition`\n                attribute.\n        NotImplementedError:\n            If acquisitions are not unique.\n    \"\"\"\n    acquisition_dict = {}\n    for image in self.well.images:\n        if image.acquisition is None:\n            raise ValueError(\n                \"Cannot get acquisition paths for Zarr files without \"\n                \"'acquisition' metadata at the well level\"\n            )\n        if image.acquisition in acquisition_dict:\n            raise NotImplementedError(\n                \"The `NgffWellMeta.get_acquisition_paths` method (in \"\n                \"fractal-tasks-core) does not support wells with \"\n                \"multiple images of the same acquisition.\"\n            )\n        acquisition_dict[image.acquisition] = image.path\n    return acquisition_dict\n</code></pre>"},{"location":"reference/fractal_tasks_core/ngff/specs/#fractal_tasks_core.ngff.specs.Omero","title":"<code>Omero</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Model for <code>NgffImageMeta.omero</code>.</p> <p>See https://ngff.openmicroscopy.org/0.4/#omero-md.</p> Source code in <code>fractal_tasks_core/ngff/specs.py</code> <pre><code>class Omero(BaseModel):\n\"\"\"\n    Model for `NgffImageMeta.omero`.\n\n    See https://ngff.openmicroscopy.org/0.4/#omero-md.\n    \"\"\"\n\n    channels: list[Channel]\n</code></pre>"},{"location":"reference/fractal_tasks_core/ngff/specs/#fractal_tasks_core.ngff.specs.ScaleCoordinateTransformation","title":"<code>ScaleCoordinateTransformation</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Model for a scale transformation.</p> <p>This corresponds to scale-type elements of <code>Dataset.coordinateTransformations</code> or <code>Multiscale.coordinateTransformations</code>. See https://ngff.openmicroscopy.org/0.4/#trafo-md</p> Source code in <code>fractal_tasks_core/ngff/specs.py</code> <pre><code>class ScaleCoordinateTransformation(BaseModel):\n\"\"\"\n    Model for a scale transformation.\n\n    This corresponds to scale-type elements of\n    `Dataset.coordinateTransformations` or\n    `Multiscale.coordinateTransformations`.\n    See https://ngff.openmicroscopy.org/0.4/#trafo-md\n    \"\"\"\n\n    type: Literal[\"scale\"]\n    scale: list[float] = Field(..., min_items=2)\n</code></pre>"},{"location":"reference/fractal_tasks_core/ngff/specs/#fractal_tasks_core.ngff.specs.TranslationCoordinateTransformation","title":"<code>TranslationCoordinateTransformation</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Model for a translation transformation.</p> <p>This corresponds to translation-type elements of <code>Dataset.coordinateTransformations</code> or <code>Multiscale.coordinateTransformations</code>. See https://ngff.openmicroscopy.org/0.4/#trafo-md</p> Source code in <code>fractal_tasks_core/ngff/specs.py</code> <pre><code>class TranslationCoordinateTransformation(BaseModel):\n\"\"\"\n    Model for a translation transformation.\n\n    This corresponds to translation-type elements of\n    `Dataset.coordinateTransformations` or\n    `Multiscale.coordinateTransformations`.\n    See https://ngff.openmicroscopy.org/0.4/#trafo-md\n    \"\"\"\n\n    type: Literal[\"translation\"]\n    translation: list[float] = Field(..., min_items=2)\n</code></pre>"},{"location":"reference/fractal_tasks_core/ngff/specs/#fractal_tasks_core.ngff.specs.Well","title":"<code>Well</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Model for <code>NgffWellMeta.well</code>.</p> <p>See https://ngff.openmicroscopy.org/0.4/#well-md.</p> Source code in <code>fractal_tasks_core/ngff/specs.py</code> <pre><code>class Well(BaseModel):\n\"\"\"\n    Model for `NgffWellMeta.well`.\n\n    See https://ngff.openmicroscopy.org/0.4/#well-md.\n    \"\"\"\n\n    images: list[ImageInWell] = Field(\n        ...,\n        description=\"The images included in this well\",\n        min_items=1,\n        unique_items=True,\n    )\n    version: Optional[str] = Field(\n        None, description=\"The version of the specification\"\n    )\n</code></pre>"},{"location":"reference/fractal_tasks_core/ngff/specs/#fractal_tasks_core.ngff.specs.Window","title":"<code>Window</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Model for <code>Channel.window</code>.</p> <p>Note that we deviate by NGFF specs by making <code>start</code> and <code>end</code> optional. See https://ngff.openmicroscopy.org/0.4/#omero-md.</p> Source code in <code>fractal_tasks_core/ngff/specs.py</code> <pre><code>class Window(BaseModel):\n\"\"\"\n    Model for `Channel.window`.\n\n    Note that we deviate by NGFF specs by making `start` and `end` optional.\n    See https://ngff.openmicroscopy.org/0.4/#omero-md.\n    \"\"\"\n\n    max: float\n    min: float\n    start: Optional[float] = None\n    end: Optional[float] = None\n</code></pre>"},{"location":"reference/fractal_tasks_core/ngff/zarr_utils/","title":"zarr_utils","text":"<p>Utilities to work with the Pydantic models from <code>specs.py</code> for Zarr groups.</p>"},{"location":"reference/fractal_tasks_core/ngff/zarr_utils/#fractal_tasks_core.ngff.zarr_utils.ZarrGroupNotFoundError","title":"<code>ZarrGroupNotFoundError</code>","text":"<p>             Bases: <code>ValueError</code></p> <p>Wrap zarr.errors.GroupNotFoundError</p> <p>This is used to provide a user-friendly error message.</p> Source code in <code>fractal_tasks_core/ngff/zarr_utils.py</code> <pre><code>class ZarrGroupNotFoundError(ValueError):\n\"\"\"\n    Wrap zarr.errors.GroupNotFoundError\n\n    This is used to provide a user-friendly error message.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/fractal_tasks_core/ngff/zarr_utils/#fractal_tasks_core.ngff.zarr_utils.detect_ome_ngff_type","title":"<code>detect_ome_ngff_type(group)</code>","text":"<p>Given a Zarr group, find whether it is an OME-NGFF plate, well or image.</p> PARAMETER  DESCRIPTION <code>group</code> <p>Zarr group</p> <p> TYPE: <code>Group</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The detected OME-NGFF type (<code>plate</code>, <code>well</code> or <code>image</code>).</p> Source code in <code>fractal_tasks_core/ngff/zarr_utils.py</code> <pre><code>def detect_ome_ngff_type(group: zarr.hierarchy.Group) -&gt; str:\n\"\"\"\n    Given a Zarr group, find whether it is an OME-NGFF plate, well or image.\n\n    Args:\n        group: Zarr group\n\n    Returns:\n        The detected OME-NGFF type (`plate`, `well` or `image`).\n    \"\"\"\n    attrs = group.attrs.asdict()\n    if \"plate\" in attrs.keys():\n        ngff_type = \"plate\"\n    elif \"well\" in attrs.keys():\n        ngff_type = \"well\"\n    elif \"multiscales\" in attrs.keys():\n        ngff_type = \"image\"\n    else:\n        error_msg = (\n            \"Zarr group at cannot be identified as one \"\n            \"of OME-NGFF plate/well/image groups.\"\n        )\n        logger.error(error_msg)\n        raise ValueError(error_msg)\n    logger.info(f\"Zarr group identified as OME-NGFF {ngff_type}.\")\n    return ngff_type\n</code></pre>"},{"location":"reference/fractal_tasks_core/ngff/zarr_utils/#fractal_tasks_core.ngff.zarr_utils.load_NgffImageMeta","title":"<code>load_NgffImageMeta(zarr_path)</code>","text":"<p>Load the attributes of a zarr group and cast them to <code>NgffImageMeta</code>.</p> PARAMETER  DESCRIPTION <code>zarr_path</code> <p>Path to the zarr group.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>NgffImageMeta</code> <p>A new <code>NgffImageMeta</code> object.</p> Source code in <code>fractal_tasks_core/ngff/zarr_utils.py</code> <pre><code>def load_NgffImageMeta(zarr_path: str) -&gt; NgffImageMeta:\n\"\"\"\n    Load the attributes of a zarr group and cast them to `NgffImageMeta`.\n\n    Args:\n        zarr_path: Path to the zarr group.\n\n    Returns:\n        A new `NgffImageMeta` object.\n    \"\"\"\n    try:\n        zarr_group = zarr.open_group(zarr_path, mode=\"r\")\n    except GroupNotFoundError:\n        error_msg = (\n            \"Could not load attributes for the requested image, \"\n            f\"because no Zarr image was found at {zarr_path}\"\n        )\n        logging.error(error_msg)\n        raise ZarrGroupNotFoundError(error_msg)\n    zarr_attrs = zarr_group.attrs.asdict()\n    try:\n        return NgffImageMeta(**zarr_attrs)\n    except Exception as e:\n        logging.error(\n            f\"Contents of {zarr_path} cannot be cast to NgffImageMeta.\\n\"\n            f\"Original error:\\n{str(e)}\"\n        )\n        raise e\n</code></pre>"},{"location":"reference/fractal_tasks_core/ngff/zarr_utils/#fractal_tasks_core.ngff.zarr_utils.load_NgffWellMeta","title":"<code>load_NgffWellMeta(zarr_path)</code>","text":"<p>Load the attributes of a zarr group and cast them to <code>NgffWellMeta</code>.</p> PARAMETER  DESCRIPTION <code>zarr_path</code> <p>Path to the zarr group.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>NgffWellMeta</code> <p>A new <code>NgffWellMeta</code> object.</p> Source code in <code>fractal_tasks_core/ngff/zarr_utils.py</code> <pre><code>def load_NgffWellMeta(zarr_path: str) -&gt; NgffWellMeta:\n\"\"\"\n    Load the attributes of a zarr group and cast them to `NgffWellMeta`.\n\n    Args:\n        zarr_path: Path to the zarr group.\n\n    Returns:\n        A new `NgffWellMeta` object.\n    \"\"\"\n    try:\n        zarr_group = zarr.open_group(zarr_path, mode=\"r\")\n    except GroupNotFoundError:\n        error_msg = (\n            \"Could not load attributes for the requested well, \"\n            f\"because no Zarr image was found at {zarr_path}\"\n        )\n        logging.error(error_msg)\n        raise ZarrGroupNotFoundError(error_msg)\n    zarr_attrs = zarr_group.attrs.asdict()\n    try:\n        return NgffWellMeta(**zarr_attrs)\n    except Exception as e:\n        logging.error(\n            f\"Contents of {zarr_path} cannot be cast to NgffWellMeta.\\n\"\n            f\"Original error:\\n{str(e)}\"\n        )\n        raise e\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/","title":"roi","text":"<p>Subpackage for ROI-related functions.</p>"},{"location":"reference/fractal_tasks_core/roi/_overlaps_common/","title":"_overlaps_common","text":"<p>Functions to identify overlaps between regions, not related to table specs.</p>"},{"location":"reference/fractal_tasks_core/roi/_overlaps_common/#fractal_tasks_core.roi._overlaps_common._is_overlapping_1D_int","title":"<code>_is_overlapping_1D_int(line1, line2)</code>","text":"<p>Given two integer intervals, find whether they overlap</p> <p>This is the same as <code>is_overlapping_1D</code> (based on https://stackoverflow.com/a/70023212/19085332), for integer-valued intervals.</p> PARAMETER  DESCRIPTION <code>line1</code> <p>The boundaries of the first interval , written as <code>[x_min, x_max]</code>.</p> <p> TYPE: <code>Sequence[int]</code> </p> <code>line2</code> <p>The boundaries of the second interval , written as <code>[x_min, x_max]</code>.</p> <p> TYPE: <code>Sequence[int]</code> </p> Source code in <code>fractal_tasks_core/roi/_overlaps_common.py</code> <pre><code>def _is_overlapping_1D_int(\n    line1: Sequence[int],\n    line2: Sequence[int],\n) -&gt; bool:\n\"\"\"\n    Given two integer intervals, find whether they overlap\n\n    This is the same as `is_overlapping_1D` (based on\n    https://stackoverflow.com/a/70023212/19085332), for integer-valued\n    intervals.\n\n    Args:\n        line1: The boundaries of the first interval , written as\n            `[x_min, x_max]`.\n        line2: The boundaries of the second interval , written as\n            `[x_min, x_max]`.\n    \"\"\"\n    return line1[0] &lt; line2[1] and line2[0] &lt; line1[1]\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/_overlaps_common/#fractal_tasks_core.roi._overlaps_common._is_overlapping_3D_int","title":"<code>_is_overlapping_3D_int(box1, box2)</code>","text":"<p>Given two three-dimensional integer boxes, find whether they overlap.</p> <p>This is the same as is_overlapping_3D (based on https://stackoverflow.com/a/70023212/19085332), for integer-valued boxes.</p> PARAMETER  DESCRIPTION <code>box1</code> <p>The boundaries of the first box, written as <code>[x_min, y_min, z_min, x_max, y_max, z_max]</code>.</p> <p> TYPE: <code>list[int]</code> </p> <code>box2</code> <p>The boundaries of the second box, written as <code>[x_min, y_min, z_min, x_max, y_max, z_max]</code>.</p> <p> TYPE: <code>list[int]</code> </p> Source code in <code>fractal_tasks_core/roi/_overlaps_common.py</code> <pre><code>def _is_overlapping_3D_int(box1: list[int], box2: list[int]) -&gt; bool:\n\"\"\"\n    Given two three-dimensional integer boxes, find whether they overlap.\n\n    This is the same as is_overlapping_3D (based on\n    https://stackoverflow.com/a/70023212/19085332), for integer-valued\n    boxes.\n\n    Args:\n        box1: The boundaries of the first box, written as\n            `[x_min, y_min, z_min, x_max, y_max, z_max]`.\n        box2: The boundaries of the second box, written as\n            `[x_min, y_min, z_min, x_max, y_max, z_max]`.\n    \"\"\"\n    overlap_x = _is_overlapping_1D_int([box1[0], box1[3]], [box2[0], box2[3]])\n    overlap_y = _is_overlapping_1D_int([box1[1], box1[4]], [box2[1], box2[4]])\n    overlap_z = _is_overlapping_1D_int([box1[2], box1[5]], [box2[2], box2[5]])\n    return overlap_x and overlap_y and overlap_z\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/_overlaps_common/#fractal_tasks_core.roi._overlaps_common.is_overlapping_1D","title":"<code>is_overlapping_1D(line1, line2, tol=1e-10)</code>","text":"<p>Given two intervals, finds whether they overlap.</p> <p>This is based on https://stackoverflow.com/a/70023212/19085332, and we additionally use a finite tolerance for floating-point comparisons.</p> PARAMETER  DESCRIPTION <code>line1</code> <p>The boundaries of the first interval, written as <code>[x_min, x_max]</code>.</p> <p> TYPE: <code>Sequence[float]</code> </p> <code>line2</code> <p>The boundaries of the second interval, written as <code>[x_min, x_max]</code>.</p> <p> TYPE: <code>Sequence[float]</code> </p> <code>tol</code> <p>Finite tolerance for floating-point comparisons.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-10</code> </p> Source code in <code>fractal_tasks_core/roi/_overlaps_common.py</code> <pre><code>def is_overlapping_1D(\n    line1: Sequence[float], line2: Sequence[float], tol: float = 1e-10\n) -&gt; bool:\n\"\"\"\n    Given two intervals, finds whether they overlap.\n\n    This is based on https://stackoverflow.com/a/70023212/19085332, and we\n    additionally use a finite tolerance for floating-point comparisons.\n\n    Args:\n        line1: The boundaries of the first interval, written as\n            `[x_min, x_max]`.\n        line2: The boundaries of the second interval, written as\n            `[x_min, x_max]`.\n        tol: Finite tolerance for floating-point comparisons.\n    \"\"\"\n    return line1[0] &lt;= line2[1] - tol and line2[0] &lt;= line1[1] - tol\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/_overlaps_common/#fractal_tasks_core.roi._overlaps_common.is_overlapping_2D","title":"<code>is_overlapping_2D(box1, box2, tol=1e-10)</code>","text":"<p>Given two rectangular boxes, finds whether they overlap.</p> <p>This is based on https://stackoverflow.com/a/70023212/19085332, and we additionally use a finite tolerance for floating-point comparisons.</p> PARAMETER  DESCRIPTION <code>box1</code> <p>The boundaries of the first rectangle, written as <code>[x_min, y_min, x_max, y_max]</code>.</p> <p> TYPE: <code>Sequence[float]</code> </p> <code>box2</code> <p>The boundaries of the second rectangle, written as <code>[x_min, y_min, x_max, y_max]</code>.</p> <p> TYPE: <code>Sequence[float]</code> </p> <code>tol</code> <p>Finite tolerance for floating-point comparisons.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-10</code> </p> Source code in <code>fractal_tasks_core/roi/_overlaps_common.py</code> <pre><code>def is_overlapping_2D(\n    box1: Sequence[float], box2: Sequence[float], tol: float = 1e-10\n) -&gt; bool:\n\"\"\"\n    Given two rectangular boxes, finds whether they overlap.\n\n    This is based on https://stackoverflow.com/a/70023212/19085332, and we\n    additionally use a finite tolerance for floating-point comparisons.\n\n    Args:\n        box1: The boundaries of the first rectangle, written as\n            `[x_min, y_min, x_max, y_max]`.\n        box2: The boundaries of the second rectangle, written as\n            `[x_min, y_min, x_max, y_max]`.\n        tol: Finite tolerance for floating-point comparisons.\n    \"\"\"\n    overlap_x = is_overlapping_1D(\n        [box1[0], box1[2]], [box2[0], box2[2]], tol=tol\n    )\n    overlap_y = is_overlapping_1D(\n        [box1[1], box1[3]], [box2[1], box2[3]], tol=tol\n    )\n    return overlap_x and overlap_y\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/_overlaps_common/#fractal_tasks_core.roi._overlaps_common.is_overlapping_3D","title":"<code>is_overlapping_3D(box1, box2, tol=1e-10)</code>","text":"<p>Given two three-dimensional boxes, finds whether they overlap.</p> <p>This is based on https://stackoverflow.com/a/70023212/19085332, and we additionally use a finite tolerance for floating-point comparisons.</p> PARAMETER  DESCRIPTION <code>box1</code> <p>The boundaries of the first box, written as <code>[x_min, y_min, z_min, x_max, y_max, z_max]</code>.</p> <p> TYPE: <code>Sequence[float]</code> </p> <code>box2</code> <p>The boundaries of the second box, written as <code>[x_min, y_min, z_min, x_max, y_max, z_max]</code>.</p> <p> TYPE: <code>Sequence[float]</code> </p> <code>tol</code> <p>Finite tolerance for floating-point comparisons.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-10</code> </p> Source code in <code>fractal_tasks_core/roi/_overlaps_common.py</code> <pre><code>def is_overlapping_3D(\n    box1: Sequence[float], box2: Sequence[float], tol: float = 1e-10\n) -&gt; bool:\n\"\"\"\n    Given two three-dimensional boxes, finds whether they overlap.\n\n    This is based on https://stackoverflow.com/a/70023212/19085332, and we\n    additionally use a finite tolerance for floating-point comparisons.\n\n    Args:\n        box1: The boundaries of the first box, written as\n            `[x_min, y_min, z_min, x_max, y_max, z_max]`.\n        box2: The boundaries of the second box, written as\n            `[x_min, y_min, z_min, x_max, y_max, z_max]`.\n        tol: Finite tolerance for floating-point comparisons.\n    \"\"\"\n\n    overlap_x = is_overlapping_1D(\n        [box1[0], box1[3]], [box2[0], box2[3]], tol=tol\n    )\n    overlap_y = is_overlapping_1D(\n        [box1[1], box1[4]], [box2[1], box2[4]], tol=tol\n    )\n    overlap_z = is_overlapping_1D(\n        [box1[2], box1[5]], [box2[2], box2[5]], tol=tol\n    )\n    return overlap_x and overlap_y and overlap_z\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/load_region/","title":"load_region","text":""},{"location":"reference/fractal_tasks_core/roi/load_region/#fractal_tasks_core.roi.load_region.load_region","title":"<code>load_region(data_zyx, region, compute=True, return_as_3D=False)</code>","text":"<p>Load a region from a dask array.</p> <p>Can handle both 2D and 3D dask arrays as input and return them as is or always as a 3D array.</p> PARAMETER  DESCRIPTION <code>data_zyx</code> <p>Dask array (2D or 3D).</p> <p> TYPE: <code>Array</code> </p> <code>region</code> <p>Region to load, tuple of three slices (ZYX).</p> <p> TYPE: <code>tuple[slice, slice, slice]</code> </p> <code>compute</code> <p>Whether to compute the result. If <code>True</code>, returns a numpy array. If <code>False</code>, returns a dask array.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>return_as_3D</code> <p>Whether to return a 3D array, even if the input is 2D.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Union[Array, ndarray]</code> <p>3D array.</p> Source code in <code>fractal_tasks_core/roi/load_region.py</code> <pre><code>def load_region(\n    data_zyx: da.Array,\n    region: tuple[slice, slice, slice],\n    compute: bool = True,\n    return_as_3D: bool = False,\n) -&gt; Union[da.Array, np.ndarray]:\n\"\"\"\n    Load a region from a dask array.\n\n    Can handle both 2D and 3D dask arrays as input and return them as is or\n    always as a 3D array.\n\n    Args:\n        data_zyx: Dask array (2D or 3D).\n        region: Region to load, tuple of three slices (ZYX).\n        compute: Whether to compute the result. If `True`, returns a numpy\n            array. If `False`, returns a dask array.\n        return_as_3D: Whether to return a 3D array, even if the input is 2D.\n\n    Returns:\n        3D array.\n    \"\"\"\n\n    if len(region) != 3:\n        raise ValueError(\n            f\"In `load_region`, `region` must have three elements \"\n            f\"(given: {len(region)}).\"\n        )\n\n    if len(data_zyx.shape) == 3:\n        img = data_zyx[region]\n    elif len(data_zyx.shape) == 2:\n        img = data_zyx[(region[1], region[2])]\n        if return_as_3D:\n            img = np.expand_dims(img, axis=0)\n    else:\n        raise ValueError(\n            f\"Shape {data_zyx.shape} not supported for `load_region`\"\n        )\n    if compute:\n        return img.compute()\n    else:\n        return img\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/v1/","title":"v1","text":"<p>Functions to produce/process ROI tables.</p>"},{"location":"reference/fractal_tasks_core/roi/v1/#fractal_tasks_core.roi.v1.array_to_bounding_box_table","title":"<code>array_to_bounding_box_table(mask_array, pxl_sizes_zyx, origin_zyx=(0, 0, 0))</code>","text":"<p>Construct bounding-box ROI table for a mask array.</p> PARAMETER  DESCRIPTION <code>mask_array</code> <p>Original array to construct bounding boxes.</p> <p> TYPE: <code>ndarray</code> </p> <code>pxl_sizes_zyx</code> <p>Physical-unit pixel ZYX sizes.</p> <p> TYPE: <code>list[float]</code> </p> <code>origin_zyx</code> <p>Shift ROI origin by this amount of ZYX pixels.</p> <p> TYPE: <code>tuple[int, int, int]</code> DEFAULT: <code>(0, 0, 0)</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>DataFrame with each line representing the bounding-box ROI that corresponds to a unique value of <code>mask_array</code>. ROI properties are expressed in physical units (with columns defined as elsewhere this module - see e.g. <code>prepare_well_ROI_table</code>), and positions are optionally shifted (if <code>origin_zyx</code> is set). An additional column <code>label</code> keeps track of the <code>mask_array</code> value corresponding to each ROI.</p> Source code in <code>fractal_tasks_core/roi/v1.py</code> <pre><code>def array_to_bounding_box_table(\n    mask_array: np.ndarray,\n    pxl_sizes_zyx: list[float],\n    origin_zyx: tuple[int, int, int] = (0, 0, 0),\n) -&gt; pd.DataFrame:\n\"\"\"\n    Construct bounding-box ROI table for a mask array.\n\n    Args:\n        mask_array: Original array to construct bounding boxes.\n        pxl_sizes_zyx: Physical-unit pixel ZYX sizes.\n        origin_zyx: Shift ROI origin by this amount of ZYX pixels.\n\n    Returns:\n        DataFrame with each line representing the bounding-box ROI that\n            corresponds to a unique value of `mask_array`. ROI properties are\n            expressed in physical units (with columns defined as elsewhere this\n            module - see e.g. `prepare_well_ROI_table`), and positions are\n            optionally shifted (if `origin_zyx` is set). An additional column\n            `label` keeps track of the `mask_array` value corresponding to each\n            ROI.\n    \"\"\"\n\n    pxl_sizes_zyx_array = np.array(pxl_sizes_zyx)\n    z_origin, y_origin, x_origin = origin_zyx[:]\n\n    labels = np.unique(mask_array)\n    labels = labels[labels &gt; 0]\n    elem_list = []\n    for label in labels:\n        # Compute bounding box\n        label_match = np.where(mask_array == label)\n        zmin, ymin, xmin = np.min(label_match, axis=1) * pxl_sizes_zyx_array\n        zmax, ymax, xmax = (\n            np.max(label_match, axis=1) + 1\n        ) * pxl_sizes_zyx_array\n\n        # Compute bounding-box edges\n        length_x = xmax - xmin\n        length_y = ymax - ymin\n        length_z = zmax - zmin\n\n        # Shift origin\n        zmin += z_origin * pxl_sizes_zyx[0]\n        ymin += y_origin * pxl_sizes_zyx[1]\n        xmin += x_origin * pxl_sizes_zyx[2]\n\n        elem_list.append((xmin, ymin, zmin, length_x, length_y, length_z))\n\n    df_columns = [\n        \"x_micrometer\",\n        \"y_micrometer\",\n        \"z_micrometer\",\n        \"len_x_micrometer\",\n        \"len_y_micrometer\",\n        \"len_z_micrometer\",\n    ]\n\n    if len(elem_list) == 0:\n        df = pd.DataFrame(columns=[x for x in df_columns] + [\"label\"])\n    else:\n        df = pd.DataFrame(np.array(elem_list), columns=df_columns)\n        df[\"label\"] = labels\n\n    return df\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/v1/#fractal_tasks_core.roi.v1.convert_ROI_table_to_indices","title":"<code>convert_ROI_table_to_indices(ROI, full_res_pxl_sizes_zyx, level=0, coarsening_xy=2, cols_xyz_pos=['x_micrometer', 'y_micrometer', 'z_micrometer'], cols_xyz_len=['len_x_micrometer', 'len_y_micrometer', 'len_z_micrometer'])</code>","text":"<p>Convert a ROI AnnData table into integer array indices.</p> PARAMETER  DESCRIPTION <code>ROI</code> <p>AnnData table with list of ROIs.</p> <p> TYPE: <code>AnnData</code> </p> <code>full_res_pxl_sizes_zyx</code> <p>Physical-unit pixel ZYX sizes at the full-resolution pyramid level.</p> <p> TYPE: <code>Sequence[float]</code> </p> <code>level</code> <p>Pyramid level.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>coarsening_xy</code> <p>Linear coarsening factor in the YX plane.</p> <p> TYPE: <code>int</code> DEFAULT: <code>2</code> </p> <code>cols_xyz_pos</code> <p>Column names for XYZ ROI positions.</p> <p> TYPE: <code>Sequence[str]</code> DEFAULT: <code>['x_micrometer', 'y_micrometer', 'z_micrometer']</code> </p> <code>cols_xyz_len</code> <p>Column names for XYZ ROI edges.</p> <p> TYPE: <code>Sequence[str]</code> DEFAULT: <code>['len_x_micrometer', 'len_y_micrometer', 'len_z_micrometer']</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If any of the array indices is negative.</p> RETURNS DESCRIPTION <code>list[list[int]]</code> <p>Nested list of indices. The main list has one item per ROI. Each ROI item is a list of six integers as in <code>[start_z, end_z, start_y, end_y, start_x, end_x]</code>. The array-index interval for a given ROI is <code>start_x:end_x</code> along X, and so on for Y and Z.</p> Source code in <code>fractal_tasks_core/roi/v1.py</code> <pre><code>def convert_ROI_table_to_indices(\n    ROI: ad.AnnData,\n    full_res_pxl_sizes_zyx: Sequence[float],\n    level: int = 0,\n    coarsening_xy: int = 2,\n    cols_xyz_pos: Sequence[str] = [\n        \"x_micrometer\",\n        \"y_micrometer\",\n        \"z_micrometer\",\n    ],\n    cols_xyz_len: Sequence[str] = [\n        \"len_x_micrometer\",\n        \"len_y_micrometer\",\n        \"len_z_micrometer\",\n    ],\n) -&gt; list[list[int]]:\n\"\"\"\n    Convert a ROI AnnData table into integer array indices.\n\n    Args:\n        ROI: AnnData table with list of ROIs.\n        full_res_pxl_sizes_zyx:\n            Physical-unit pixel ZYX sizes at the full-resolution pyramid level.\n        level: Pyramid level.\n        coarsening_xy: Linear coarsening factor in the YX plane.\n        cols_xyz_pos: Column names for XYZ ROI positions.\n        cols_xyz_len: Column names for XYZ ROI edges.\n\n    Raises:\n        ValueError:\n            If any of the array indices is negative.\n\n    Returns:\n        Nested list of indices. The main list has one item per ROI. Each ROI\n            item is a list of six integers as in `[start_z, end_z, start_y,\n            end_y, start_x, end_x]`. The array-index interval for a given ROI\n            is `start_x:end_x` along X, and so on for Y and Z.\n    \"\"\"\n    # Handle empty ROI table\n    if len(ROI) == 0:\n        return []\n\n    # Set pyramid-level pixel sizes\n    pxl_size_z, pxl_size_y, pxl_size_x = full_res_pxl_sizes_zyx\n    prefactor = coarsening_xy**level\n    pxl_size_x *= prefactor\n    pxl_size_y *= prefactor\n\n    x_pos, y_pos, z_pos = cols_xyz_pos[:]\n    x_len, y_len, z_len = cols_xyz_len[:]\n\n    list_indices = []\n    for ROI_name in ROI.obs_names:\n        # Extract data from anndata table\n        x_micrometer = ROI[ROI_name, x_pos].X[0, 0]\n        y_micrometer = ROI[ROI_name, y_pos].X[0, 0]\n        z_micrometer = ROI[ROI_name, z_pos].X[0, 0]\n        len_x_micrometer = ROI[ROI_name, x_len].X[0, 0]\n        len_y_micrometer = ROI[ROI_name, y_len].X[0, 0]\n        len_z_micrometer = ROI[ROI_name, z_len].X[0, 0]\n\n        # Identify indices along the three dimensions\n        start_x = x_micrometer / pxl_size_x\n        end_x = (x_micrometer + len_x_micrometer) / pxl_size_x\n        start_y = y_micrometer / pxl_size_y\n        end_y = (y_micrometer + len_y_micrometer) / pxl_size_y\n        start_z = z_micrometer / pxl_size_z\n        end_z = (z_micrometer + len_z_micrometer) / pxl_size_z\n        indices = [start_z, end_z, start_y, end_y, start_x, end_x]\n\n        # Round indices to lower integer\n        indices = list(map(round, indices))\n\n        # Fail for negative indices\n        if min(indices) &lt; 0:\n            raise ValueError(\n                f\"ROI {ROI_name} converted into negative array indices.\\n\"\n                f\"ZYX position: {z_micrometer}, {y_micrometer}, \"\n                f\"{x_micrometer}\\n\"\n                f\"ZYX pixel sizes: {pxl_size_z}, {pxl_size_y}, \"\n                f\"{pxl_size_x} ({level=})\\n\"\n                \"Hint: As of fractal-tasks-core v0.12, FOV/well ROI \"\n                \"tables with non-zero origins (e.g. the ones created with \"\n                \"v0.11) are not supported.\"\n            )\n\n        # Append ROI indices to to list\n        list_indices.append(indices[:])\n\n    return list_indices\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/v1/#fractal_tasks_core.roi.v1.convert_ROIs_from_3D_to_2D","title":"<code>convert_ROIs_from_3D_to_2D(adata, pixel_size_z)</code>","text":"<p>TBD</p> <p>Note that this function is only relevant when the ROIs in adata span the whole extent of the Z axis. TODO: check this explicitly.</p> PARAMETER  DESCRIPTION <code>adata</code> <p>TBD</p> <p> TYPE: <code>AnnData</code> </p> <code>pixel_size_z</code> <p>TBD</p> <p> TYPE: <code>float</code> </p> Source code in <code>fractal_tasks_core/roi/v1.py</code> <pre><code>def convert_ROIs_from_3D_to_2D(\n    adata: ad.AnnData,\n    pixel_size_z: float,\n) -&gt; ad.AnnData:\n\"\"\"\n    TBD\n\n    Note that this function is only relevant when the ROIs in adata span the\n    whole extent of the Z axis.\n    TODO: check this explicitly.\n\n    Args:\n        adata: TBD\n        pixel_size_z: TBD\n    \"\"\"\n\n    # Compress a 3D stack of images to a single Z plane,\n    # with thickness equal to pixel_size_z\n    df = adata.to_df()\n    df[\"len_z_micrometer\"] = pixel_size_z\n\n    # Assign dtype explicitly, to avoid\n    # &gt;&gt; UserWarning: X converted to numpy array with dtype float64\n    # when creating AnnData object\n    df = df.astype(np.float32)\n\n    # Create an AnnData object directly from the DataFrame\n    new_adata = ad.AnnData(X=df)\n\n    # Rename rows and columns\n    new_adata.obs_names = adata.obs_names\n    new_adata.var_names = list(map(str, df.columns))\n\n    return new_adata\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/v1/#fractal_tasks_core.roi.v1.convert_indices_to_regions","title":"<code>convert_indices_to_regions(index)</code>","text":"<p>Converts index tuples to region tuple</p> PARAMETER  DESCRIPTION <code>index</code> <p>Tuple containing 6 entries of (z_start, z_end, y_start, y_end, x_start, x_end).</p> <p> TYPE: <code>list[int]</code> </p> RETURNS DESCRIPTION <code>region</code> <p>tuple of three slices (ZYX)</p> <p> TYPE: <code>tuple[slice, slice, slice]</code> </p> Source code in <code>fractal_tasks_core/roi/v1.py</code> <pre><code>def convert_indices_to_regions(\n    index: list[int],\n) -&gt; tuple[slice, slice, slice]:\n\"\"\"\n    Converts index tuples to region tuple\n\n    Args:\n        index: Tuple containing 6 entries of (z_start, z_end, y_start,\n            y_end, x_start, x_end).\n\n    Returns:\n        region: tuple of three slices (ZYX)\n    \"\"\"\n    return (\n        slice(index[0], index[1]),\n        slice(index[2], index[3]),\n        slice(index[4], index[5]),\n    )\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/v1/#fractal_tasks_core.roi.v1.empty_bounding_box_table","title":"<code>empty_bounding_box_table()</code>","text":"<p>Construct an empty bounding-box ROI table of given shape.</p> <p>This function mirrors the functionality of <code>array_to_bounding_box_table</code>, for the specific case where the array includes no label. The advantages of this function are that:</p> <ol> <li>It does not require computing a whole array of zeros;</li> <li>We avoid hardcoding column names in the task functions.</li> </ol> RETURNS DESCRIPTION <code>DataFrame</code> <p>DataFrame with no rows, and with columns corresponding to the output of <code>array_to_bounding_box_table</code>.</p> Source code in <code>fractal_tasks_core/roi/v1.py</code> <pre><code>def empty_bounding_box_table() -&gt; pd.DataFrame:\n\"\"\"\n    Construct an empty bounding-box ROI table of given shape.\n\n    This function mirrors the functionality of `array_to_bounding_box_table`,\n    for the specific case where the array includes no label. The advantages of\n    this function are that:\n\n    1. It does not require computing a whole array of zeros;\n    2. We avoid hardcoding column names in the task functions.\n\n    Returns:\n        DataFrame with no rows, and with columns corresponding to the output of\n            `array_to_bounding_box_table`.\n    \"\"\"\n\n    df_columns = [\n        \"x_micrometer\",\n        \"y_micrometer\",\n        \"z_micrometer\",\n        \"len_x_micrometer\",\n        \"len_y_micrometer\",\n        \"len_z_micrometer\",\n    ]\n    df = pd.DataFrame(columns=[x for x in df_columns] + [\"label\"])\n    return df\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/v1/#fractal_tasks_core.roi.v1.get_image_grid_ROIs","title":"<code>get_image_grid_ROIs(array_shape, pixels_ZYX, grid_YX_shape)</code>","text":"<p>Produce a table with ROIS placed on a rectangular grid.</p> <p>The main goal of this ROI grid is to allow processing of smaller subset of the whole array.</p> <p>In a specific case (that is, if the image array was obtained by stitching together a set of FOVs placed on a regular grid), the ROIs correspond to the original FOVs.</p> <p>TODO: make this flexible with respect to the presence/absence of Z.</p> PARAMETER  DESCRIPTION <code>array_shape</code> <p>ZYX shape of the image array.</p> <p> TYPE: <code>tuple[int, int, int]</code> </p> <code>pixels_ZYX</code> <p>ZYX pixel sizes in micrometers.</p> <p> TYPE: <code>list[float]</code> </p> <code>grid_YX_shape</code> <p> TYPE: <code>tuple[int, int]</code> </p> RETURNS DESCRIPTION <code>AnnData</code> <p>An <code>AnnData</code> table with a single ROI.</p> Source code in <code>fractal_tasks_core/roi/v1.py</code> <pre><code>def get_image_grid_ROIs(\n    array_shape: tuple[int, int, int],\n    pixels_ZYX: list[float],\n    grid_YX_shape: tuple[int, int],\n) -&gt; ad.AnnData:\n\"\"\"\n    Produce a table with ROIS placed on a rectangular grid.\n\n    The main goal of this ROI grid is to allow processing of smaller subset of\n    the whole array.\n\n    In a specific case (that is, if the image array was obtained by stitching\n    together a set of FOVs placed on a regular grid), the ROIs correspond to\n    the original FOVs.\n\n    TODO: make this flexible with respect to the presence/absence of Z.\n\n    Args:\n        array_shape: ZYX shape of the image array.\n        pixels_ZYX: ZYX pixel sizes in micrometers.\n        grid_YX_shape:\n\n    Returns:\n        An `AnnData` table with a single ROI.\n    \"\"\"\n    shape_z, shape_y, shape_x = array_shape[-3:]\n    grid_size_y, grid_size_x = grid_YX_shape[:]\n    X = []\n    obs_names = []\n    counter = 0\n    start_z = 0\n    len_z = shape_z\n\n    # Find minimal len_y that covers [0,shape_y] with grid_size_y intervals\n    len_y = math.ceil(shape_y / grid_size_y)\n    len_x = math.ceil(shape_x / grid_size_x)\n    for ind_y in range(grid_size_y):\n        start_y = ind_y * len_y\n        tmp_len_y = min(shape_y, start_y + len_y) - start_y\n        for ind_x in range(grid_size_x):\n            start_x = ind_x * len_x\n            tmp_len_x = min(shape_x, start_x + len_x) - start_x\n            X.append(\n                [\n                    start_x * pixels_ZYX[2],\n                    start_y * pixels_ZYX[1],\n                    start_z * pixels_ZYX[0],\n                    tmp_len_x * pixels_ZYX[2],\n                    tmp_len_y * pixels_ZYX[1],\n                    len_z * pixels_ZYX[0],\n                ]\n            )\n            counter += 1\n            obs_names.append(f\"ROI_{counter}\")\n    ROI_table = ad.AnnData(X=np.array(X, dtype=np.float32))\n    ROI_table.obs_names = obs_names\n    ROI_table.var_names = [\n        \"x_micrometer\",\n        \"y_micrometer\",\n        \"z_micrometer\",\n        \"len_x_micrometer\",\n        \"len_y_micrometer\",\n        \"len_z_micrometer\",\n    ]\n    return ROI_table\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/v1/#fractal_tasks_core.roi.v1.get_single_image_ROI","title":"<code>get_single_image_ROI(array_shape, pixels_ZYX)</code>","text":"<p>Produce a table with a single ROI that covers the whole array</p> <p>TODO: make this flexible with respect to the presence/absence of Z.</p> PARAMETER  DESCRIPTION <code>array_shape</code> <p>ZYX shape of the image array.</p> <p> TYPE: <code>tuple[int, int, int]</code> </p> <code>pixels_ZYX</code> <p>ZYX pixel sizes in micrometers.</p> <p> TYPE: <code>list[float]</code> </p> RETURNS DESCRIPTION <code>AnnData</code> <p>An <code>AnnData</code> table with a single ROI.</p> Source code in <code>fractal_tasks_core/roi/v1.py</code> <pre><code>def get_single_image_ROI(\n    array_shape: tuple[int, int, int],\n    pixels_ZYX: list[float],\n) -&gt; ad.AnnData:\n\"\"\"\n    Produce a table with a single ROI that covers the whole array\n\n    TODO: make this flexible with respect to the presence/absence of Z.\n\n    Args:\n        array_shape: ZYX shape of the image array.\n        pixels_ZYX: ZYX pixel sizes in micrometers.\n\n    Returns:\n        An `AnnData` table with a single ROI.\n    \"\"\"\n    shape_z, shape_y, shape_x = array_shape[-3:]\n    ROI_table = ad.AnnData(\n        X=np.array(\n            [\n                [\n                    0.0,\n                    0.0,\n                    0.0,\n                    shape_x * pixels_ZYX[2],\n                    shape_y * pixels_ZYX[1],\n                    shape_z * pixels_ZYX[0],\n                ],\n            ],\n            dtype=np.float32,\n        )\n    )\n    ROI_table.obs_names = [\"image_1\"]\n    ROI_table.var_names = [\n        \"x_micrometer\",\n        \"y_micrometer\",\n        \"z_micrometer\",\n        \"len_x_micrometer\",\n        \"len_y_micrometer\",\n        \"len_z_micrometer\",\n    ]\n    return ROI_table\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/v1/#fractal_tasks_core.roi.v1.is_standard_roi_table","title":"<code>is_standard_roi_table(table)</code>","text":"<p>True if the name of the table contains one of the standard Fractal tables</p> <p>If a table name is well_ROI_table, FOV_ROI_table or contains either of the two (e.g. registered_FOV_ROI_table), this function returns True.</p> PARAMETER  DESCRIPTION <code>table</code> <p>table name</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>bool of whether it's a standard ROI table</p> Source code in <code>fractal_tasks_core/roi/v1.py</code> <pre><code>def is_standard_roi_table(table: str) -&gt; bool:\n\"\"\"\n    True if the name of the table contains one of the standard Fractal tables\n\n    If a table name is well_ROI_table, FOV_ROI_table or contains either of the\n    two (e.g. registered_FOV_ROI_table), this function returns True.\n\n    Args:\n        table: table name\n\n    Returns:\n        bool of whether it's a standard ROI table\n\n    \"\"\"\n    if \"well_ROI_table\" in table:\n        return True\n    elif \"FOV_ROI_table\" in table:\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/v1/#fractal_tasks_core.roi.v1.prepare_FOV_ROI_table","title":"<code>prepare_FOV_ROI_table(df, metadata=('time'))</code>","text":"<p>Prepare an AnnData table for fields-of-view ROIs.</p> PARAMETER  DESCRIPTION <code>df</code> <p>Input dataframe, possibly prepared through <code>parse_yokogawa_metadata</code>.</p> <p> TYPE: <code>DataFrame</code> </p> <code>metadata</code> <p>Columns of <code>df</code> to be stored (if present) into AnnData table <code>obs</code>.</p> <p> TYPE: <code>tuple[str, ...]</code> DEFAULT: <code>('time')</code> </p> Source code in <code>fractal_tasks_core/roi/v1.py</code> <pre><code>def prepare_FOV_ROI_table(\n    df: pd.DataFrame, metadata: tuple[str, ...] = (\"time\",)\n) -&gt; ad.AnnData:\n\"\"\"\n    Prepare an AnnData table for fields-of-view ROIs.\n\n    Args:\n        df:\n            Input dataframe, possibly prepared through\n            `parse_yokogawa_metadata`.\n        metadata:\n            Columns of `df` to be stored (if present) into AnnData table `obs`.\n    \"\"\"\n\n    # Make a local copy of the dataframe, to avoid SettingWithCopyWarning\n    df = df.copy()\n\n    # Convert DataFrame index to str, to avoid\n    # &gt;&gt; ImplicitModificationWarning: Transforming to str index\n    # when creating AnnData object.\n    # Do this in the beginning to allow concatenation with e.g. time\n    df.index = df.index.astype(str)\n\n    # Obtain box size in physical units\n    df = df.assign(len_x_micrometer=df.x_pixel * df.pixel_size_x)\n    df = df.assign(len_y_micrometer=df.y_pixel * df.pixel_size_y)\n    df = df.assign(len_z_micrometer=df.z_pixel * df.pixel_size_z)\n\n    # Select only the numeric positional columns needed to define ROIs\n    # (to avoid) casting things like the data column to float32\n    # or to use unnecessary columns like bit_depth\n    positional_columns = [\n        \"x_micrometer\",\n        \"y_micrometer\",\n        \"z_micrometer\",\n        \"len_x_micrometer\",\n        \"len_y_micrometer\",\n        \"len_z_micrometer\",\n        \"x_micrometer_original\",\n        \"y_micrometer_original\",\n    ]\n\n    # Assign dtype explicitly, to avoid\n    # &gt;&gt; UserWarning: X converted to numpy array with dtype float64\n    # when creating AnnData object\n    df_roi = df.loc[:, positional_columns].astype(np.float32)\n\n    # Create an AnnData object directly from the DataFrame\n    adata = ad.AnnData(X=df_roi)\n\n    # Reset origin of the FOV ROI table, so that it matches with the well\n    # origin\n    adata = reset_origin(adata)\n\n    # Save any metadata that is specified to the obs df\n    for col in metadata:\n        if col in df:\n            # Cast all metadata to str.\n            # Reason: AnnData Zarr writers don't support all pandas types.\n            # e.g. pandas.core.arrays.datetimes.DatetimeArray can't be written\n            adata.obs[col] = df[col].astype(str)\n\n    # Rename rows and columns: Maintain FOV indices from the dataframe\n    # (they are already enforced to be unique by Pandas and may contain\n    # information for the user, as they are based on the filenames)\n    adata.obs_names = \"FOV_\" + adata.obs.index\n    adata.var_names = list(map(str, df_roi.columns))\n\n    return adata\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/v1/#fractal_tasks_core.roi.v1.prepare_well_ROI_table","title":"<code>prepare_well_ROI_table(df, metadata=('time'))</code>","text":"<p>Prepare an AnnData table with a single well ROI.</p> PARAMETER  DESCRIPTION <code>df</code> <p>Input dataframe, possibly prepared through <code>parse_yokogawa_metadata</code>.</p> <p> TYPE: <code>DataFrame</code> </p> <code>metadata</code> <p>Columns of <code>df</code> to be stored (if present) into AnnData table <code>obs</code>.</p> <p> TYPE: <code>tuple[str, ...]</code> DEFAULT: <code>('time')</code> </p> Source code in <code>fractal_tasks_core/roi/v1.py</code> <pre><code>def prepare_well_ROI_table(\n    df: pd.DataFrame, metadata: tuple[str, ...] = (\"time\",)\n) -&gt; ad.AnnData:\n\"\"\"\n    Prepare an AnnData table with a single well ROI.\n\n    Args:\n        df:\n            Input dataframe, possibly prepared through\n            `parse_yokogawa_metadata`.\n        metadata:\n            Columns of `df` to be stored (if present) into AnnData table `obs`.\n    \"\"\"\n\n    # Make a local copy of the dataframe, to avoid SettingWithCopyWarning\n    df = df.copy()\n\n    # Convert DataFrame index to str, to avoid\n    # &gt;&gt; ImplicitModificationWarning: Transforming to str index\n    # when creating AnnData object.\n    # Do this in the beginning to allow concatenation with e.g. time\n    df.index = df.index.astype(str)\n\n    # Calculate bounding box extents in physical units\n    for mu in [\"x\", \"y\", \"z\"]:\n        # Obtain per-FOV properties in physical units.\n        # NOTE: a FOV ROI is defined here as the interval [min_micrometer,\n        # max_micrometer], with max_micrometer=min_micrometer+len_micrometer\n        min_micrometer = df[f\"{mu}_micrometer\"]\n        len_micrometer = df[f\"{mu}_pixel\"] * df[f\"pixel_size_{mu}\"]\n        max_micrometer = min_micrometer + len_micrometer\n        # Obtain well bounding box, in physical units\n        min_min_micrometer = min_micrometer.min()\n        max_max_micrometer = max_micrometer.max()\n        df[f\"{mu}_micrometer\"] = min_min_micrometer\n        df[f\"len_{mu}_micrometer\"] = max_max_micrometer - min_min_micrometer\n\n    # Select only the numeric positional columns needed to define ROIs\n    # (to avoid) casting things like the data column to float32\n    # or to use unnecessary columns like bit_depth\n    positional_columns = [\n        \"x_micrometer\",\n        \"y_micrometer\",\n        \"z_micrometer\",\n        \"len_x_micrometer\",\n        \"len_y_micrometer\",\n        \"len_z_micrometer\",\n    ]\n\n    # Assign dtype explicitly, to avoid\n    # &gt;&gt; UserWarning: X converted to numpy array with dtype float64\n    # when creating AnnData object\n    df_roi = df.iloc[0:1, :].loc[:, positional_columns].astype(np.float32)\n\n    # Create an AnnData object directly from the DataFrame\n    adata = ad.AnnData(X=df_roi)\n\n    # Reset origin of the single-entry well ROI table\n    adata = reset_origin(adata)\n\n    # Save any metadata that is specified to the obs df\n    for col in metadata:\n        if col in df:\n            # Cast all metadata to str.\n            # Reason: AnnData Zarr writers don't support all pandas types.\n            # e.g. pandas.core.arrays.datetimes.DatetimeArray can't be written\n            adata.obs[col] = df[col].astype(str)\n\n    # Rename rows and columns: Maintain FOV indices from the dataframe\n    # (they are already enforced to be unique by Pandas and may contain\n    # information for the user, as they are based on the filenames)\n    adata.obs_names = \"well_\" + adata.obs.index\n    adata.var_names = list(map(str, df_roi.columns))\n\n    return adata\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/v1/#fractal_tasks_core.roi.v1.reset_origin","title":"<code>reset_origin(ROI_table, x_pos='x_micrometer', y_pos='y_micrometer', z_pos='z_micrometer')</code>","text":"<p>Return a copy of a ROI table, with shifted-to-zero origin for some columns.</p> PARAMETER  DESCRIPTION <code>ROI_table</code> <p>Original ROI table.</p> <p> TYPE: <code>AnnData</code> </p> <code>x_pos</code> <p>Name of the column with X position of ROIs.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'x_micrometer'</code> </p> <code>y_pos</code> <p>Name of the column with Y position of ROIs.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'y_micrometer'</code> </p> <code>z_pos</code> <p>Name of the column with Z position of ROIs.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'z_micrometer'</code> </p> RETURNS DESCRIPTION <code>AnnData</code> <p>A copy of the <code>ROI_table</code> AnnData table, where values of <code>x_pos</code>, <code>y_pos</code> and <code>z_pos</code> columns have been shifted by their minimum values.</p> Source code in <code>fractal_tasks_core/roi/v1.py</code> <pre><code>def reset_origin(\n    ROI_table: ad.AnnData,\n    x_pos: str = \"x_micrometer\",\n    y_pos: str = \"y_micrometer\",\n    z_pos: str = \"z_micrometer\",\n) -&gt; ad.AnnData:\n\"\"\"\n    Return a copy of a ROI table, with shifted-to-zero origin for some columns.\n\n    Args:\n        ROI_table: Original ROI table.\n        x_pos: Name of the column with X position of ROIs.\n        y_pos: Name of the column with Y position of ROIs.\n        z_pos: Name of the column with Z position of ROIs.\n\n    Returns:\n        A copy of the `ROI_table` AnnData table, where values of `x_pos`,\n            `y_pos` and `z_pos` columns have been shifted by their minimum\n            values.\n    \"\"\"\n    new_table = ROI_table.copy()\n\n    origin_x = min(new_table[:, x_pos].X[:, 0])\n    origin_y = min(new_table[:, y_pos].X[:, 0])\n    origin_z = min(new_table[:, z_pos].X[:, 0])\n\n    for FOV in new_table.obs_names:\n        new_table[FOV, x_pos] = new_table[FOV, x_pos].X[0, 0] - origin_x\n        new_table[FOV, y_pos] = new_table[FOV, y_pos].X[0, 0] - origin_y\n        new_table[FOV, z_pos] = new_table[FOV, z_pos].X[0, 0] - origin_z\n\n    return new_table\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/v1_checks/","title":"v1_checks","text":"<p>Functions to check content of ROI tables.</p>"},{"location":"reference/fractal_tasks_core/roi/v1_checks/#fractal_tasks_core.roi.v1_checks.are_ROI_table_columns_valid","title":"<code>are_ROI_table_columns_valid(*, table)</code>","text":"<p>Verify some validity assumptions on a ROI table.</p> <p>This function reflects our current working assumptions (e.g. the presence of some specific columns); this may change in future versions.</p> PARAMETER  DESCRIPTION <code>table</code> <p>AnnData table to be checked</p> <p> TYPE: <code>AnnData</code> </p> Source code in <code>fractal_tasks_core/roi/v1_checks.py</code> <pre><code>def are_ROI_table_columns_valid(*, table: ad.AnnData) -&gt; None:\n\"\"\"\n    Verify some validity assumptions on a ROI table.\n\n    This function reflects our current working assumptions (e.g. the presence\n    of some specific columns); this may change in future versions.\n\n    Args:\n        table: AnnData table to be checked\n    \"\"\"\n\n    # Hard constraint: table columns must include some expected ones\n    columns = [\n        \"x_micrometer\",\n        \"y_micrometer\",\n        \"z_micrometer\",\n        \"len_x_micrometer\",\n        \"len_y_micrometer\",\n        \"len_z_micrometer\",\n    ]\n    for column in columns:\n        if column not in table.var_names:\n            raise ValueError(f\"Column {column} is not present in ROI table\")\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/v1_checks/#fractal_tasks_core.roi.v1_checks.check_valid_ROI_indices","title":"<code>check_valid_ROI_indices(list_indices, ROI_table_name)</code>","text":"<p>Check that list of indices has zero origin on each axis.</p> <p>See fractal-tasks-core issues #530 and #554.</p> <p>This helper function is meant to provide informative error messages when ROI tables created with fractal-tasks-core up to v0.11 are used in v0.12. This function will be deprecated and removed as soon as the v0.11/v0.12 transition advances.</p> <p>Note that only <code>FOV_ROI_table</code> and <code>well_ROI_table</code> have to fulfill this constraint, while ROI tables obtained through segmentation may have arbitrary (non-negative) indices.</p> PARAMETER  DESCRIPTION <code>list_indices</code> <p>Output of <code>convert_ROI_table_to_indices</code>; each item is like <code>[start_z, end_z, start_y, end_y, start_x, end_x]</code>.</p> <p> TYPE: <code>list[list[int]]</code> </p> <code>ROI_table_name</code> <p>Name of the ROI table.</p> <p> TYPE: <code>str</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the table name is <code>FOV_ROI_table</code> or <code>well_ROI_table</code> and the     minimum value of <code>start_x</code>, <code>start_y</code> and <code>start_z</code> are not all     zero.</p> Source code in <code>fractal_tasks_core/roi/v1_checks.py</code> <pre><code>def check_valid_ROI_indices(\n    list_indices: list[list[int]],\n    ROI_table_name: str,\n) -&gt; None:\n\"\"\"\n    Check that list of indices has zero origin on each axis.\n\n    See fractal-tasks-core issues #530 and #554.\n\n    This helper function is meant to provide informative error messages when\n    ROI tables created with fractal-tasks-core up to v0.11 are used in v0.12.\n    This function will be deprecated and removed as soon as the v0.11/v0.12\n    transition advances.\n\n    Note that only `FOV_ROI_table` and `well_ROI_table` have to fulfill this\n    constraint, while ROI tables obtained through segmentation may have\n    arbitrary (non-negative) indices.\n\n    Args:\n        list_indices:\n            Output of `convert_ROI_table_to_indices`; each item is like\n            `[start_z, end_z, start_y, end_y, start_x, end_x]`.\n        ROI_table_name: Name of the ROI table.\n\n    Raises:\n        ValueError:\n            If the table name is `FOV_ROI_table` or `well_ROI_table` and the\n                minimum value of `start_x`, `start_y` and `start_z` are not all\n                zero.\n    \"\"\"\n    if ROI_table_name not in [\"FOV_ROI_table\", \"well_ROI_table\"]:\n        # This validation function only applies to the FOV/well ROI tables\n        # generated with fractal-tasks-core\n        return\n\n    # Find minimum index along ZYX\n    min_start_z = min(item[0] for item in list_indices)\n    min_start_y = min(item[2] for item in list_indices)\n    min_start_x = min(item[4] for item in list_indices)\n\n    # Check that minimum indices are all zero\n    for ind, min_index in enumerate((min_start_z, min_start_y, min_start_x)):\n        if min_index != 0:\n            axis = [\"Z\", \"Y\", \"X\"][ind]\n            raise ValueError(\n                f\"{axis} component of ROI indices for table `{ROI_table_name}`\"\n                f\" do not start with 0, but with {min_index}.\\n\"\n                \"Hint: As of fractal-tasks-core v0.12, FOV/well ROI \"\n                \"tables with non-zero origins (e.g. the ones created with \"\n                \"v0.11) are not supported.\"\n            )\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/v1_checks/#fractal_tasks_core.roi.v1_checks.is_ROI_table_valid","title":"<code>is_ROI_table_valid(*, table_path, use_masks)</code>","text":"<p>Verify some validity assumptions on a ROI table.</p> <p>This function reflects our current working assumptions (e.g. the presence of some specific columns); this may change in future versions.</p> <p>If <code>use_masks=True</code>, we verify that the table is a valid <code>masking_roi_table</code> as of table specifications V1; if this check fails, <code>use_masks</code> should be set to <code>False</code> upstream in the parent function.</p> PARAMETER  DESCRIPTION <code>table_path</code> <p>Path of the AnnData ROI table to be checked.</p> <p> TYPE: <code>str</code> </p> <code>use_masks</code> <p>If <code>True</code>, perform some additional checks related to masked loading.</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>Optional[bool]</code> <p>Always <code>None</code> if <code>use_masks=False</code>, otherwise return whether the table is valid for masked loading.</p> Source code in <code>fractal_tasks_core/roi/v1_checks.py</code> <pre><code>def is_ROI_table_valid(*, table_path: str, use_masks: bool) -&gt; Optional[bool]:\n\"\"\"\n    Verify some validity assumptions on a ROI table.\n\n    This function reflects our current working assumptions (e.g. the presence\n    of some specific columns); this may change in future versions.\n\n    If `use_masks=True`, we verify that the table is a valid\n    `masking_roi_table` as of table specifications V1; if this check fails,\n    `use_masks` should be set to `False` upstream in the parent function.\n\n    Args:\n        table_path: Path of the AnnData ROI table to be checked.\n        use_masks: If `True`, perform some additional checks related to\n            masked loading.\n\n    Returns:\n        Always `None` if `use_masks=False`, otherwise return whether the table\n            is valid for masked loading.\n    \"\"\"\n\n    table = ad.read_zarr(table_path)\n    are_ROI_table_columns_valid(table=table)\n    if not use_masks:\n        return None\n\n    # Check whether the table can be used for masked loading\n    attrs = zarr.group(table_path).attrs.asdict()\n    logger.info(f\"ROI table at {table_path} has attrs: {attrs}\")\n    try:\n        MaskingROITableAttrs(**attrs)\n        logging.info(\"ROI table can be used for masked loading\")\n        return True\n    except ValidationError:\n        logging.info(\"ROI table cannot be used for masked loading\")\n        return False\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/v1_overlaps/","title":"v1_overlaps","text":"<p>Functions to identify and remove ROI overlaps, based on V1 table specs.</p>"},{"location":"reference/fractal_tasks_core/roi/v1_overlaps/#fractal_tasks_core.roi.v1_overlaps.apply_shift_in_one_direction","title":"<code>apply_shift_in_one_direction(tmp_df_well, line_1, line_2, mu, tol=1e-10)</code>","text":"<p>TBD</p> PARAMETER  DESCRIPTION <code>tmp_df_well</code> <p>TBD</p> <p> TYPE: <code>DataFrame</code> </p> <code>line_1</code> <p>TBD</p> <p> TYPE: <code>Sequence[float]</code> </p> <code>line_2</code> <p>TBD</p> <p> TYPE: <code>Sequence[float]</code> </p> <code>mu</code> <p>TBD</p> <p> TYPE: <code>str</code> </p> <code>tol</code> <p>TBD</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-10</code> </p> Source code in <code>fractal_tasks_core/roi/v1_overlaps.py</code> <pre><code>def apply_shift_in_one_direction(\n    tmp_df_well: pd.DataFrame,\n    line_1: Sequence[float],\n    line_2: Sequence[float],\n    mu: str,\n    tol: float = 1e-10,\n):\n\"\"\"\n    TBD\n\n    Args:\n        tmp_df_well: TBD\n        line_1: TBD\n        line_2: TBD\n        mu: TBD\n        tol: TBD\n    \"\"\"\n    min_1, max_1 = line_1[:]\n    min_2, max_2 = line_2[:]\n    min_max = min(max_1, max_2)\n    max_min = max(min_1, min_2)\n    shift = min_max - max_min\n    logging.debug(f\"{mu}-shifting by {shift=}\")\n    ind = tmp_df_well.loc[:, f\"{mu}min\"] &gt;= max_min - tol\n    if not (shift &gt; 0.0 and ind.to_numpy().max() &gt; 0):\n        raise ValueError(\n            \"Something wrong in apply_shift_in_one_direction\\n\"\n            f\"{mu=}\\n{shift=}\\n{ind.to_numpy()=}\"\n        )\n    tmp_df_well.loc[ind, f\"{mu}min\"] += shift\n    tmp_df_well.loc[ind, f\"{mu}max\"] += shift\n    tmp_df_well.loc[ind, f\"{mu}_micrometer\"] += shift\n    return tmp_df_well\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/v1_overlaps/#fractal_tasks_core.roi.v1_overlaps.check_well_for_FOV_overlap","title":"<code>check_well_for_FOV_overlap(site_metadata, selected_well, plotting_function, tol=1e-10)</code>","text":"<p>This function is currently only used in tests and examples.</p> <p>The <code>plotting_function</code> parameter is exposed so that other tools (see examples in this repository) may use it to show the FOV ROIs.</p> PARAMETER  DESCRIPTION <code>site_metadata</code> <p>TBD</p> <p> TYPE: <code>DataFrame</code> </p> <code>selected_well</code> <p>TBD</p> <p> TYPE: <code>str</code> </p> <code>plotting_function</code> <p>TBD</p> <p> TYPE: <code>Callable</code> </p> <code>tol</code> <p>TBD</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-10</code> </p> Source code in <code>fractal_tasks_core/roi/v1_overlaps.py</code> <pre><code>def check_well_for_FOV_overlap(\n    site_metadata: pd.DataFrame,\n    selected_well: str,\n    plotting_function: Callable,\n    tol: float = 1e-10,\n):\n\"\"\"\n    This function is currently only used in tests and examples.\n\n    The `plotting_function` parameter is exposed so that other tools (see\n    examples in this repository) may use it to show the FOV ROIs.\n\n    Args:\n        site_metadata: TBD\n        selected_well: TBD\n        plotting_function: TBD\n        tol: TBD\n    \"\"\"\n\n    df = site_metadata.loc[selected_well].copy()\n    df[\"xmin\"] = df[\"x_micrometer\"]\n    df[\"ymin\"] = df[\"y_micrometer\"]\n    df[\"xmax\"] = df[\"x_micrometer\"] + df[\"pixel_size_x\"] * df[\"x_pixel\"]\n    df[\"ymax\"] = df[\"y_micrometer\"] + df[\"pixel_size_y\"] * df[\"y_pixel\"]\n\n    xmin = list(df.loc[:, \"xmin\"])\n    ymin = list(df.loc[:, \"ymin\"])\n    xmax = list(df.loc[:, \"xmax\"])\n    ymax = list(df.loc[:, \"ymax\"])\n    num_lines = len(xmin)\n\n    list_overlapping_FOVs = []\n    for line_1 in range(num_lines):\n        min_x_1, max_x_1 = [a[line_1] for a in [xmin, xmax]]\n        min_y_1, max_y_1 = [a[line_1] for a in [ymin, ymax]]\n        for line_2 in range(line_1):\n            min_x_2, max_x_2 = [a[line_2] for a in [xmin, xmax]]\n            min_y_2, max_y_2 = [a[line_2] for a in [ymin, ymax]]\n            overlap = is_overlapping_2D(\n                (min_x_1, min_y_1, max_x_1, max_y_1),\n                (min_x_2, min_y_2, max_x_2, max_y_2),\n                tol=tol,\n            )\n            if overlap:\n                list_overlapping_FOVs.append(line_1)\n                list_overlapping_FOVs.append(line_2)\n\n    # Call plotting_function\n    plotting_function(\n        xmin, xmax, ymin, ymax, list_overlapping_FOVs, selected_well\n    )\n\n    if len(list_overlapping_FOVs) &gt; 0:\n        # Increase values by one to switch from index to the label plotted\n        return {selected_well: [x + 1 for x in list_overlapping_FOVs]}\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/v1_overlaps/#fractal_tasks_core.roi.v1_overlaps.find_overlaps_in_ROI_indices","title":"<code>find_overlaps_in_ROI_indices(list_indices)</code>","text":"<p>Given a list of integer ROI indices, find whether there are overlaps.</p> PARAMETER  DESCRIPTION <code>list_indices</code> <p>List of ROI indices, where each element in the list should look like <code>[start_z, end_z, start_y, end_y, start_x, end_x]</code>.</p> <p> TYPE: <code>list[list[int]]</code> </p> RETURNS DESCRIPTION <code>Optional[tuple[int, int]]</code> <p><code>None</code> if no overlap was detected, otherwise a tuple with the positional indices of a pair of overlapping ROIs.</p> Source code in <code>fractal_tasks_core/roi/v1_overlaps.py</code> <pre><code>def find_overlaps_in_ROI_indices(\n    list_indices: list[list[int]],\n) -&gt; Optional[tuple[int, int]]:\n\"\"\"\n    Given a list of integer ROI indices, find whether there are overlaps.\n\n    Args:\n        list_indices: List of ROI indices, where each element in the list\n            should look like\n            `[start_z, end_z, start_y, end_y, start_x, end_x]`.\n\n    Returns:\n        `None` if no overlap was detected, otherwise a tuple with the\n            positional indices of a pair of overlapping ROIs.\n    \"\"\"\n\n    for ind_1, ROI_1 in enumerate(list_indices):\n        s_z, e_z, s_y, e_y, s_x, e_x = ROI_1[:]\n        box_1 = [s_x, s_y, s_z, e_x, e_y, e_z]\n        for ind_2 in range(ind_1):\n            ROI_2 = list_indices[ind_2]\n            s_z, e_z, s_y, e_y, s_x, e_x = ROI_2[:]\n            box_2 = [s_x, s_y, s_z, e_x, e_y, e_z]\n            if _is_overlapping_3D_int(box_1, box_2):\n                return (ind_1, ind_2)\n    return None\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/v1_overlaps/#fractal_tasks_core.roi.v1_overlaps.get_overlapping_pair","title":"<code>get_overlapping_pair(tmp_df, tol=1e-10)</code>","text":"<p>Finds the indices for the next overlapping FOVs pair.</p> <p>Note: the returned indices are positional indices, starting from 0.</p> PARAMETER  DESCRIPTION <code>tmp_df</code> <p>Dataframe with columns <code>[\"xmin\", \"ymin\", \"xmax\", \"ymax\"]</code>.</p> <p> TYPE: <code>DataFrame</code> </p> <code>tol</code> <p>Finite tolerance for floating-point comparisons.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-10</code> </p> Source code in <code>fractal_tasks_core/roi/v1_overlaps.py</code> <pre><code>def get_overlapping_pair(\n    tmp_df: pd.DataFrame, tol: float = 1e-10\n) -&gt; Union[tuple[int, int], bool]:\n\"\"\"\n    Finds the indices for the next overlapping FOVs pair.\n\n    Note: the returned indices are positional indices, starting from 0.\n\n    Args:\n        tmp_df: Dataframe with columns `[\"xmin\", \"ymin\", \"xmax\", \"ymax\"]`.\n        tol: Finite tolerance for floating-point comparisons.\n    \"\"\"\n\n    num_lines = len(tmp_df.index)\n    for pos_ind_1 in range(num_lines):\n        for pos_ind_2 in range(pos_ind_1):\n            if is_overlapping_2D(\n                tmp_df.iloc[pos_ind_1], tmp_df.iloc[pos_ind_2], tol=tol\n            ):\n                return (pos_ind_1, pos_ind_2)\n    return False\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/v1_overlaps/#fractal_tasks_core.roi.v1_overlaps.get_overlapping_pairs_3D","title":"<code>get_overlapping_pairs_3D(tmp_df, full_res_pxl_sizes_zyx)</code>","text":"<p>Finds the indices for the all overlapping FOVs pair, in three dimensions.</p> <p>Note: the returned indices are positional indices, starting from 0.</p> PARAMETER  DESCRIPTION <code>tmp_df</code> <p>Dataframe with columns <code>{x,y,z}_micrometer</code> and <code>len_{x,y,z}_micrometer</code>.</p> <p> TYPE: <code>DataFrame</code> </p> <code>full_res_pxl_sizes_zyx</code> <p>TBD</p> <p> TYPE: <code>Sequence[float]</code> </p> Source code in <code>fractal_tasks_core/roi/v1_overlaps.py</code> <pre><code>def get_overlapping_pairs_3D(\n    tmp_df: pd.DataFrame,\n    full_res_pxl_sizes_zyx: Sequence[float],\n):\n\"\"\"\n    Finds the indices for the all overlapping FOVs pair, in three dimensions.\n\n    Note: the returned indices are positional indices, starting from 0.\n\n    Args:\n        tmp_df: Dataframe with columns `{x,y,z}_micrometer` and\n            `len_{x,y,z}_micrometer`.\n        full_res_pxl_sizes_zyx: TBD\n    \"\"\"\n\n    tol = 1e-10\n    if tol &gt; min(full_res_pxl_sizes_zyx) / 1e3:\n        raise ValueError(f\"{tol=} but {full_res_pxl_sizes_zyx=}\")\n\n    new_tmp_df = tmp_df.copy()\n\n    new_tmp_df[\"x_micrometer_max\"] = (\n        new_tmp_df[\"x_micrometer\"] + new_tmp_df[\"len_x_micrometer\"]\n    )\n    new_tmp_df[\"y_micrometer_max\"] = (\n        new_tmp_df[\"y_micrometer\"] + new_tmp_df[\"len_y_micrometer\"]\n    )\n    new_tmp_df[\"z_micrometer_max\"] = (\n        new_tmp_df[\"z_micrometer\"] + new_tmp_df[\"len_z_micrometer\"]\n    )\n    # Remove columns which are not necessary for overlap checks\n    list_columns = [\n        \"len_x_micrometer\",\n        \"len_y_micrometer\",\n        \"len_z_micrometer\",\n        \"label\",\n    ]\n    new_tmp_df.drop(labels=list_columns, axis=1, inplace=True)\n\n    # Loop over all pairs, and construct list of overlapping ones\n    num_lines = len(new_tmp_df.index)\n    overlapping_list = []\n    for pos_ind_1 in range(num_lines):\n        for pos_ind_2 in range(pos_ind_1):\n            overlap = is_overlapping_3D(\n                new_tmp_df.iloc[pos_ind_1], new_tmp_df.iloc[pos_ind_2], tol=tol\n            )\n            if overlap:\n                overlapping_list.append((pos_ind_1, pos_ind_2))\n    return overlapping_list\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/v1_overlaps/#fractal_tasks_core.roi.v1_overlaps.remove_FOV_overlaps","title":"<code>remove_FOV_overlaps(df)</code>","text":"<p>Given a metadata dataframe, shift its columns to remove FOV overlaps.</p> PARAMETER  DESCRIPTION <code>df</code> <p>Metadata dataframe.</p> <p> TYPE: <code>DataFrame</code> </p> Source code in <code>fractal_tasks_core/roi/v1_overlaps.py</code> <pre><code>def remove_FOV_overlaps(df: pd.DataFrame):\n\"\"\"\n    Given a metadata dataframe, shift its columns to remove FOV overlaps.\n\n    Args:\n        df: Metadata dataframe.\n    \"\"\"\n\n    # Set tolerance (this should be much smaller than pixel size or expected\n    # round-offs), and maximum number of iterations in constraint solver\n    tol = 1e-10\n    max_iterations = 200\n\n    # Create a local copy of the dataframe\n    df = df.copy()\n\n    # Create temporary columns (to streamline overlap removals), which are\n    # then removed at the end of the remove_FOV_overlaps function\n    df[\"xmin\"] = df[\"x_micrometer\"]\n    df[\"ymin\"] = df[\"y_micrometer\"]\n    df[\"xmax\"] = df[\"x_micrometer\"] + df[\"pixel_size_x\"] * df[\"x_pixel\"]\n    df[\"ymax\"] = df[\"y_micrometer\"] + df[\"pixel_size_y\"] * df[\"y_pixel\"]\n    list_columns = [\"xmin\", \"ymin\", \"xmax\", \"ymax\"]\n\n    # Create columns with the original positions (not to be removed)\n    df[\"x_micrometer_original\"] = df[\"x_micrometer\"]\n    df[\"y_micrometer_original\"] = df[\"y_micrometer\"]\n\n    # Check that tolerance is much smaller than pixel sizes\n    min_pixel_size = df[[\"pixel_size_x\", \"pixel_size_y\"]].min().min()\n    if tol &gt; min_pixel_size / 1e3:\n        raise ValueError(\n            f\"In remove_FOV_overlaps, {tol=} but {min_pixel_size=}\"\n        )\n\n    # Loop over wells\n    wells = sorted(list(set([ind[0] for ind in df.index])))\n    for well in wells:\n\n        logger.info(f\"removing FOV overlaps for {well=}\")\n        df_well = df.loc[well].copy()\n\n        # NOTE: these are positional indices (i.e. starting from 0)\n        pair_pos_indices = get_overlapping_pair(df_well[list_columns], tol=tol)\n\n        # Keep going until there are no overlaps, or until iteration reaches\n        # max_iterations\n        iteration = 0\n        while pair_pos_indices:\n            iteration += 1\n\n            # Identify overlapping FOVs\n            pos_ind_1, pos_ind_2 = pair_pos_indices\n            fov_id_1 = df_well.index[pos_ind_1]\n            fov_id_2 = df_well.index[pos_ind_2]\n            xmin_1, ymin_1, xmax_1, ymax_1 = df_well[list_columns].iloc[\n                pos_ind_1\n            ]\n            xmin_2, ymin_2, xmax_2, ymax_2 = df_well[list_columns].iloc[\n                pos_ind_2\n            ]\n            logger.debug(\n                f\"{well=}, {iteration=}, removing overlap between\"\n                f\" {fov_id_1=} and {fov_id_2=}\"\n            )\n\n            # Check what kind of overlap is there (X, Y, or XY)\n            is_x_equal = abs(xmin_1 - xmin_2) &lt; tol and (xmax_1 - xmax_2) &lt; tol\n            is_y_equal = abs(ymin_1 - ymin_2) &lt; tol and (ymax_1 - ymax_2) &lt; tol\n            is_x_overlap = is_overlapping_1D(\n                [xmin_1, xmax_1], [xmin_2, xmax_2], tol=tol\n            )\n            is_y_overlap = is_overlapping_1D(\n                [ymin_1, ymax_1], [ymin_2, ymax_2], tol=tol\n            )\n\n            if is_x_equal and is_y_overlap:\n                # Y overlap\n                df_well = apply_shift_in_one_direction(\n                    df_well,\n                    [ymin_1, ymax_1],\n                    [ymin_2, ymax_2],\n                    mu=\"y\",\n                    tol=tol,\n                )\n            elif is_y_equal and is_x_overlap:\n                # X overlap\n                df_well = apply_shift_in_one_direction(\n                    df_well,\n                    [xmin_1, xmax_1],\n                    [xmin_2, xmax_2],\n                    mu=\"x\",\n                    tol=tol,\n                )\n            elif not (is_x_equal or is_y_equal) and (\n                is_x_overlap and is_y_overlap\n            ):\n                # XY overlap\n                df_well = apply_shift_in_one_direction(\n                    df_well,\n                    [xmin_1, xmax_1],\n                    [xmin_2, xmax_2],\n                    mu=\"x\",\n                    tol=tol,\n                )\n                df_well = apply_shift_in_one_direction(\n                    df_well,\n                    [ymin_1, ymax_1],\n                    [ymin_2, ymax_2],\n                    mu=\"y\",\n                    tol=tol,\n                )\n            else:\n                raise ValueError(\n                    \"Trying to remove overlap which is not there.\"\n                )\n\n            # Look for next overlapping FOV pair\n            pair_pos_indices = get_overlapping_pair(\n                df_well[list_columns], tol=tol\n            )\n\n            # Enforce maximum number of iterations\n            if iteration &gt;= max_iterations:\n                raise ValueError(f\"Reached {max_iterations=} for {well=}\")\n\n        # Note: using df.loc[well] = df_well leads to a NaN dataframe, see\n        # for instance https://stackoverflow.com/a/28432733/19085332\n        df.loc[well, :] = df_well.values\n\n    # Remove temporary columns that were added only as part of this function\n    df.drop(list_columns, axis=1, inplace=True)\n\n    return df\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/v1_overlaps/#fractal_tasks_core.roi.v1_overlaps.run_overlap_check","title":"<code>run_overlap_check(site_metadata, tol=1e-10, plotting_function=None)</code>","text":"<p>Run an overlap check over all wells and optionally plots overlaps.</p> <p>This function is currently only used in tests and examples.</p> <p>The <code>plotting_function</code> parameter is exposed so that other tools (see examples in this repository) may use it to show the FOV ROIs. Its arguments are: <code>[xmin, xmax, ymin, ymax, list_overlapping_FOVs, selected_well]</code>.</p> PARAMETER  DESCRIPTION <code>site_metadata</code> <p>TBD</p> <p> TYPE: <code>DataFrame</code> </p> <code>tol</code> <p>TBD</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-10</code> </p> <code>plotting_function</code> <p>TBD</p> <p> TYPE: <code>Optional[Callable]</code> DEFAULT: <code>None</code> </p> Source code in <code>fractal_tasks_core/roi/v1_overlaps.py</code> <pre><code>def run_overlap_check(\n    site_metadata: pd.DataFrame,\n    tol: float = 1e-10,\n    plotting_function: Optional[Callable] = None,\n):\n\"\"\"\n    Run an overlap check over all wells and optionally plots overlaps.\n\n    This function is currently only used in tests and examples.\n\n    The `plotting_function` parameter is exposed so that other tools (see\n    examples in this repository) may use it to show the FOV ROIs. Its arguments\n    are: `[xmin, xmax, ymin, ymax, list_overlapping_FOVs, selected_well]`.\n\n    Args:\n        site_metadata: TBD\n        tol: TBD\n        plotting_function: TBD\n    \"\"\"\n\n    if plotting_function is None:\n\n        def plotting_function(\n            xmin, xmax, ymin, ymax, list_overlapping_FOVs, selected_well\n        ):\n            pass\n\n    wells = site_metadata.index.unique(level=\"well_id\")\n    overlapping_FOVs = []\n    for selected_well in wells:\n        overlap_curr_well = check_well_for_FOV_overlap(\n            site_metadata,\n            selected_well=selected_well,\n            tol=tol,\n            plotting_function=plotting_function,\n        )\n        if overlap_curr_well:\n            print(selected_well)\n            overlapping_FOVs.append(overlap_curr_well)\n\n    return overlapping_FOVs\n</code></pre>"},{"location":"reference/fractal_tasks_core/tables/","title":"tables","text":"<p>Subpackage with functions and classes related to table specifications (see https://fractal-analytics-platform.github.io/fractal-tasks-core/tables).</p>"},{"location":"reference/fractal_tasks_core/tables/#fractal_tasks_core.tables.write_table","title":"<code>write_table(image_group, table_name, table, overwrite=False, table_type=None, table_attrs=None)</code>","text":"<p>Write a table to a Zarr group.</p> <p>This is the general interface that should allow for a smooth coexistence of tables with different <code>fractal_table_version</code> values. Currently only V1 is defined and implemented. The assumption is that V2 should only change:</p> <ol> <li>The lower-level writing function (that is, <code>_write_table_v2</code>).</li> <li>The type of the table (which would also reflect into a more general type     hint for <code>table</code>, in the current funciton);</li> <li>A different definition of what values of <code>table_attrs</code> are valid or    invalid, to be implemented in <code>_write_table_v2</code>.</li> <li>Possibly, additional parameters for <code>_write_table_v2</code>, which will be    optional parameters of <code>write_table</code> (so that <code>write_table</code> remains    valid for both V1 and V2).</li> </ol> PARAMETER  DESCRIPTION <code>image_group</code> <p>The image Zarr group where the table will be written.</p> <p> TYPE: <code>Group</code> </p> <code>table_name</code> <p>The name of the table.</p> <p> TYPE: <code>str</code> </p> <code>table</code> <p>The table object (currently an AnnData object, for V1).</p> <p> TYPE: <code>AnnData</code> </p> <code>overwrite</code> <p>If <code>False</code>, check that the new table does not exist (either as a zarr sub-group or as part of the zarr-group attributes). In all cases, propagate parameter to low-level functions, to determine the behavior in case of an existing sub-group named as in <code>table_name</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>table_type</code> <p><code>type</code> attribute for the table; in case <code>type</code> is also present in <code>table_attrs</code>, this function argument takes priority.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>table_attrs</code> <p>If set, overwrite table_group attributes with table_attrs key/value pairs. If <code>table_type</code> is not provided, then <code>table_attrs</code> must include the <code>type</code> key.</p> <p> TYPE: <code>Optional[dict[str, Any]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>group</code> <p>Zarr group of the table.</p> Source code in <code>fractal_tasks_core/tables/__init__.py</code> <pre><code>def write_table(\n    image_group: zarr.hierarchy.Group,\n    table_name: str,\n    table: ad.AnnData,\n    overwrite: bool = False,\n    table_type: Optional[str] = None,\n    table_attrs: Optional[dict[str, Any]] = None,\n) -&gt; zarr.group:\n\"\"\"\n    Write a table to a Zarr group.\n\n    This is the general interface that should allow for a smooth coexistence of\n    tables with different `fractal_table_version` values. Currently only V1 is\n    defined and implemented. The assumption is that V2 should only change:\n\n    1. The lower-level writing function (that is, `_write_table_v2`).\n    2. The type of the table (which would also reflect into a more general type\n        hint for `table`, in the current funciton);\n    3. A different definition of what values of `table_attrs` are valid or\n       invalid, to be implemented in `_write_table_v2`.\n    4. Possibly, additional parameters for `_write_table_v2`, which will be\n       optional parameters of `write_table` (so that `write_table` remains\n       valid for both V1 and V2).\n\n    Args:\n        image_group:\n            The image Zarr group where the table will be written.\n        table_name:\n            The name of the table.\n        table:\n            The table object (currently an AnnData object, for V1).\n        overwrite:\n            If `False`, check that the new table does not exist (either as a\n            zarr sub-group or as part of the zarr-group attributes). In all\n            cases, propagate parameter to low-level functions, to determine the\n            behavior in case of an existing sub-group named as in `table_name`.\n        table_type: `type` attribute for the table; in case `type` is also\n            present in `table_attrs`, this function argument takes priority.\n        table_attrs:\n            If set, overwrite table_group attributes with table_attrs key/value\n            pairs. If `table_type` is not provided, then `table_attrs` must\n            include the `type` key.\n\n    Returns:\n        Zarr group of the table.\n    \"\"\"\n    # Choose which version to use, giving priority to a value that is present\n    # in table_attrs\n    version = __FRACTAL_TABLE_VERSION__\n    if table_attrs is not None:\n        try:\n            version = table_attrs[\"fractal_table_version\"]\n        except KeyError:\n            pass\n\n    if version == \"1\":\n        return _write_table_v1(\n            image_group,\n            table_name,\n            table,\n            overwrite,\n            table_type,\n            table_attrs,\n        )\n    else:\n        raise NotImplementedError(\n            f\"fractal_table_version='{version}' is not supported\"\n        )\n</code></pre>"},{"location":"reference/fractal_tasks_core/tables/v1/","title":"v1","text":"<p>Functions and classes related to table specifications V1 (see https://fractal-analytics-platform.github.io/fractal-tasks-core/tables).</p>"},{"location":"reference/fractal_tasks_core/tables/v1/#fractal_tasks_core.tables.v1._write_elem_with_overwrite","title":"<code>_write_elem_with_overwrite(group, key, elem, *, overwrite, logger=None)</code>","text":"<p>Wrap <code>anndata.experimental.write_elem</code>, to include <code>overwrite</code> parameter.</p> <p>See docs for the original function here.</p> <p>This function writes <code>elem</code> to the sub-group <code>key</code> of <code>group</code>. The <code>overwrite</code>-related expected behavior is:</p> <ul> <li>if the sub-group does not exist, create it (independently on   <code>overwrite</code>);</li> <li>if the sub-group already exists and <code>overwrite=True</code>, overwrite the   sub-group;</li> <li>if the sub-group already exists and <code>overwrite=False</code>, fail.</li> </ul> <p>Note that this version of the wrapper does not include the original <code>dataset_kwargs</code> parameter.</p> PARAMETER  DESCRIPTION <code>group</code> <p>The group to write to.</p> <p> TYPE: <code>Group</code> </p> <code>key</code> <p>The key to write to in the group. Note that absolute paths will be written from the root.</p> <p> TYPE: <code>str</code> </p> <code>elem</code> <p>The element to write. Typically an in-memory object, e.g. an AnnData, pandas dataframe, scipy sparse matrix, etc.</p> <p> TYPE: <code>Any</code> </p> <code>overwrite</code> <p>If <code>True</code>, overwrite the <code>key</code> sub-group (if present); if <code>False</code> and <code>key</code> sub-group exists, raise an error.</p> <p> TYPE: <code>bool</code> </p> <code>logger</code> <p>The logger to use (if unset, use <code>logging.getLogger(None)</code>)</p> <p> TYPE: <code>Optional[Logger]</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>OverwriteNotAllowedError</code> <p>If <code>overwrite=False</code> and the sub-group already exists.</p> Source code in <code>fractal_tasks_core/tables/v1.py</code> <pre><code>def _write_elem_with_overwrite(\n    group: zarr.hierarchy.Group,\n    key: str,\n    elem: Any,\n    *,\n    overwrite: bool,\n    logger: Optional[logging.Logger] = None,\n) -&gt; None:\n\"\"\"\n    Wrap `anndata.experimental.write_elem`, to include `overwrite` parameter.\n\n    See docs for the original function\n    [here](https://anndata.readthedocs.io/en/stable/generated/anndata.experimental.write_elem.html).\n\n    This function writes `elem` to the sub-group `key` of `group`. The\n    `overwrite`-related expected behavior is:\n\n    * if the sub-group does not exist, create it (independently on\n      `overwrite`);\n    * if the sub-group already exists and `overwrite=True`, overwrite the\n      sub-group;\n    * if the sub-group already exists and `overwrite=False`, fail.\n\n    Note that this version of the wrapper does not include the original\n    `dataset_kwargs` parameter.\n\n    Args:\n        group:\n            The group to write to.\n        key:\n            The key to write to in the group. Note that absolute paths will be\n            written from the root.\n        elem:\n            The element to write. Typically an in-memory object, e.g. an\n            AnnData, pandas dataframe, scipy sparse matrix, etc.\n        overwrite:\n            If `True`, overwrite the `key` sub-group (if present); if `False`\n            and `key` sub-group exists, raise an error.\n        logger:\n            The logger to use (if unset, use `logging.getLogger(None)`)\n\n    Raises:\n        OverwriteNotAllowedError:\n            If `overwrite=False` and the sub-group already exists.\n    \"\"\"\n\n    # Set logger\n    if logger is None:\n        logger = logging.getLogger(None)\n\n    if key in set(group.group_keys()):\n        if not overwrite:\n            error_msg = (\n                f\"Sub-group '{key}' of group {group.store.path} \"\n                f\"already exists, but `{overwrite=}`.\\n\"\n                \"Hint: try setting `overwrite=True`.\"\n            )\n            logger.error(error_msg)\n            raise OverwriteNotAllowedError(error_msg)\n    write_elem(group, key, elem)\n</code></pre>"},{"location":"reference/fractal_tasks_core/tables/v1/#fractal_tasks_core.tables.v1._write_table_v1","title":"<code>_write_table_v1(image_group, table_name, table, overwrite=False, table_type=None, table_attrs=None)</code>","text":"<p>Handle multiple options for writing an AnnData table to a zarr group.</p> <ol> <li>Create the <code>tables</code> group, if needed.</li> <li>If <code>overwrite=False</code>, check that the new table does not exist (either in    zarr attributes or as a zarr sub-group).</li> <li>Call the <code>_write_elem_with_overwrite</code> wrapper with the appropriate    <code>overwrite</code> parameter.</li> <li>Update the <code>tables</code> attribute of the image group.</li> <li>Validate <code>table_type</code> and <code>table_attrs</code> according to Fractal table    specifications, and raise errors/warnings if needed; then set the    appropriate attributes in the new-table Zarr group.</li> </ol> PARAMETER  DESCRIPTION <code>image_group</code> <p>The group to write to.</p> <p> TYPE: <code>Group</code> </p> <code>table_name</code> <p>The name of the new table.</p> <p> TYPE: <code>str</code> </p> <code>table</code> <p>The AnnData table to write.</p> <p> TYPE: <code>AnnData</code> </p> <code>overwrite</code> <p>If <code>False</code>, check that the new table does not exist (either as a zarr sub-group or as part of the zarr-group attributes). In all cases, propagate parameter to <code>_write_elem_with_overwrite</code>, to determine the behavior in case of an existing sub-group named as <code>table_name</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>table_type</code> <p><code>type</code> attribute for the table; in case <code>type</code> is also present in <code>table_attrs</code>, this function argument takes priority.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>table_attrs</code> <p>If set, overwrite table_group attributes with table_attrs key/value pairs. If <code>table_type</code> is not provided, then <code>table_attrs</code> must include the <code>type</code> key.</p> <p> TYPE: <code>Optional[dict[str, Any]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>group</code> <p>Zarr group of the new table.</p> Source code in <code>fractal_tasks_core/tables/v1.py</code> <pre><code>def _write_table_v1(\n    image_group: zarr.hierarchy.Group,\n    table_name: str,\n    table: ad.AnnData,\n    overwrite: bool = False,\n    table_type: Optional[str] = None,\n    table_attrs: Optional[dict[str, Any]] = None,\n) -&gt; zarr.group:\n\"\"\"\n    Handle multiple options for writing an AnnData table to a zarr group.\n\n    1. Create the `tables` group, if needed.\n    2. If `overwrite=False`, check that the new table does not exist (either in\n       zarr attributes or as a zarr sub-group).\n    3. Call the `_write_elem_with_overwrite` wrapper with the appropriate\n       `overwrite` parameter.\n    4. Update the `tables` attribute of the image group.\n    5. Validate `table_type` and `table_attrs` according to Fractal table\n       specifications, and raise errors/warnings if needed; then set the\n       appropriate attributes in the new-table Zarr group.\n\n\n    Args:\n        image_group:\n            The group to write to.\n        table_name:\n            The name of the new table.\n        table:\n            The AnnData table to write.\n        overwrite:\n            If `False`, check that the new table does not exist (either as a\n            zarr sub-group or as part of the zarr-group attributes). In all\n            cases, propagate parameter to `_write_elem_with_overwrite`, to\n            determine the behavior in case of an existing sub-group named as\n            `table_name`.\n        table_type: `type` attribute for the table; in case `type` is also\n            present in `table_attrs`, this function argument takes priority.\n        table_attrs:\n            If set, overwrite table_group attributes with table_attrs key/value\n            pairs. If `table_type` is not provided, then `table_attrs` must\n            include the `type` key.\n\n    Returns:\n        Zarr group of the new table.\n    \"\"\"\n\n    # Create tables group (if needed) and extract current_tables\n    if \"tables\" not in set(image_group.group_keys()):\n        tables_group = image_group.create_group(\"tables\", overwrite=False)\n    else:\n        tables_group = image_group[\"tables\"]\n    current_tables = tables_group.attrs.asdict().get(\"tables\", [])\n\n    # If overwrite=False, check that the new table does not exist (either as a\n    # zarr sub-group or as part of the zarr-group attributes)\n    if not overwrite:\n        if table_name in set(tables_group.group_keys()):\n            error_msg = (\n                f\"Sub-group '{table_name}' of group {image_group.store.path} \"\n                f\"already exists, but `{overwrite=}`.\\n\"\n                \"Hint: try setting `overwrite=True`.\"\n            )\n            logger.error(error_msg)\n            raise OverwriteNotAllowedError(error_msg)\n        if table_name in current_tables:\n            error_msg = (\n                f\"Item '{table_name}' already exists in `tables` attribute of \"\n                f\"group {image_group.store.path}, but `{overwrite=}`.\\n\"\n                \"Hint: try setting `overwrite=True`.\"\n            )\n            logger.error(error_msg)\n            raise OverwriteNotAllowedError(error_msg)\n\n    # Always include fractal-roi-table version in table attributes\n    if table_attrs is None:\n        table_attrs = dict(fractal_table_version=\"1\")\n    elif table_attrs.get(\"fractal_table_version\", None) is None:\n        table_attrs[\"fractal_table_version\"] = \"1\"\n\n    # Set type attribute for the table\n    table_type_from_attrs = table_attrs.get(\"type\", None)\n    if table_type is not None:\n        if table_type_from_attrs is not None:\n            logger.warning(\n                f\"Setting table type to '{table_type}' (and overriding \"\n                f\"'{table_type_from_attrs}' attribute).\"\n            )\n        table_attrs[\"type\"] = table_type\n    else:\n        if table_type_from_attrs is None:\n            raise ValueError(\n                \"Missing attribute `type` for table; this must be provided\"\n                \" either via `table_type` or within `table_attrs`.\"\n            )\n\n    # Prepare/validate attributes for the table\n    table_type = table_attrs.get(\"type\", None)\n    if table_type == \"roi_table\":\n        pass\n    elif table_type == \"masking_roi_table\":\n        try:\n            MaskingROITableAttrs(**table_attrs)\n        except ValidationError as e:\n            error_msg = (\n                \"Table attributes do not comply with Fractal \"\n                \"`masking_roi_table` specifications V1.\\nOriginal error:\\n\"\n                f\"ValidationError: {str(e)}\"\n            )\n            logger.error(error_msg)\n            raise ValueError(error_msg)\n    elif table_type == \"feature_table\":\n        try:\n            FeatureTableAttrs(**table_attrs)\n        except ValidationError as e:\n            error_msg = (\n                \"Table attributes do not comply with Fractal \"\n                \"`feature_table` specifications V1.\\nOriginal error:\\n\"\n                f\"ValidationError: {str(e)}\"\n            )\n            logger.error(error_msg)\n            raise ValueError(error_msg)\n    else:\n        logger.warning(f\"Unknown table type `{table_type}`.\")\n\n    # If it's all OK, proceed and write the table\n    _write_elem_with_overwrite(\n        tables_group,\n        table_name,\n        table,\n        overwrite=overwrite,\n    )\n    table_group = tables_group[table_name]\n\n    # Update the `tables` metadata of the image group, if needed\n    if table_name not in current_tables:\n        new_tables = current_tables + [table_name]\n        tables_group.attrs[\"tables\"] = new_tables\n\n    # Update table_group attributes with table_attrs key/value pairs\n    table_group.attrs.update(**table_attrs)\n\n    return table_group\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/","title":"tasks","text":"<p>Tasks subpackage (requires installation extra <code>fractal-tasks</code>).</p>"},{"location":"reference/fractal_tasks_core/tasks/_utils/","title":"_utils","text":"<p>Standard input/output interface for tasks.</p>"},{"location":"reference/fractal_tasks_core/tasks/_utils/#fractal_tasks_core.tasks._utils.TaskParameterEncoder","title":"<code>TaskParameterEncoder</code>","text":"<p>             Bases: <code>JSONEncoder</code></p> <p>Custom JSONEncoder that transforms Path objects to strings.</p> Source code in <code>fractal_tasks_core/tasks/_utils.py</code> <pre><code>class TaskParameterEncoder(JSONEncoder):\n\"\"\"\n    Custom JSONEncoder that transforms Path objects to strings.\n    \"\"\"\n\n    def default(self, value):\n\"\"\"\n        Subclass implementation of `default`, to serialize Path objects as\n        strings.\n        \"\"\"\n        if isinstance(value, Path):\n            return value.as_posix()\n        return JSONEncoder.default(self, value)\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/_utils/#fractal_tasks_core.tasks._utils.TaskParameterEncoder.default","title":"<code>default(value)</code>","text":"<p>Subclass implementation of <code>default</code>, to serialize Path objects as strings.</p> Source code in <code>fractal_tasks_core/tasks/_utils.py</code> <pre><code>def default(self, value):\n\"\"\"\n    Subclass implementation of `default`, to serialize Path objects as\n    strings.\n    \"\"\"\n    if isinstance(value, Path):\n        return value.as_posix()\n    return JSONEncoder.default(self, value)\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/_utils/#fractal_tasks_core.tasks._utils.run_fractal_task","title":"<code>run_fractal_task(*, task_function, logger_name=None)</code>","text":"<p>Implement standard task interface and call task_function.</p> PARAMETER  DESCRIPTION <code>task_function</code> <p>the callable function that runs the task.</p> <p> TYPE: <code>Callable</code> </p> <code>logger_name</code> <p>TBD</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> Source code in <code>fractal_tasks_core/tasks/_utils.py</code> <pre><code>def run_fractal_task(\n    *,\n    task_function: Callable,\n    logger_name: Optional[str] = None,\n):\n\"\"\"\n    Implement standard task interface and call task_function.\n\n    Args:\n        task_function: the callable function that runs the task.\n        logger_name: TBD\n    \"\"\"\n\n    # Parse `-j` and `--metadata-out` arguments\n    parser = ArgumentParser()\n    parser.add_argument(\n        \"-j\", \"--json\", help=\"Read parameters from json file\", required=True\n    )\n    parser.add_argument(\n        \"--metadata-out\",\n        help=\"Output file to redirect serialised returned data\",\n        required=True,\n    )\n    args = parser.parse_args()\n\n    # Set logger\n    logger = logging.getLogger(logger_name)\n\n    # Preliminary check\n    if Path(args.metadata_out).exists():\n        logger.error(\n            f\"Output file {args.metadata_out} already exists. Terminating\"\n        )\n        exit(1)\n\n    # Read parameters dictionary\n    with open(args.json, \"r\") as f:\n        pars = json.load(f)\n\n    # Run task\n    logger.info(f\"START {task_function.__name__} task\")\n    metadata_update = task_function(**pars)\n    logger.info(f\"END {task_function.__name__} task\")\n\n    # Write output metadata to file, with custom JSON encoder\n    with open(args.metadata_out, \"w\") as fout:\n        json.dump(metadata_update, fout, cls=TaskParameterEncoder, indent=2)\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/apply_registration_to_ROI_tables/","title":"apply_registration_to_ROI_tables","text":"<p>Applies the multiplexing translation to all ROI tables</p>"},{"location":"reference/fractal_tasks_core/tasks/apply_registration_to_ROI_tables/#fractal_tasks_core.tasks.apply_registration_to_ROI_tables.add_zero_translation_columns","title":"<code>add_zero_translation_columns(ad_table)</code>","text":"<p>Add three zero-filled columns (<code>translation_{x,y,z}</code>) to an AnnData table.</p> Source code in <code>fractal_tasks_core/tasks/apply_registration_to_ROI_tables.py</code> <pre><code>def add_zero_translation_columns(ad_table: ad.AnnData):\n\"\"\"\n    Add three zero-filled columns (`translation_{x,y,z}`) to an AnnData table.\n    \"\"\"\n    columns = [\"translation_z\", \"translation_y\", \"translation_x\"]\n    if ad_table.var.index.isin(columns).any().any():\n        raise ValueError(\n            \"The roi table already contains translation columns. Did you \"\n            \"enter a wrong reference cycle?\"\n        )\n    df = pd.DataFrame(np.zeros([len(ad_table), 3]), columns=columns)\n    df.index = ad_table.obs.index\n    ad_new = ad.concat([ad_table, ad.AnnData(df)], axis=1)\n    return ad_new\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/apply_registration_to_ROI_tables/#fractal_tasks_core.tasks.apply_registration_to_ROI_tables.apply_registration_to_ROI_tables","title":"<code>apply_registration_to_ROI_tables(*, input_paths, output_path, component, metadata, roi_table='FOV_ROI_table', reference_cycle=0, new_roi_table=None)</code>","text":"<p>Applies pre-calculated registration to ROI tables.</p> <p>Apply pre-calculated registration such that resulting ROIs contain the consensus align region between all cycles.</p> <p>Parallelization level: well</p> PARAMETER  DESCRIPTION <code>input_paths</code> <p>List of input paths where the image data is stored as OME-Zarrs. Should point to the parent folder containing one or many OME-Zarr files, not the actual OME-Zarr file. Example: <code>[\"/some/path/\"]</code>. This task only supports a single input path. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>Sequence[str]</code> </p> <code>output_path</code> <p>This parameter is not used by this task. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>str</code> </p> <code>component</code> <p>Path to the OME-Zarr image in the OME-Zarr plate that is processed. Example: <code>\"some_plate.zarr/B/03/0\"</code>. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>str</code> </p> <code>metadata</code> <p>This parameter is not used by this task. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>roi_table</code> <p>Name of the ROI table over which the task loops to calculate the registration. Examples: <code>FOV_ROI_table</code> =&gt; loop over the field of views, <code>well_ROI_table</code> =&gt; process the whole well as one image.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'FOV_ROI_table'</code> </p> <code>reference_cycle</code> <p>Which cycle to register against. Defaults to 0, which is the first OME-Zarr image in the well, usually the first cycle that was provided</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>new_roi_table</code> <p>Optional name for the new, registered ROI table. If no name is given, it will default to \"registered_\" + <code>roi_table</code></p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> Source code in <code>fractal_tasks_core/tasks/apply_registration_to_ROI_tables.py</code> <pre><code>@validate_arguments\ndef apply_registration_to_ROI_tables(\n    *,\n    # Fractal arguments\n    input_paths: Sequence[str],\n    output_path: str,\n    component: str,\n    metadata: dict[str, Any],\n    # Task-specific arguments\n    roi_table: str = \"FOV_ROI_table\",\n    reference_cycle: int = 0,\n    new_roi_table: Optional[str] = None,\n) -&gt; dict[str, Any]:\n\"\"\"\n    Applies pre-calculated registration to ROI tables.\n\n    Apply pre-calculated registration such that resulting ROIs contain\n    the consensus align region between all cycles.\n\n    Parallelization level: well\n\n    Args:\n        input_paths: List of input paths where the image data is stored as\n            OME-Zarrs. Should point to the parent folder containing one or many\n            OME-Zarr files, not the actual OME-Zarr file. Example:\n            `[\"/some/path/\"]`. This task only supports a single input path.\n            (standard argument for Fractal tasks, managed by Fractal server).\n        output_path: This parameter is not used by this task.\n            (standard argument for Fractal tasks, managed by Fractal server).\n        component: Path to the OME-Zarr image in the OME-Zarr plate that is\n            processed. Example: `\"some_plate.zarr/B/03/0\"`.\n            (standard argument for Fractal tasks, managed by Fractal server).\n        metadata: This parameter is not used by this task.\n            (standard argument for Fractal tasks, managed by Fractal server).\n        roi_table: Name of the ROI table over which the task loops to\n            calculate the registration. Examples: `FOV_ROI_table` =&gt; loop over\n            the field of views, `well_ROI_table` =&gt; process the whole well as\n            one image.\n        reference_cycle: Which cycle to register against. Defaults to 0,\n            which is the first OME-Zarr image in the well, usually the first\n            cycle that was provided\n        new_roi_table: Optional name for the new, registered ROI table. If no\n            name is given, it will default to \"registered_\" + `roi_table`\n\n    \"\"\"\n    if not new_roi_table:\n        new_roi_table = \"registered_\" + roi_table\n    logger.info(\n        f\"Running for {input_paths=}, {component=}. \\n\"\n        f\"Applyg translation registration to {roi_table=} and storing it as \"\n        f\"{new_roi_table=}.\"\n    )\n\n    well_zarr = f\"{input_paths[0]}/{component}\"\n    ngff_well_meta = load_NgffWellMeta(well_zarr)\n    acquisition_dict = ngff_well_meta.get_acquisition_paths()\n    logger.info(\n        \"Calculating common registration for the following cycles: \"\n        f\"{acquisition_dict}\"\n    )\n\n    # TODO: Allow a filter on which acquisitions should get processed?\n\n    # Collect all the ROI tables\n    roi_tables = {}\n    roi_tables_attrs = {}\n    for acq in acquisition_dict.keys():\n        acq_path = acquisition_dict[acq]\n        curr_ROI_table = ad.read_zarr(\n            f\"{well_zarr}/{acq_path}/tables/{roi_table}\"\n        )\n        curr_ROI_table_group = zarr.open_group(\n            f\"{well_zarr}/{acq_path}/tables/{roi_table}\", mode=\"r\"\n        )\n        curr_ROI_table_attrs = curr_ROI_table_group.attrs.asdict()\n\n        # For reference_cycle acquisition, handle the fact that it doesn't\n        # have the shifts\n        if acq == reference_cycle:\n            curr_ROI_table = add_zero_translation_columns(curr_ROI_table)\n        # Check for valid ROI tables\n        are_ROI_table_columns_valid(table=curr_ROI_table)\n        translation_columns = [\n            \"translation_z\",\n            \"translation_y\",\n            \"translation_x\",\n        ]\n        if curr_ROI_table.var.index.isin(translation_columns).sum() != 3:\n            raise ValueError(\n                f\"Cycle {acq}'s {roi_table} does not contain the \"\n                f\"translation columns {translation_columns} necessary to use \"\n                \"this task.\"\n            )\n        roi_tables[acq] = curr_ROI_table\n        roi_tables_attrs[acq] = curr_ROI_table_attrs\n\n    # Check that all acquisitions have the same ROIs\n    rois = roi_tables[reference_cycle].obs.index\n    for acq, acq_roi_table in roi_tables.items():\n        if not (acq_roi_table.obs.index == rois).all():\n            raise ValueError(\n                f\"Acquisition {acq} does not contain the same ROIs as the \"\n                f\"reference acquisition {reference_cycle}:\\n\"\n                f\"{acq}: {acq_roi_table.obs.index}\\n\"\n                f\"{reference_cycle}: {rois}\"\n            )\n\n    roi_table_dfs = [\n        roi_table.to_df().loc[:, translation_columns]\n        for roi_table in roi_tables.values()\n    ]\n    logger.info(\"Calculating min &amp; max translation across cycles.\")\n    max_df, min_df = calculate_min_max_across_dfs(roi_table_dfs)\n    shifted_rois = {}\n    # Loop over acquisitions\n    for acq in acquisition_dict.keys():\n        shifted_rois[acq] = apply_registration_to_single_ROI_table(\n            roi_tables[acq], max_df, min_df\n        )\n\n        # TODO: Drop translation columns from this table?\n\n        logger.info(\n            f\"Write the registered ROI table {new_roi_table} for {acq=}\"\n        )\n        # Save the shifted ROI table as a new table\n        image_group = zarr.group(f\"{well_zarr}/{acq}\")\n        write_table(\n            image_group,\n            new_roi_table,\n            shifted_rois[acq],\n            table_attrs=roi_tables_attrs[acq],\n        )\n\n    # TODO: Optionally apply registration to other tables as well?\n    # e.g. to well_ROI_table based on FOV_ROI_table\n    # =&gt; out of scope for the initial task, apply registration separately\n    # to each table\n    # Easiest implementation: Apply average shift calculcated here to other\n    # ROIs. From many to 1 (e.g. FOV =&gt; well) =&gt; average shift, but crop len\n    # From well to many (e.g. well to FOVs) =&gt; average shift, crop len by that\n    # amount\n    # Many to many (FOVs to organoids) =&gt; tricky because of matching\n\n    return {}\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/apply_registration_to_ROI_tables/#fractal_tasks_core.tasks.apply_registration_to_ROI_tables.apply_registration_to_single_ROI_table","title":"<code>apply_registration_to_single_ROI_table(roi_table, max_df, min_df)</code>","text":"<p>Applies the registration to a ROI table</p> <p>Calculates the new position as: p = position + max(shift, 0) - own_shift Calculates the new len as: l = len - max(shift, 0) + min(shift, 0)</p> PARAMETER  DESCRIPTION <code>roi_table</code> <p>AnnData table which contains a Fractal ROI table. Rows are ROIs</p> <p> TYPE: <code>AnnData</code> </p> <code>max_df</code> <p>Max translation shift in z, y, x for each ROI. Rows are ROIs, columns are translation_z, translation_y, translation_x</p> <p> TYPE: <code>DataFrame</code> </p> <code>min_df</code> <p>Min translation shift in z, y, x for each ROI. Rows are ROIs, columns are translation_z, translation_y, translation_x</p> <p> TYPE: <code>DataFrame</code> </p> <p>Returns:     ROI table where all ROIs are registered to the smallest common area     across all cycles.</p> Source code in <code>fractal_tasks_core/tasks/apply_registration_to_ROI_tables.py</code> <pre><code>def apply_registration_to_single_ROI_table(\n    roi_table: ad.AnnData,\n    max_df: pd.DataFrame,\n    min_df: pd.DataFrame,\n) -&gt; ad.AnnData:\n\"\"\"\n    Applies the registration to a ROI table\n\n    Calculates the new position as: p = position + max(shift, 0) - own_shift\n    Calculates the new len as: l = len - max(shift, 0) + min(shift, 0)\n\n    Args:\n        roi_table: AnnData table which contains a Fractal ROI table.\n            Rows are ROIs\n        max_df: Max translation shift in z, y, x for each ROI. Rows are ROIs,\n            columns are translation_z, translation_y, translation_x\n        min_df: Min translation shift in z, y, x for each ROI. Rows are ROIs,\n            columns are translation_z, translation_y, translation_x\n    Returns:\n        ROI table where all ROIs are registered to the smallest common area\n        across all cycles.\n    \"\"\"\n    roi_table = copy.deepcopy(roi_table)\n    rois = roi_table.obs.index\n    if (rois != max_df.index).all() or (rois != min_df.index).all():\n        raise ValueError(\n            \"ROI table and max &amp; min translation need to contain the same \"\n            f\"ROIS, but they were {rois=}, {max_df.index=}, {min_df.index=}\"\n        )\n\n    for roi in rois:\n        roi_table[[roi], [\"z_micrometer\"]] = (\n            roi_table[[roi], [\"z_micrometer\"]].X\n            + float(max_df.loc[roi, \"translation_z\"])\n            - roi_table[[roi], [\"translation_z\"]].X\n        )\n        roi_table[[roi], [\"y_micrometer\"]] = (\n            roi_table[[roi], [\"y_micrometer\"]].X\n            + float(max_df.loc[roi, \"translation_y\"])\n            - roi_table[[roi], [\"translation_y\"]].X\n        )\n        roi_table[[roi], [\"x_micrometer\"]] = (\n            roi_table[[roi], [\"x_micrometer\"]].X\n            + float(max_df.loc[roi, \"translation_x\"])\n            - roi_table[[roi], [\"translation_x\"]].X\n        )\n        # This calculation only works if all ROIs are the same size initially!\n        roi_table[[roi], [\"len_z_micrometer\"]] = (\n            roi_table[[roi], [\"len_z_micrometer\"]].X\n            - float(max_df.loc[roi, \"translation_z\"])\n            + float(min_df.loc[roi, \"translation_z\"])\n        )\n        roi_table[[roi], [\"len_y_micrometer\"]] = (\n            roi_table[[roi], [\"len_y_micrometer\"]].X\n            - float(max_df.loc[roi, \"translation_y\"])\n            + float(min_df.loc[roi, \"translation_y\"])\n        )\n        roi_table[[roi], [\"len_x_micrometer\"]] = (\n            roi_table[[roi], [\"len_x_micrometer\"]].X\n            - float(max_df.loc[roi, \"translation_x\"])\n            + float(min_df.loc[roi, \"translation_x\"])\n        )\n    return roi_table\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/apply_registration_to_image/","title":"apply_registration_to_image","text":"<p>Calculates translation for 2D image-based registration</p>"},{"location":"reference/fractal_tasks_core/tasks/apply_registration_to_image/#fractal_tasks_core.tasks.apply_registration_to_image.apply_registration_to_image","title":"<code>apply_registration_to_image(*, input_paths, output_path, component, metadata, registered_roi_table, reference_cycle='0', overwrite_input=True)</code>","text":"<p>Apply registration to images by using a registered ROI table</p> <p>This task consists of 4 parts:</p> <ol> <li>Mask all regions in images that are not available in the registered ROI table and store each cycle aligned to the reference_cycle (by looping over ROIs).</li> <li>Do the same for all label images.</li> <li>Copy all tables from the non-aligned image to the aligned image (currently only works well if the only tables are well &amp; FOV ROI tables (registered and original). Not implemented for measurement tables and other ROI tables).</li> <li>Clean up: Delete the old, non-aligned image and rename the new, aligned image to take over its place.</li> </ol> <p>Parallelization level: image</p> PARAMETER  DESCRIPTION <code>input_paths</code> <p>List of input paths where the image data is stored as OME-Zarrs. Should point to the parent folder containing one or many OME-Zarr files, not the actual OME-Zarr file. Example: <code>[\"/some/path/\"]</code>. This task only supports a single input path. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>Sequence[str]</code> </p> <code>output_path</code> <p>This parameter is not used by this task. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>str</code> </p> <code>component</code> <p>Path to the OME-Zarr image in the OME-Zarr plate that is processed. Example: <code>\"some_plate.zarr/B/03/0\"</code>. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>str</code> </p> <code>metadata</code> <p>This parameter is not used by this task. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>registered_roi_table</code> <p>Name of the ROI table which has been registered and will be applied to mask and shift the images. Examples: <code>registered_FOV_ROI_table</code> =&gt; loop over the field of views, <code>registered_well_ROI_table</code> =&gt; process the whole well as one image.</p> <p> TYPE: <code>str</code> </p> <code>reference_cycle</code> <p>Which cycle to register against. Defaults to 0, which is the first OME-Zarr image in the well, usually the first cycle that was provided</p> <p> TYPE: <code>str</code> DEFAULT: <code>'0'</code> </p> <code>overwrite_input</code> <p>Whether the old image data should be replaced with the newly registered image data. Currently only implemented for <code>overwrite_input=True</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>fractal_tasks_core/tasks/apply_registration_to_image.py</code> <pre><code>@validate_arguments\ndef apply_registration_to_image(\n    *,\n    # Fractal arguments\n    input_paths: Sequence[str],\n    output_path: str,\n    component: str,\n    metadata: dict[str, Any],\n    # Task-specific arguments\n    registered_roi_table: str,\n    reference_cycle: str = \"0\",\n    overwrite_input: bool = True,\n):\n\"\"\"\n    Apply registration to images by using a registered ROI table\n\n    This task consists of 4 parts:\n\n    1. Mask all regions in images that are not available in the\n    registered ROI table and store each cycle aligned to the\n    reference_cycle (by looping over ROIs).\n    2. Do the same for all label images.\n    3. Copy all tables from the non-aligned image to the aligned image\n    (currently only works well if the only tables are well &amp; FOV ROI tables\n    (registered and original). Not implemented for measurement tables and\n    other ROI tables).\n    4. Clean up: Delete the old, non-aligned image and rename the new,\n    aligned image to take over its place.\n\n    Parallelization level: image\n\n    Args:\n        input_paths: List of input paths where the image data is stored as\n            OME-Zarrs. Should point to the parent folder containing one or many\n            OME-Zarr files, not the actual OME-Zarr file. Example:\n            `[\"/some/path/\"]`. This task only supports a single input path.\n            (standard argument for Fractal tasks, managed by Fractal server).\n        output_path: This parameter is not used by this task.\n            (standard argument for Fractal tasks, managed by Fractal server).\n        component: Path to the OME-Zarr image in the OME-Zarr plate that is\n            processed. Example: `\"some_plate.zarr/B/03/0\"`.\n            (standard argument for Fractal tasks, managed by Fractal server).\n        metadata: This parameter is not used by this task.\n            (standard argument for Fractal tasks, managed by Fractal server).\n        registered_roi_table: Name of the ROI table which has been registered\n            and will be applied to mask and shift the images.\n            Examples: `registered_FOV_ROI_table` =&gt; loop over the field of\n            views, `registered_well_ROI_table` =&gt; process the whole well as\n            one image.\n        reference_cycle: Which cycle to register against. Defaults to 0,\n            which is the first OME-Zarr image in the well, usually the first\n            cycle that was provided\n        overwrite_input: Whether the old image data should be replaced with the\n            newly registered image data. Currently only implemented for\n            `overwrite_input=True`.\n\n    \"\"\"\n    logger.info(component)\n    if not overwrite_input:\n        raise NotImplementedError(\n            \"This task is only implemented for the overwrite_input version\"\n        )\n    logger.info(\n        f\"Running `apply_registration_to_image` on {input_paths=}, \"\n        f\"{component=}, {registered_roi_table=} and {reference_cycle=}. \"\n        f\"Using {overwrite_input=}\"\n    )\n\n    input_path = Path(input_paths[0])\n    new_component = \"/\".join(\n        component.split(\"/\")[:-1] + [component.split(\"/\")[-1] + \"_registered\"]\n    )\n    reference_component = \"/\".join(\n        component.split(\"/\")[:-1] + [reference_cycle]\n    )\n\n    ROI_table_ref = ad.read_zarr(\n        f\"{input_path / reference_component}/tables/{registered_roi_table}\"\n    )\n    ROI_table_cycle = ad.read_zarr(\n        f\"{input_path / component}/tables/{registered_roi_table}\"\n    )\n\n    ngff_image_meta = load_NgffImageMeta(str(input_path / component))\n    coarsening_xy = ngff_image_meta.coarsening_xy\n    num_levels = ngff_image_meta.num_levels\n\n    ####################\n    # Process images\n    ####################\n    logger.info(\"Write the registered Zarr image to disk\")\n    write_registered_zarr(\n        input_path=input_path,\n        component=component,\n        new_component=new_component,\n        ROI_table=ROI_table_cycle,\n        ROI_table_ref=ROI_table_ref,\n        num_levels=num_levels,\n        coarsening_xy=coarsening_xy,\n        aggregation_function=np.mean,\n    )\n\n    ####################\n    # Process labels\n    ####################\n    try:\n        labels_group = zarr.open_group(f\"{input_path / component}/labels\", \"r\")\n        label_list = labels_group.attrs[\"labels\"]\n    except (zarr.errors.GroupNotFoundError, KeyError):\n        label_list = []\n\n    if label_list:\n        logger.info(f\"Processing the label images: {label_list}\")\n        labels_group = zarr.group(f\"{input_path / new_component}/labels\")\n        labels_group.attrs[\"labels\"] = label_list\n\n        for label in label_list:\n            label_component = f\"{component}/labels/{label}\"\n            label_component_new = f\"{new_component}/labels/{label}\"\n            write_registered_zarr(\n                input_path=input_path,\n                component=label_component,\n                new_component=label_component_new,\n                ROI_table=ROI_table_cycle,\n                ROI_table_ref=ROI_table_ref,\n                num_levels=num_levels,\n                coarsening_xy=coarsening_xy,\n                aggregation_function=np.max,\n            )\n\n    ####################\n    # Copy tables\n    # 1. Copy all standard ROI tables from cycle 0.\n    # 2. Copy all tables that aren't standard ROI tables from the given cycle\n    ####################\n    table_dict_reference = get_table_path_dict(input_path, reference_component)\n    table_dict_component = get_table_path_dict(input_path, component)\n\n    table_dict = {}\n    # Define which table should get copied:\n    for table in table_dict_reference:\n        if is_standard_roi_table(table):\n            table_dict[table] = table_dict_reference[table]\n    for table in table_dict_component:\n        if not is_standard_roi_table(table):\n            if reference_component != component:\n                logger.warning(\n                    f\"{component} contained a table that is not a standard \"\n                    \"ROI table. The `Apply Registration To Image task` is \"\n                    \"best used before additional tables are generated. It \"\n                    f\"will copy the {table} from this cycle without applying \"\n                    f\"any transformations. This will work well if {table} \"\n                    f\"contains measurements. But if {table} is a custom ROI \"\n                    \"table coming from another task, the transformation is \"\n                    \"not applied and it will not match with the registered \"\n                    \"image anymore\"\n                )\n            table_dict[table] = table_dict_component[table]\n\n    if table_dict:\n        logger.info(f\"Processing the tables: {table_dict}\")\n        new_image_group = zarr.group(f\"{input_path / new_component}\")\n\n        for table in table_dict.keys():\n            logger.info(f\"Copying table: {table}\")\n            # Get the relevant metadata of the Zarr table &amp; add it\n            # See issue #516 for the need for this workaround\n            max_retries = 20\n            sleep_time = 5\n            current_round = 0\n            while current_round &lt; max_retries:\n                try:\n                    old_table_group = zarr.open_group(\n                        table_dict[table], mode=\"r\"\n                    )\n                    current_round = max_retries\n                except zarr.errors.GroupNotFoundError:\n                    logger.debug(\n                        f\"Table {table} not found in attempt {current_round}. \"\n                        f\"Waiting {sleep_time} seconds before trying again.\"\n                    )\n                    current_round += 1\n                    time.sleep(sleep_time)\n            # Write the Zarr table\n            curr_table = ad.read_zarr(table_dict[table])\n            write_table(\n                new_image_group,\n                table,\n                curr_table,\n                table_attrs=old_table_group.attrs.asdict(),\n            )\n\n    ####################\n    # Clean up Zarr file\n    ####################\n    if overwrite_input:\n        logger.info(\n            \"Replace original zarr image with the newly created Zarr image\"\n        )\n        # Potential for race conditions: Every cycle reads the\n        # reference cycle, but the reference cycle also gets modified\n        # See issue #516 for the details\n        os.rename(f\"{input_path / component}\", f\"{input_path / component}_tmp\")\n        os.rename(f\"{input_path / new_component}\", f\"{input_path / component}\")\n        shutil.rmtree(f\"{input_path / component}_tmp\")\n    else:\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/apply_registration_to_image/#fractal_tasks_core.tasks.apply_registration_to_image.write_registered_zarr","title":"<code>write_registered_zarr(input_path, component, new_component, ROI_table, ROI_table_ref, num_levels, coarsening_xy=2, aggregation_function=np.mean)</code>","text":"<p>Write registered zarr array based on ROI tables</p> <p>This function loads the image or label data from a zarr array based on the ROI bounding-box coordinates and stores them into a new zarr array. The new Zarr array has the same shape as the original array, but will have 0s where the ROI tables don't specify loading of the image data. The ROIs loaded from <code>list_indices</code> will be written into the <code>list_indices_ref</code> position, thus performing translational registration if the two lists of ROI indices vary.</p> PARAMETER  DESCRIPTION <code>input_path</code> <p>Base folder where the Zarr is stored (does not contain the Zarr file itself)</p> <p> TYPE: <code>Path</code> </p> <code>component</code> <p>Path to the OME-Zarr image that is processed. For example: <code>\"20200812-CardiomyocyteDifferentiation14-Cycle1_mip.zarr/B/03/1\"</code></p> <p> TYPE: <code>str</code> </p> <code>new_component</code> <p>Path to the new Zarr image that will be written (also in the input_path folder). For example: <code>\"20200812-CardiomyocyteDifferentiation14-Cycle1_mip.zarr/B/03/1_registered\"</code></p> <p> TYPE: <code>str</code> </p> <code>ROI_table</code> <p>Fractal ROI table for the component</p> <p> TYPE: <code>AnnData</code> </p> <code>ROI_table_ref</code> <p>Fractal ROI table for the reference cycle</p> <p> TYPE: <code>AnnData</code> </p> <code>num_levels</code> <p>Number of pyramid layers to be created (argument of <code>build_pyramid</code>).</p> <p> TYPE: <code>int</code> </p> <code>coarsening_xy</code> <p>Coarsening factor between pyramid levels</p> <p> TYPE: <code>int</code> DEFAULT: <code>2</code> </p> <code>aggregation_function</code> <p>Function to be used when downsampling (argument of <code>build_pyramid</code>).</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>mean</code> </p> Source code in <code>fractal_tasks_core/tasks/apply_registration_to_image.py</code> <pre><code>def write_registered_zarr(\n    input_path: Path,\n    component: str,\n    new_component: str,\n    ROI_table: ad.AnnData,\n    ROI_table_ref: ad.AnnData,\n    num_levels: int,\n    coarsening_xy: int = 2,\n    aggregation_function: Callable = np.mean,\n):\n\"\"\"\n    Write registered zarr array based on ROI tables\n\n    This function loads the image or label data from a zarr array based on the\n    ROI bounding-box coordinates and stores them into a new zarr array.\n    The new Zarr array has the same shape as the original array, but will have\n    0s where the ROI tables don't specify loading of the image data.\n    The ROIs loaded from `list_indices` will be written into the\n    `list_indices_ref` position, thus performing translational registration if\n    the two lists of ROI indices vary.\n\n    Args:\n        input_path: Base folder where the Zarr is stored\n            (does not contain the Zarr file itself)\n        component: Path to the OME-Zarr image that is processed. For example:\n            `\"20200812-CardiomyocyteDifferentiation14-Cycle1_mip.zarr/B/03/1\"`\n        new_component: Path to the new Zarr image that will be written\n            (also in the input_path folder). For example:\n            `\"20200812-CardiomyocyteDifferentiation14-Cycle1_mip.zarr/B/03/1_registered\"`\n        ROI_table: Fractal ROI table for the component\n        ROI_table_ref: Fractal ROI table for the reference cycle\n        num_levels: Number of pyramid layers to be created (argument of\n            `build_pyramid`).\n        coarsening_xy: Coarsening factor between pyramid levels\n        aggregation_function: Function to be used when downsampling (argument\n            of `build_pyramid`).\n\n    \"\"\"\n    # Read pixel sizes from Zarr attributes\n    ngff_image_meta = load_NgffImageMeta(str(input_path / component))\n    pxl_sizes_zyx = ngff_image_meta.get_pixel_sizes_zyx(level=0)\n\n    # Create list of indices for 3D ROIs\n    list_indices = convert_ROI_table_to_indices(\n        ROI_table,\n        level=0,\n        coarsening_xy=coarsening_xy,\n        full_res_pxl_sizes_zyx=pxl_sizes_zyx,\n    )\n    list_indices_ref = convert_ROI_table_to_indices(\n        ROI_table_ref,\n        level=0,\n        coarsening_xy=coarsening_xy,\n        full_res_pxl_sizes_zyx=pxl_sizes_zyx,\n    )\n\n    old_image_group = zarr.open_group(f\"{input_path / component}\", mode=\"r\")\n    old_ngff_image_meta = load_NgffImageMeta(str(input_path / component))\n    new_image_group = zarr.group(f\"{input_path / new_component}\")\n    new_image_group.attrs.put(old_image_group.attrs.asdict())\n\n    # Loop over all channels. For each channel, write full-res image data.\n    data_array = da.from_zarr(old_image_group[\"0\"])\n    # Create dask array with 0s of same shape\n    new_array = da.zeros_like(data_array)\n\n    # TODO: Add sanity checks on the 2 ROI tables:\n    # 1. The number of ROIs need to match\n    # 2. The size of the ROIs need to match\n    # (otherwise, we can't assign them to the reference regions)\n    # ROI_table_ref vs ROI_table_cycle\n    for i, roi_indices in enumerate(list_indices):\n        reference_region = convert_indices_to_regions(list_indices_ref[i])\n        region = convert_indices_to_regions(roi_indices)\n\n        axes_list = old_ngff_image_meta.axes_names\n\n        if axes_list == [\"c\", \"z\", \"y\", \"x\"]:\n            num_channels = data_array.shape[0]\n            # Loop over channels\n            for ind_ch in range(num_channels):\n                idx = tuple(\n                    [slice(ind_ch, ind_ch + 1)] + list(reference_region)\n                )\n                new_array[idx] = load_region(\n                    data_zyx=data_array[ind_ch], region=region, compute=False\n                )\n        elif axes_list == [\"z\", \"y\", \"x\"]:\n            new_array[reference_region] = load_region(\n                data_zyx=data_array, region=region, compute=False\n            )\n        elif axes_list == [\"c\", \"y\", \"x\"]:\n            # TODO: Implement cyx case (based on looping over xy case)\n            raise NotImplementedError(\n                \"`write_registered_zarr` has not been implemented for \"\n                f\"a zarr with {axes_list=}\"\n            )\n        elif axes_list == [\"y\", \"x\"]:\n            # TODO: Implement yx case\n            raise NotImplementedError(\n                \"`write_registered_zarr` has not been implemented for \"\n                f\"a zarr with {axes_list=}\"\n            )\n        else:\n            raise NotImplementedError(\n                \"`write_registered_zarr` has not been implemented for \"\n                f\"a zarr with {axes_list=}\"\n            )\n\n    new_array.to_zarr(\n        f\"{input_path / new_component}/0\",\n        overwrite=True,\n        dimension_separator=\"/\",\n        write_empty_chunks=False,\n    )\n\n    # Starting from on-disk highest-resolution data, build and write to\n    # disk a pyramid of coarser levels\n    build_pyramid(\n        zarrurl=f\"{input_path / new_component}\",\n        overwrite=True,\n        num_levels=num_levels,\n        coarsening_xy=coarsening_xy,\n        chunksize=data_array.chunksize,\n        aggregation_function=aggregation_function,\n    )\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/calculate_registration_image_based/","title":"calculate_registration_image_based","text":"<p>Calculates translation for image-based registration</p>"},{"location":"reference/fractal_tasks_core/tasks/calculate_registration_image_based/#fractal_tasks_core.tasks.calculate_registration_image_based.calculate_physical_shifts","title":"<code>calculate_physical_shifts(shifts, level, coarsening_xy, full_res_pxl_sizes_zyx)</code>","text":"<p>Calculates shifts in physical units based on pixel shifts</p> PARAMETER  DESCRIPTION <code>shifts</code> <p>array of shifts, zyx or yx</p> <p> TYPE: <code>array</code> </p> <code>level</code> <p>resolution level</p> <p> TYPE: <code>int</code> </p> <code>coarsening_xy</code> <p>coarsening factor between levels</p> <p> TYPE: <code>int</code> </p> <code>full_res_pxl_sizes_zyx</code> <p>pixel sizes in physical units as zyx</p> <p> TYPE: <code>list[float]</code> </p> RETURNS DESCRIPTION <code>shifts_physical</code> <p>shifts in physical units as zyx</p> <p> TYPE: <code>list[float]</code> </p> Source code in <code>fractal_tasks_core/tasks/calculate_registration_image_based.py</code> <pre><code>def calculate_physical_shifts(\n    shifts: np.array,\n    level: int,\n    coarsening_xy: int,\n    full_res_pxl_sizes_zyx: list[float],\n) -&gt; list[float]:\n\"\"\"\n    Calculates shifts in physical units based on pixel shifts\n\n    Args:\n        shifts: array of shifts, zyx or yx\n        level: resolution level\n        coarsening_xy: coarsening factor between levels\n        full_res_pxl_sizes_zyx: pixel sizes in physical units as zyx\n\n    Returns:\n        shifts_physical: shifts in physical units as zyx\n    \"\"\"\n\n    curr_pixel_size = np.array(full_res_pxl_sizes_zyx) * coarsening_xy**level\n    if len(shifts) == 3:\n        shifts_physical = shifts * curr_pixel_size\n    elif len(shifts) == 2:\n        shifts_physical = [\n            0,\n            shifts[0] * curr_pixel_size[1],\n            shifts[1] * curr_pixel_size[2],\n        ]\n    else:\n        raise ValueError(\n            f\"Wrong input for calculate_physical_shifts ({shifts=})\"\n        )\n    return shifts_physical\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/calculate_registration_image_based/#fractal_tasks_core.tasks.calculate_registration_image_based.calculate_registration_image_based","title":"<code>calculate_registration_image_based(*, input_paths, output_path, component, metadata, wavelength_id, roi_table='FOV_ROI_table', reference_cycle=0, level=2)</code>","text":"<p>Calculate registration based on images</p> <p>This task consists of 3 parts:</p> <ol> <li>Loading the images of a given ROI (=&gt; loop over ROIs)</li> <li>Calculating the transformation for that ROI</li> <li>Storing the calculated transformation in the ROI table</li> </ol> <p>Parallelization level: image</p> PARAMETER  DESCRIPTION <code>input_paths</code> <p>List of input paths where the image data is stored as OME-Zarrs. Should point to the parent folder containing one or many OME-Zarr files, not the actual OME-Zarr file. Example: <code>[\"/some/path/\"]</code>. This task only supports a single input path. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>Sequence[str]</code> </p> <code>output_path</code> <p>This parameter is not used by this task. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>str</code> </p> <code>component</code> <p>Path to the OME-Zarr image in the OME-Zarr plate that is processed. Example: <code>\"some_plate.zarr/B/03/0\"</code>. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>str</code> </p> <code>metadata</code> <p>This parameter is not used by this task. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>wavelength_id</code> <p>Wavelength that will be used for image-based registration; e.g. <code>A01_C01</code> for Yokogawa, <code>C01</code> for MD.</p> <p> TYPE: <code>str</code> </p> <code>roi_table</code> <p>Name of the ROI table over which the task loops to calculate the registration. Examples: <code>FOV_ROI_table</code> =&gt; loop over the field of views, <code>well_ROI_table</code> =&gt; process the whole well as one image.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'FOV_ROI_table'</code> </p> <code>reference_cycle</code> <p>Which cycle to register against. Defaults to 0, which is the first OME-Zarr image in the well (usually the first cycle that was provided).</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>level</code> <p>Pyramid level of the image to be segmented. Choose <code>0</code> to process at full resolution.</p> <p> TYPE: <code>int</code> DEFAULT: <code>2</code> </p> Source code in <code>fractal_tasks_core/tasks/calculate_registration_image_based.py</code> <pre><code>@validate_arguments\ndef calculate_registration_image_based(\n    *,\n    # Fractal arguments\n    input_paths: Sequence[str],\n    output_path: str,\n    component: str,\n    metadata: dict[str, Any],\n    # Task-specific arguments\n    wavelength_id: str,\n    roi_table: str = \"FOV_ROI_table\",\n    reference_cycle: int = 0,\n    level: int = 2,\n) -&gt; dict[str, Any]:\n\"\"\"\n    Calculate registration based on images\n\n    This task consists of 3 parts:\n\n    1. Loading the images of a given ROI (=&gt; loop over ROIs)\n    2. Calculating the transformation for that ROI\n    3. Storing the calculated transformation in the ROI table\n\n    Parallelization level: image\n\n    Args:\n        input_paths: List of input paths where the image data is stored as\n            OME-Zarrs. Should point to the parent folder containing one or many\n            OME-Zarr files, not the actual OME-Zarr file. Example:\n            `[\"/some/path/\"]`. This task only supports a single input path.\n            (standard argument for Fractal tasks, managed by Fractal server).\n        output_path: This parameter is not used by this task.\n            (standard argument for Fractal tasks, managed by Fractal server).\n        component: Path to the OME-Zarr image in the OME-Zarr plate that is\n            processed. Example: `\"some_plate.zarr/B/03/0\"`.\n            (standard argument for Fractal tasks, managed by Fractal server).\n        metadata: This parameter is not used by this task.\n            (standard argument for Fractal tasks, managed by Fractal server).\n        wavelength_id: Wavelength that will be used for image-based\n            registration; e.g. `A01_C01` for Yokogawa, `C01` for MD.\n        roi_table: Name of the ROI table over which the task loops to\n            calculate the registration. Examples: `FOV_ROI_table` =&gt; loop over\n            the field of views, `well_ROI_table` =&gt; process the whole well as\n            one image.\n        reference_cycle: Which cycle to register against. Defaults to 0,\n            which is the first OME-Zarr image in the well (usually the first\n            cycle that was provided).\n        level: Pyramid level of the image to be segmented. Choose `0` to\n            process at full resolution.\n\n    \"\"\"\n    logger.info(\n        f\"Running for {input_paths=}, {component=}. \\n\"\n        f\"Calculating translation registration per {roi_table=} for \"\n        f\"{wavelength_id=}.\"\n    )\n    # Set OME-Zarr paths\n    zarr_img_cycle_x = Path(input_paths[0]) / component\n\n    # If the task is run for the reference cycle, exit\n    # TODO: Improve the input for this: Can we filter components to not\n    # run for itself?\n    alignment_cycle = zarr_img_cycle_x.name\n    if alignment_cycle == str(reference_cycle):\n        logger.info(\n            \"Calculate registration image-based is running for \"\n            f\"cycle {alignment_cycle}, which is the reference_cycle.\"\n            \"Thus, exiting the task.\"\n        )\n        return {}\n    else:\n        logger.info(\n            \"Calculate registration image-based is running for \"\n            f\"cycle {alignment_cycle}\"\n        )\n\n    zarr_img_ref_cycle = zarr_img_cycle_x.parent / str(reference_cycle)\n\n    # Read some parameters from Zarr metadata\n    ngff_image_meta = load_NgffImageMeta(str(zarr_img_ref_cycle))\n    coarsening_xy = ngff_image_meta.coarsening_xy\n\n    # Get channel_index via wavelength_id.\n    # Intially only allow registration of the same wavelength\n    channel_ref: OmeroChannel = get_channel_from_image_zarr(\n        image_zarr_path=str(zarr_img_ref_cycle),\n        wavelength_id=wavelength_id,\n    )\n    channel_index_ref = channel_ref.index\n\n    channel_align: OmeroChannel = get_channel_from_image_zarr(\n        image_zarr_path=str(zarr_img_cycle_x),\n        wavelength_id=wavelength_id,\n    )\n    channel_index_align = channel_align.index\n\n    # Lazily load zarr array\n    data_reference_zyx = da.from_zarr(f\"{zarr_img_ref_cycle}/{level}\")[\n        channel_index_ref\n    ]\n    data_alignment_zyx = da.from_zarr(f\"{zarr_img_cycle_x}/{level}\")[\n        channel_index_align\n    ]\n\n    # Read ROIs\n    ROI_table_ref = ad.read_zarr(f\"{zarr_img_ref_cycle}/tables/{roi_table}\")\n    ROI_table_x = ad.read_zarr(f\"{zarr_img_cycle_x}/tables/{roi_table}\")\n    logger.info(\n        f\"Found {len(ROI_table_x)} ROIs in {roi_table=} to be processed.\"\n    )\n\n    # Check that table type of ROI_table_ref is valid. Note that\n    # \"ngff:region_table\" and None are accepted for backwards compatibility\n    valid_table_types = [\n        \"roi_table\",\n        \"masking_roi_table\",\n        \"ngff:region_table\",\n        None,\n    ]\n    ROI_table_ref_group = zarr.open_group(\n        f\"{zarr_img_ref_cycle}/tables/{roi_table}\",\n        mode=\"r\",\n    )\n    ref_table_attrs = ROI_table_ref_group.attrs.asdict()\n    ref_table_type = ref_table_attrs.get(\"type\")\n    if ref_table_type not in valid_table_types:\n        raise ValueError(\n            (\n                f\"Table '{roi_table}' (with type '{ref_table_type}') is \"\n                \"not a valid ROI table.\"\n            )\n        )\n\n    # For each cycle, get the relevant info\n    # TODO: Add additional checks on ROIs?\n    if (ROI_table_ref.obs.index != ROI_table_x.obs.index).all():\n        raise ValueError(\n            \"Registration is only implemented for ROIs that match between the \"\n            \"cycles (e.g. well, FOV ROIs). Here, the ROIs in the reference \"\n            \"cycles were {ROI_table_ref.obs.index}, but the ROIs in the \"\n            \"alignment cycle were {ROI_table_x.obs.index}\"\n        )\n    # TODO: Make this less restrictive? i.e. could we also run it if different\n    # cycles have different FOVs? But then how do we know which FOVs to match?\n    # If we relax this, downstream assumptions on matching based on order\n    # in the list will break.\n\n    # Read pixel sizes from zarr attributes\n    ngff_image_meta_cycle_x = load_NgffImageMeta(str(zarr_img_cycle_x))\n    pxl_sizes_zyx = ngff_image_meta.get_pixel_sizes_zyx(level=0)\n    pxl_sizes_zyx_cycle_x = ngff_image_meta_cycle_x.get_pixel_sizes_zyx(\n        level=0\n    )\n\n    if pxl_sizes_zyx != pxl_sizes_zyx_cycle_x:\n        raise ValueError(\n            \"Pixel sizes need to be equal between cycles for registration\"\n        )\n\n    # Create list of indices for 3D ROIs spanning the entire Z direction\n    list_indices_ref = convert_ROI_table_to_indices(\n        ROI_table_ref,\n        level=level,\n        coarsening_xy=coarsening_xy,\n        full_res_pxl_sizes_zyx=pxl_sizes_zyx,\n    )\n    check_valid_ROI_indices(list_indices_ref, roi_table)\n\n    list_indices_cycle_x = convert_ROI_table_to_indices(\n        ROI_table_x,\n        level=level,\n        coarsening_xy=coarsening_xy,\n        full_res_pxl_sizes_zyx=pxl_sizes_zyx,\n    )\n    check_valid_ROI_indices(list_indices_cycle_x, roi_table)\n\n    num_ROIs = len(list_indices_ref)\n    compute = True\n    new_shifts = {}\n    for i_ROI in range(num_ROIs):\n        logger.info(\n            f\"Now processing ROI {i_ROI+1}/{num_ROIs} \"\n            f\"for channel {channel_align}.\"\n        )\n        img_ref = load_region(\n            data_zyx=data_reference_zyx,\n            region=convert_indices_to_regions(list_indices_ref[i_ROI]),\n            compute=compute,\n        )\n        img_cycle_x = load_region(\n            data_zyx=data_alignment_zyx,\n            region=convert_indices_to_regions(list_indices_cycle_x[i_ROI]),\n            compute=compute,\n        )\n\n        ##############\n        #  Calculate the transformation\n        ##############\n        # Basic version (no padding, no internal binning)\n        if img_ref.shape != img_cycle_x.shape:\n            raise NotImplementedError(\n                \"This registration is not implemented for ROIs with \"\n                \"different shapes between cycles\"\n            )\n        shifts = phase_cross_correlation(\n            np.squeeze(img_ref), np.squeeze(img_cycle_x)\n        )[0]\n\n        # Registration based on scmultiplex, image-based\n        # shifts, _, _ = calculate_shift(np.squeeze(img_ref),\n        #           np.squeeze(img_cycle_x), bin=binning, binarize=False)\n\n        # TODO: Make this work on label images\n        # (=&gt; different loading) etc.\n\n        ##############\n        # Storing the calculated transformation ###\n        ##############\n        # Store the shift in ROI table\n        # TODO: Store in OME-NGFF transformations: Check SpatialData approach,\n        # per ROI storage?\n\n        # Adapt ROIs for the given ROI table:\n        ROI_name = ROI_table_ref.obs.index[i_ROI]\n        new_shifts[ROI_name] = calculate_physical_shifts(\n            shifts,\n            level=level,\n            coarsening_xy=coarsening_xy,\n            full_res_pxl_sizes_zyx=pxl_sizes_zyx,\n        )\n\n    # Write physical shifts to disk (as part of the ROI table)\n    logger.info(f\"Updating the {roi_table=} with translation columns\")\n    image_group = zarr.group(zarr_img_cycle_x)\n    new_ROI_table = get_ROI_table_with_translation(ROI_table_x, new_shifts)\n    write_table(\n        image_group,\n        roi_table,\n        new_ROI_table,\n        overwrite=True,\n        table_attrs=ref_table_attrs,\n    )\n\n    return {}\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/calculate_registration_image_based/#fractal_tasks_core.tasks.calculate_registration_image_based.get_ROI_table_with_translation","title":"<code>get_ROI_table_with_translation(ROI_table, new_shifts)</code>","text":"<p>Adds translation columns to a ROI table</p> PARAMETER  DESCRIPTION <code>ROI_table</code> <p>Fractal ROI table</p> <p> TYPE: <code>AnnData</code> </p> <code>new_shifts</code> <p>zyx list of shifts</p> <p> TYPE: <code>dict[str, list[float]]</code> </p> RETURNS DESCRIPTION <code>AnnData</code> <p>Fractal ROI table with 3 additional columns for calculated translations</p> Source code in <code>fractal_tasks_core/tasks/calculate_registration_image_based.py</code> <pre><code>def get_ROI_table_with_translation(\n    ROI_table: ad.AnnData,\n    new_shifts: dict[str, list[float]],\n) -&gt; ad.AnnData:\n\"\"\"\n    Adds translation columns to a ROI table\n\n    Args:\n        ROI_table: Fractal ROI table\n        new_shifts: zyx list of shifts\n\n    Returns:\n        Fractal ROI table with 3 additional columns for calculated translations\n    \"\"\"\n\n    shift_table = pd.DataFrame(new_shifts).T\n    shift_table.columns = [\"translation_z\", \"translation_y\", \"translation_x\"]\n    shift_table = shift_table.rename_axis(\"FieldIndex\")\n    new_roi_table = ROI_table.to_df().merge(\n        shift_table, left_index=True, right_index=True\n    )\n    if len(new_roi_table) != len(ROI_table):\n        raise ValueError(\n            \"New ROI table with registration info has a \"\n            f\"different length ({len(new_roi_table)=}) \"\n            f\"from the original ROI table ({len(ROI_table)=})\"\n        )\n\n    adata = ad.AnnData(X=new_roi_table.astype(np.float32))\n    adata.obs_names = new_roi_table.index\n    adata.var_names = list(map(str, new_roi_table.columns))\n    return adata\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/cellpose_segmentation/","title":"cellpose_segmentation","text":"<p>Image segmentation via Cellpose library.</p>"},{"location":"reference/fractal_tasks_core/tasks/cellpose_segmentation/#fractal_tasks_core.tasks.cellpose_segmentation.cellpose_segmentation","title":"<code>cellpose_segmentation(*, input_paths, output_path, component, metadata, level, channel, channel2=None, input_ROI_table='FOV_ROI_table', output_ROI_table=None, output_label_name=None, use_masks=True, relabeling=True, diameter_level0=30.0, model_type='cyto2', pretrained_model=None, cellprob_threshold=0.0, flow_threshold=0.4, normalize=CellposeCustomNormalizer(), anisotropy=None, min_size=15, augment=False, net_avg=False, use_gpu=True, batch_size=8, invert=False, tile=True, tile_overlap=0.1, resample=True, interp=True, stitch_threshold=0.0, overwrite=True)</code>","text":"<p>Run cellpose segmentation on the ROIs of a single OME-Zarr image.</p> PARAMETER  DESCRIPTION <code>input_paths</code> <p>List of input paths where the image data is stored as OME-Zarrs. Should point to the parent folder containing one or many OME-Zarr files, not the actual OME-Zarr file. Example: <code>[\"/some/path/\"]</code>. This task only supports a single input path. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>Sequence[str]</code> </p> <code>output_path</code> <p>This parameter is not used by this task. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>str</code> </p> <code>component</code> <p>Path to the OME-Zarr image in the OME-Zarr plate that is processed. Example: <code>\"some_plate.zarr/B/03/0\"</code>. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>str</code> </p> <code>metadata</code> <p>This parameter is not used by this task. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>level</code> <p>Pyramid level of the image to be segmented. Choose <code>0</code> to process at full resolution.</p> <p> TYPE: <code>int</code> </p> <code>channel</code> <p>Primary channel for segmentation; requires either <code>wavelength_id</code> (e.g. <code>A01_C01</code>) or <code>label</code> (e.g. <code>DAPI</code>).</p> <p> TYPE: <code>ChannelInputModel</code> </p> <code>channel2</code> <p>Second channel for segmentation (in the same format as <code>channel</code>). If specified, cellpose runs in dual channel mode. For dual channel segmentation of cells, the first channel should contain the membrane marker, the second channel should contain the nuclear marker.</p> <p> TYPE: <code>Optional[ChannelInputModel]</code> DEFAULT: <code>None</code> </p> <code>input_ROI_table</code> <p>Name of the ROI table over which the task loops to apply Cellpose segmentation. Examples: <code>FOV_ROI_table</code> =&gt; loop over the field of views, <code>organoid_ROI_table</code> =&gt; loop over the organoid ROI table (generated by another task), <code>well_ROI_table</code> =&gt; process the whole well as one image.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'FOV_ROI_table'</code> </p> <code>output_ROI_table</code> <p>If provided, a ROI table with that name is created, which will contain the bounding boxes of the newly segmented labels. ROI tables should have <code>ROI</code> in their name.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>use_masks</code> <p>If <code>True</code>, try to use masked loading and fall back to <code>use_masks=False</code> if the ROI table is not suitable. Masked loading is relevant when only a subset of the bounding box should actually be processed (e.g. running within <code>organoid_ROI_table</code>).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>output_label_name</code> <p>Name of the output label image (e.g. <code>\"organoids\"</code>).</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>relabeling</code> <p>If <code>True</code>, apply relabeling so that label values are unique for all objects in the well.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>diameter_level0</code> <p>Expected diameter of the objects that should be segmented in pixels at level 0. Initial diameter is rescaled using the <code>level</code> that was selected. The rescaled value is passed as the diameter to the <code>CellposeModel.eval</code> method.</p> <p> TYPE: <code>float</code> DEFAULT: <code>30.0</code> </p> <code>model_type</code> <p>Parameter of <code>CellposeModel</code> class. Defines which model should be used. Typical choices are <code>nuclei</code>, <code>cyto</code>, <code>cyto2</code>, etc.</p> <p> TYPE: <code>Literal[tuple(MODEL_NAMES)]</code> DEFAULT: <code>'cyto2'</code> </p> <code>pretrained_model</code> <p>Parameter of <code>CellposeModel</code> class (takes precedence over <code>model_type</code>). Allows you to specify the path of a custom trained cellpose model.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>cellprob_threshold</code> <p>Parameter of <code>CellposeModel.eval</code> method. Valid values between -6 to 6. From Cellpose documentation: \"Decrease this threshold if cellpose is not returning as many ROIs as you\u2019d expect. Similarly, increase this threshold if cellpose is returning too ROIs particularly from dim areas.\"</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> <code>flow_threshold</code> <p>Parameter of <code>CellposeModel.eval</code> method. Valid values between 0.0 and 1.0. From Cellpose documentation: \"Increase this threshold if cellpose is not returning as many ROIs as you\u2019d expect. Similarly, decrease this threshold if cellpose is returning too many ill-shaped ROIs.\"</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.4</code> </p> <code>normalize</code> <p>By default, data is normalized so 0.0=1st percentile and 1.0=99th percentile of image intensities in each channel. This automatic normalization can lead to issues when the image to be segmented is very sparse. You can turn off the default rescaling. With the \"custom\" option, you can either provide your own rescaling percentiles or fixed rescaling upper and lower bound integers.</p> <p> TYPE: <code>CellposeCustomNormalizer</code> DEFAULT: <code>CellposeCustomNormalizer()</code> </p> <code>anisotropy</code> <p>Ratio of the pixel sizes along Z and XY axis (ignored if the image is not three-dimensional). If <code>None</code>, it is inferred from the OME-NGFF metadata.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>min_size</code> <p>Parameter of <code>CellposeModel</code> class. Minimum size of the segmented objects (in pixels). Use <code>-1</code> to turn off the size filter.</p> <p> TYPE: <code>int</code> DEFAULT: <code>15</code> </p> <code>augment</code> <p>Parameter of <code>CellposeModel</code> class. Whether to use cellpose augmentation to tile images with overlap.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>net_avg</code> <p>Parameter of <code>CellposeModel</code> class. Whether to use cellpose net averaging to run the 4 built-in networks (useful for <code>nuclei</code>, <code>cyto</code> and <code>cyto2</code>, not sure it works for the others).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>use_gpu</code> <p>If <code>False</code>, always use the CPU; if <code>True</code>, use the GPU if possible (as defined in <code>cellpose.core.use_gpu()</code>) and fall-back to the CPU otherwise.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>batch_size</code> <p>number of 224x224 patches to run simultaneously on the GPU (can make smaller or bigger depending on GPU memory usage)</p> <p> TYPE: <code>int</code> DEFAULT: <code>8</code> </p> <code>invert</code> <p>invert image pixel intensity before running network (if True, image is also normalized)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>tile</code> <p>tiles image to ensure GPU/CPU memory usage limited (recommended)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>tile_overlap</code> <p>fraction of overlap of tiles when computing flows</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.1</code> </p> <code>resample</code> <p>run dynamics at original image size (will be slower but create more accurate boundaries)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>interp</code> <p>interpolate during 2D dynamics (not available in 3D) (in previous versions it was False, now it defaults to True)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>stitch_threshold</code> <p>if stitch_threshold&gt;0.0 and not do_3D and equal image sizes, masks are stitched in 3D to return volume segmentation</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> <code>overwrite</code> <p>If <code>True</code>, overwrite the task output.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>fractal_tasks_core/tasks/cellpose_segmentation.py</code> <pre><code>@validate_arguments\ndef cellpose_segmentation(\n    *,\n    # Fractal arguments\n    input_paths: Sequence[str],\n    output_path: str,\n    component: str,\n    metadata: dict[str, Any],\n    # Task-specific arguments\n    level: int,\n    channel: ChannelInputModel,\n    channel2: Optional[ChannelInputModel] = None,\n    input_ROI_table: str = \"FOV_ROI_table\",\n    output_ROI_table: Optional[str] = None,\n    output_label_name: Optional[str] = None,\n    use_masks: bool = True,\n    relabeling: bool = True,\n    # Cellpose-related arguments\n    diameter_level0: float = 30.0,\n    # https://github.com/fractal-analytics-platform/fractal-tasks-core/issues/401 # noqa E501\n    model_type: Literal[tuple(models.MODEL_NAMES)] = \"cyto2\",\n    pretrained_model: Optional[str] = None,\n    cellprob_threshold: float = 0.0,\n    flow_threshold: float = 0.4,\n    normalize: CellposeCustomNormalizer = CellposeCustomNormalizer(),\n    anisotropy: Optional[float] = None,\n    min_size: int = 15,\n    augment: bool = False,\n    net_avg: bool = False,\n    use_gpu: bool = True,\n    batch_size: int = 8,\n    invert: bool = False,\n    tile: bool = True,\n    tile_overlap: float = 0.1,\n    resample: bool = True,\n    interp: bool = True,\n    stitch_threshold: float = 0.0,\n    # Overwrite option\n    overwrite: bool = True,\n) -&gt; dict[str, Any]:\n\"\"\"\n    Run cellpose segmentation on the ROIs of a single OME-Zarr image.\n\n    Args:\n        input_paths: List of input paths where the image data is stored as\n            OME-Zarrs. Should point to the parent folder containing one or many\n            OME-Zarr files, not the actual OME-Zarr file. Example:\n            `[\"/some/path/\"]`. This task only supports a single input path.\n            (standard argument for Fractal tasks, managed by Fractal server).\n        output_path: This parameter is not used by this task.\n            (standard argument for Fractal tasks, managed by Fractal server).\n        component: Path to the OME-Zarr image in the OME-Zarr plate that is\n            processed. Example: `\"some_plate.zarr/B/03/0\"`.\n            (standard argument for Fractal tasks, managed by Fractal server).\n        metadata: This parameter is not used by this task.\n            (standard argument for Fractal tasks, managed by Fractal server).\n        level: Pyramid level of the image to be segmented. Choose `0` to\n            process at full resolution.\n        channel: Primary channel for segmentation; requires either\n            `wavelength_id` (e.g. `A01_C01`) or `label` (e.g. `DAPI`).\n        channel2: Second channel for segmentation (in the same format as\n            `channel`). If specified, cellpose runs in dual channel mode.\n            For dual channel segmentation of cells, the first channel should\n            contain the membrane marker, the second channel should contain the\n            nuclear marker.\n        input_ROI_table: Name of the ROI table over which the task loops to\n            apply Cellpose segmentation. Examples: `FOV_ROI_table` =&gt; loop over\n            the field of views, `organoid_ROI_table` =&gt; loop over the organoid\n            ROI table (generated by another task), `well_ROI_table` =&gt; process\n            the whole well as one image.\n        output_ROI_table: If provided, a ROI table with that name is created,\n            which will contain the bounding boxes of the newly segmented\n            labels. ROI tables should have `ROI` in their name.\n        use_masks: If `True`, try to use masked loading and fall back to\n            `use_masks=False` if the ROI table is not suitable. Masked\n            loading is relevant when only a subset of the bounding box should\n            actually be processed (e.g. running within `organoid_ROI_table`).\n        output_label_name: Name of the output label image (e.g. `\"organoids\"`).\n        relabeling: If `True`, apply relabeling so that label values are\n            unique for all objects in the well.\n        diameter_level0: Expected diameter of the objects that should be\n            segmented in pixels at level 0. Initial diameter is rescaled using\n            the `level` that was selected. The rescaled value is passed as\n            the diameter to the `CellposeModel.eval` method.\n        model_type: Parameter of `CellposeModel` class. Defines which model\n            should be used. Typical choices are `nuclei`, `cyto`, `cyto2`, etc.\n        pretrained_model: Parameter of `CellposeModel` class (takes\n            precedence over `model_type`). Allows you to specify the path of\n            a custom trained cellpose model.\n        cellprob_threshold: Parameter of `CellposeModel.eval` method. Valid\n            values between -6 to 6. From Cellpose documentation: \"Decrease this\n            threshold if cellpose is not returning as many ROIs as you\u2019d\n            expect. Similarly, increase this threshold if cellpose is returning\n            too ROIs particularly from dim areas.\"\n        flow_threshold: Parameter of `CellposeModel.eval` method. Valid\n            values between 0.0 and 1.0. From Cellpose documentation: \"Increase\n            this threshold if cellpose is not returning as many ROIs as you\u2019d\n            expect. Similarly, decrease this threshold if cellpose is returning\n            too many ill-shaped ROIs.\"\n        normalize: By default, data is normalized so 0.0=1st percentile and\n            1.0=99th percentile of image intensities in each channel.\n            This automatic normalization can lead to issues when the image to\n            be segmented is very sparse. You can turn off the default\n            rescaling. With the \"custom\" option, you can either provide your\n            own rescaling percentiles or fixed rescaling upper and lower\n            bound integers.\n        anisotropy: Ratio of the pixel sizes along Z and XY axis (ignored if\n            the image is not three-dimensional). If `None`, it is inferred from\n            the OME-NGFF metadata.\n        min_size: Parameter of `CellposeModel` class. Minimum size of the\n            segmented objects (in pixels). Use `-1` to turn off the size\n            filter.\n        augment: Parameter of `CellposeModel` class. Whether to use cellpose\n            augmentation to tile images with overlap.\n        net_avg: Parameter of `CellposeModel` class. Whether to use cellpose\n            net averaging to run the 4 built-in networks (useful for `nuclei`,\n            `cyto` and `cyto2`, not sure it works for the others).\n        use_gpu: If `False`, always use the CPU; if `True`, use the GPU if\n            possible (as defined in `cellpose.core.use_gpu()`) and fall-back\n            to the CPU otherwise.\n        batch_size: number of 224x224 patches to run simultaneously on the GPU\n            (can make smaller or bigger depending on GPU memory usage)\n        invert: invert image pixel intensity before running network (if True,\n            image is also normalized)\n        tile: tiles image to ensure GPU/CPU memory usage limited (recommended)\n        tile_overlap: fraction of overlap of tiles when computing flows\n        resample: run dynamics at original image size (will be slower but\n            create more accurate boundaries)\n        interp: interpolate during 2D dynamics (not available in 3D)\n            (in previous versions it was False, now it defaults to True)\n        stitch_threshold: if stitch_threshold&gt;0.0 and not do_3D and equal\n            image sizes, masks are stitched in 3D to return volume segmentation\n        overwrite: If `True`, overwrite the task output.\n    \"\"\"\n\n    # Set input path\n    if len(input_paths) &gt; 1:\n        raise NotImplementedError\n    in_path = Path(input_paths[0])\n    zarrurl = (in_path.resolve() / component).as_posix()\n    logger.info(f\"{zarrurl=}\")\n\n    # Preliminary checks on Cellpose model\n    if pretrained_model:\n        if not os.path.exists(pretrained_model):\n            raise ValueError(f\"{pretrained_model=} does not exist.\")\n\n    # Read attributes from NGFF metadata\n    ngff_image_meta = load_NgffImageMeta(zarrurl)\n    num_levels = ngff_image_meta.num_levels\n    coarsening_xy = ngff_image_meta.coarsening_xy\n    full_res_pxl_sizes_zyx = ngff_image_meta.get_pixel_sizes_zyx(level=0)\n    actual_res_pxl_sizes_zyx = ngff_image_meta.get_pixel_sizes_zyx(level=level)\n    logger.info(f\"NGFF image has {num_levels=}\")\n    logger.info(f\"NGFF image has {coarsening_xy=}\")\n    logger.info(\n        f\"NGFF image has full-res pixel sizes {full_res_pxl_sizes_zyx}\"\n    )\n    logger.info(\n        f\"NGFF image has level-{level} pixel sizes \"\n        f\"{actual_res_pxl_sizes_zyx}\"\n    )\n\n    plate, well = component.split(\".zarr/\")\n\n    # Find channel index\n    try:\n        tmp_channel: OmeroChannel = get_channel_from_image_zarr(\n            image_zarr_path=zarrurl,\n            wavelength_id=channel.wavelength_id,\n            label=channel.label,\n        )\n    except ChannelNotFoundError as e:\n        logger.warning(\n            \"Channel not found, exit from the task.\\n\"\n            f\"Original error: {str(e)}\"\n        )\n        return {}\n    ind_channel = tmp_channel.index\n\n    # Find channel index for second channel, if one is provided\n    if channel2:\n        try:\n            tmp_channel_c2: OmeroChannel = get_channel_from_image_zarr(\n                image_zarr_path=zarrurl,\n                wavelength_id=channel2.wavelength_id,\n                label=channel2.label,\n            )\n        except ChannelNotFoundError as e:\n            logger.warning(\n                f\"Second channel with wavelength_id: {channel2.wavelength_id} \"\n                f\"and label: {channel2.label} not found, exit from the task.\\n\"\n                f\"Original error: {str(e)}\"\n            )\n            return {}\n        ind_channel_c2 = tmp_channel_c2.index\n\n    # Set channel label\n    if output_label_name is None:\n        try:\n            channel_label = tmp_channel.label\n            output_label_name = f\"label_{channel_label}\"\n        except (KeyError, IndexError):\n            output_label_name = f\"label_{ind_channel}\"\n\n    # Load ZYX data\n    data_zyx = da.from_zarr(f\"{zarrurl}/{level}\")[ind_channel]\n    logger.info(f\"{data_zyx.shape=}\")\n    if channel2:\n        data_zyx_c2 = da.from_zarr(f\"{zarrurl}/{level}\")[ind_channel_c2]\n        logger.info(f\"Second channel: {data_zyx_c2.shape=}\")\n\n    # Read ROI table\n    ROI_table_path = f\"{zarrurl}/tables/{input_ROI_table}\"\n    ROI_table = ad.read_zarr(ROI_table_path)\n\n    # Perform some checks on the ROI table\n    valid_ROI_table = is_ROI_table_valid(\n        table_path=ROI_table_path, use_masks=use_masks\n    )\n    if use_masks and not valid_ROI_table:\n        logger.info(\n            f\"ROI table at {ROI_table_path} cannot be used for masked \"\n            \"loading. Set use_masks=False.\"\n        )\n        use_masks = False\n    logger.info(f\"{use_masks=}\")\n\n    # Create list of indices for 3D ROIs spanning the entire Z direction\n    list_indices = convert_ROI_table_to_indices(\n        ROI_table,\n        level=level,\n        coarsening_xy=coarsening_xy,\n        full_res_pxl_sizes_zyx=full_res_pxl_sizes_zyx,\n    )\n    check_valid_ROI_indices(list_indices, input_ROI_table)\n\n    # If we are not planning to use masked loading, fail for overlapping ROIs\n    if not use_masks:\n        overlap = find_overlaps_in_ROI_indices(list_indices)\n        if overlap:\n            raise ValueError(\n                f\"ROI indices created from {input_ROI_table} table have \"\n                \"overlaps, but we are not using masked loading.\"\n            )\n\n    # Select 2D/3D behavior and set some parameters\n    do_3D = data_zyx.shape[0] &gt; 1 and len(data_zyx.shape) == 3\n    if do_3D:\n        if anisotropy is None:\n            # Compute anisotropy as pixel_size_z/pixel_size_x\n            anisotropy = (\n                actual_res_pxl_sizes_zyx[0] / actual_res_pxl_sizes_zyx[2]\n            )\n        logger.info(f\"Anisotropy: {anisotropy}\")\n\n    # Rescale datasets (only relevant for level&gt;0)\n    if ngff_image_meta.axes_names[0] != \"c\":\n        raise ValueError(\n            \"Cannot set `remove_channel_axis=True` for multiscale \"\n            f\"metadata with axes={ngff_image_meta.axes_names}. \"\n            'First axis should have name \"c\".'\n        )\n    new_datasets = rescale_datasets(\n        datasets=[ds.dict() for ds in ngff_image_meta.datasets],\n        coarsening_xy=coarsening_xy,\n        reference_level=level,\n        remove_channel_axis=True,\n    )\n\n    label_attrs = {\n        \"image-label\": {\n            \"version\": __OME_NGFF_VERSION__,\n            \"source\": {\"image\": \"../../\"},\n        },\n        \"multiscales\": [\n            {\n                \"name\": output_label_name,\n                \"version\": __OME_NGFF_VERSION__,\n                \"axes\": [\n                    ax.dict()\n                    for ax in ngff_image_meta.multiscale.axes\n                    if ax.type != \"channel\"\n                ],\n                \"datasets\": new_datasets,\n            }\n        ],\n    }\n\n    image_group = zarr.group(zarrurl)\n    label_group = prepare_label_group(\n        image_group,\n        output_label_name,\n        overwrite=overwrite,\n        label_attrs=label_attrs,\n        logger=logger,\n    )\n\n    logger.info(\n        f\"Helper function `prepare_label_group` returned {label_group=}\"\n    )\n    logger.info(f\"Output label path: {zarrurl}/labels/{output_label_name}/0\")\n    store = zarr.storage.FSStore(f\"{zarrurl}/labels/{output_label_name}/0\")\n    label_dtype = np.uint32\n\n    # Ensure that all output shapes &amp; chunks are 3D (for 2D data: (1, y, x))\n    # https://github.com/fractal-analytics-platform/fractal-tasks-core/issues/398\n    shape = data_zyx.shape\n    if len(shape) == 2:\n        shape = (1, *shape)\n    chunks = data_zyx.chunksize\n    if len(chunks) == 2:\n        chunks = (1, *chunks)\n    mask_zarr = zarr.create(\n        shape=shape,\n        chunks=chunks,\n        dtype=label_dtype,\n        store=store,\n        overwrite=False,\n        dimension_separator=\"/\",\n    )\n\n    logger.info(\n        f\"mask will have shape {data_zyx.shape} \"\n        f\"and chunks {data_zyx.chunks}\"\n    )\n\n    # Initialize cellpose\n    gpu = use_gpu and cellpose.core.use_gpu()\n    if pretrained_model:\n        model = models.CellposeModel(\n            gpu=gpu, pretrained_model=pretrained_model\n        )\n    else:\n        model = models.CellposeModel(gpu=gpu, model_type=model_type)\n\n    # Initialize other things\n    logger.info(f\"Start cellpose_segmentation task for {zarrurl}\")\n    logger.info(f\"relabeling: {relabeling}\")\n    logger.info(f\"do_3D: {do_3D}\")\n    logger.info(f\"use_gpu: {gpu}\")\n    logger.info(f\"level: {level}\")\n    logger.info(f\"model_type: {model_type}\")\n    logger.info(f\"pretrained_model: {pretrained_model}\")\n    logger.info(f\"anisotropy: {anisotropy}\")\n    logger.info(\"Total well shape/chunks:\")\n    logger.info(f\"{data_zyx.shape}\")\n    logger.info(f\"{data_zyx.chunks}\")\n    if channel2:\n        logger.info(\"Dual channel input for cellpose model\")\n        logger.info(f\"{data_zyx_c2.shape}\")\n        logger.info(f\"{data_zyx_c2.chunks}\")\n\n    # Counters for relabeling\n    if relabeling:\n        num_labels_tot = 0\n\n    # Iterate over ROIs\n    num_ROIs = len(list_indices)\n\n    if output_ROI_table:\n        bbox_dataframe_list = []\n\n    logger.info(f\"Now starting loop over {num_ROIs} ROIs\")\n    for i_ROI, indices in enumerate(list_indices):\n        # Define region\n        s_z, e_z, s_y, e_y, s_x, e_x = indices[:]\n        region = (\n            slice(s_z, e_z),\n            slice(s_y, e_y),\n            slice(s_x, e_x),\n        )\n        logger.info(f\"Now processing ROI {i_ROI+1}/{num_ROIs}\")\n\n        # Prepare single-channel or dual-channel input for cellpose\n        if channel2:\n            # Dual channel mode, first channel is the membrane channel\n            img_1 = load_region(\n                data_zyx,\n                region,\n                compute=True,\n                return_as_3D=True,\n            )\n            img_np = np.zeros((2, *img_1.shape))\n            img_np[0, :, :, :] = img_1\n            img_np[1, :, :, :] = load_region(\n                data_zyx_c2,\n                region,\n                compute=True,\n                return_as_3D=True,\n            )\n            channels = [1, 2]\n        else:\n            img_np = np.expand_dims(\n                load_region(data_zyx, region, compute=True, return_as_3D=True),\n                axis=0,\n            )\n            channels = [0, 0]\n\n        # Prepare keyword arguments for segment_ROI function\n        kwargs_segment_ROI = dict(\n            model=model,\n            channels=channels,\n            do_3D=do_3D,\n            anisotropy=anisotropy,\n            label_dtype=label_dtype,\n            diameter=diameter_level0 / coarsening_xy**level,\n            cellprob_threshold=cellprob_threshold,\n            flow_threshold=flow_threshold,\n            normalize=normalize,\n            min_size=min_size,\n            augment=augment,\n            net_avg=net_avg,\n            batch_size=batch_size,\n            invert=invert,\n            tile=tile,\n            tile_overlap=tile_overlap,\n            resample=resample,\n            interp=interp,\n            stitch_threshold=stitch_threshold,\n        )\n\n        # Prepare keyword arguments for preprocessing function\n        preprocessing_kwargs = {}\n        if use_masks:\n            preprocessing_kwargs = dict(\n                region=region,\n                current_label_path=f\"{zarrurl}/labels/{output_label_name}/0\",\n                ROI_table_path=ROI_table_path,\n                ROI_positional_index=i_ROI,\n            )\n\n        # Call segment_ROI through the masked-loading wrapper, which includes\n        # pre/post-processing functions if needed\n        new_label_img = masked_loading_wrapper(\n            image_array=img_np,\n            function=segment_ROI,\n            kwargs=kwargs_segment_ROI,\n            use_masks=use_masks,\n            preprocessing_kwargs=preprocessing_kwargs,\n        )\n\n        # Shift labels and update relabeling counters\n        if relabeling:\n            num_labels_roi = np.max(new_label_img)\n            new_label_img[new_label_img &gt; 0] += num_labels_tot\n            num_labels_tot += num_labels_roi\n\n            # Write some logs\n            logger.info(f\"ROI {indices}, {num_labels_roi=}, {num_labels_tot=}\")\n\n            # Check that total number of labels is under control\n            if num_labels_tot &gt; np.iinfo(label_dtype).max:\n                raise ValueError(\n                    \"ERROR in re-labeling:\"\n                    f\"Reached {num_labels_tot} labels, \"\n                    f\"but dtype={label_dtype}\"\n                )\n\n        if output_ROI_table:\n            bbox_df = array_to_bounding_box_table(\n                new_label_img,\n                actual_res_pxl_sizes_zyx,\n                origin_zyx=(s_z, s_y, s_x),\n            )\n\n            bbox_dataframe_list.append(bbox_df)\n\n            overlap_list = []\n            for df in bbox_dataframe_list:\n                overlap_list.extend(\n                    get_overlapping_pairs_3D(df, full_res_pxl_sizes_zyx)\n                )\n            if len(overlap_list) &gt; 0:\n                logger.warning(\n                    f\"{len(overlap_list)} bounding-box pairs overlap\"\n                )\n\n        # Compute and store 0-th level to disk\n        da.array(new_label_img).to_zarr(\n            url=mask_zarr,\n            region=region,\n            compute=True,\n        )\n\n    logger.info(\n        f\"End cellpose_segmentation task for {zarrurl}, \"\n        \"now building pyramids.\"\n    )\n\n    # Starting from on-disk highest-resolution data, build and write to disk a\n    # pyramid of coarser levels\n    build_pyramid(\n        zarrurl=f\"{zarrurl}/labels/{output_label_name}\",\n        overwrite=overwrite,\n        num_levels=num_levels,\n        coarsening_xy=coarsening_xy,\n        chunksize=chunks,\n        aggregation_function=np.max,\n    )\n\n    logger.info(\"End building pyramids\")\n\n    if output_ROI_table:\n        # Handle the case where `bbox_dataframe_list` is empty (typically\n        # because list_indices is also empty)\n        if len(bbox_dataframe_list) == 0:\n            bbox_dataframe_list = [empty_bounding_box_table()]\n        # Concatenate all ROI dataframes\n        df_well = pd.concat(bbox_dataframe_list, axis=0, ignore_index=True)\n        df_well.index = df_well.index.astype(str)\n        # Extract labels and drop them from df_well\n        labels = pd.DataFrame(df_well[\"label\"].astype(str))\n        df_well.drop(labels=[\"label\"], axis=1, inplace=True)\n        # Convert all to float (warning: some would be int, in principle)\n        bbox_dtype = np.float32\n        df_well = df_well.astype(bbox_dtype)\n        # Convert to anndata\n        bbox_table = ad.AnnData(df_well, dtype=bbox_dtype)\n        bbox_table.obs = labels\n\n        # Write to zarr group\n        image_group = zarr.group(f\"{in_path}/{component}\")\n        logger.info(\n            \"Now writing bounding-box ROI table to \"\n            f\"{in_path}/{component}/tables/{output_ROI_table}\"\n        )\n        table_attrs = {\n            \"type\": \"masking_roi_table\",\n            \"region\": {\"path\": f\"../labels/{output_label_name}\"},\n            \"instance_key\": \"label\",\n        }\n        write_table(\n            image_group,\n            output_ROI_table,\n            bbox_table,\n            overwrite=overwrite,\n            table_attrs=table_attrs,\n        )\n\n    return {}\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/cellpose_segmentation/#fractal_tasks_core.tasks.cellpose_segmentation.segment_ROI","title":"<code>segment_ROI(x, model=None, do_3D=True, channels=[0, 0], anisotropy=None, diameter=30.0, cellprob_threshold=0.0, flow_threshold=0.4, normalize=CellposeCustomNormalizer(), label_dtype=None, augment=False, net_avg=False, min_size=15, batch_size=8, invert=False, tile=True, tile_overlap=0.1, resample=True, interp=True, stitch_threshold=0.0)</code>","text":"<p>Internal function that runs Cellpose segmentation for a single ROI.</p> PARAMETER  DESCRIPTION <code>x</code> <p>4D numpy array.</p> <p> TYPE: <code>ndarray</code> </p> <code>model</code> <p>An instance of <code>models.CellposeModel</code>.</p> <p> TYPE: <code>CellposeModel</code> DEFAULT: <code>None</code> </p> <code>do_3D</code> <p>If <code>True</code>, cellpose runs in 3D mode: runs on xy, xz &amp; yz planes, then averages the flows.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>channels</code> <p>Which channels to use. If only one channel is provided, <code>[0, 0]</code> should be used. If two channels are provided (the first dimension of <code>x</code> has length of 2), <code>[1, 2]</code> should be used (<code>x[0, :, :,:]</code> contains the membrane channel and <code>x[1, :, :, :]</code> contains the nuclear channel).</p> <p> TYPE: <code>list[int]</code> DEFAULT: <code>[0, 0]</code> </p> <code>anisotropy</code> <p>Set anisotropy rescaling factor for Z dimension.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>diameter</code> <p>Expected object diameter in pixels for cellpose.</p> <p> TYPE: <code>float</code> DEFAULT: <code>30.0</code> </p> <code>cellprob_threshold</code> <p>Cellpose model parameter.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> <code>flow_threshold</code> <p>Cellpose model parameter.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.4</code> </p> <code>normalize</code> <p>normalize data so 0.0=1st percentile and 1.0=99th percentile of image intensities in each channel. This automatic normalization can lead to issues when the image to be segmented is very sparse.</p> <p> TYPE: <code>CellposeCustomNormalizer</code> DEFAULT: <code>CellposeCustomNormalizer()</code> </p> <code>label_dtype</code> <p>Label images are cast into this <code>np.dtype</code>.</p> <p> TYPE: <code>Optional[dtype]</code> DEFAULT: <code>None</code> </p> <code>augment</code> <p>Whether to use cellpose augmentation to tile images with overlap.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>net_avg</code> <p>Whether to use cellpose net averaging to run the 4 built-in networks (useful for <code>nuclei</code>, <code>cyto</code> and <code>cyto2</code>, not sure it works for the others).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>min_size</code> <p>Minimum size of the segmented objects.</p> <p> TYPE: <code>int</code> DEFAULT: <code>15</code> </p> <code>batch_size</code> <p>number of 224x224 patches to run simultaneously on the GPU (can make smaller or bigger depending on GPU memory usage)</p> <p> TYPE: <code>int</code> DEFAULT: <code>8</code> </p> <code>invert</code> <p>invert image pixel intensity before running network (if True, image is also normalized)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>tile</code> <p>tiles image to ensure GPU/CPU memory usage limited (recommended)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>tile_overlap</code> <p>fraction of overlap of tiles when computing flows</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.1</code> </p> <code>resample</code> <p>run dynamics at original image size (will be slower but create more accurate boundaries)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>interp</code> <p>interpolate during 2D dynamics (not available in 3D) (in previous versions it was False, now it defaults to True)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>stitch_threshold</code> <p>if stitch_threshold&gt;0.0 and not do_3D and equal image sizes, masks are stitched in 3D to return volume segmentation</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> Source code in <code>fractal_tasks_core/tasks/cellpose_segmentation.py</code> <pre><code>def segment_ROI(\n    x: np.ndarray,\n    model: models.CellposeModel = None,\n    do_3D: bool = True,\n    channels: list[int] = [0, 0],\n    anisotropy: Optional[float] = None,\n    diameter: float = 30.0,\n    cellprob_threshold: float = 0.0,\n    flow_threshold: float = 0.4,\n    normalize: CellposeCustomNormalizer = CellposeCustomNormalizer(),\n    label_dtype: Optional[np.dtype] = None,\n    augment: bool = False,\n    net_avg: bool = False,\n    min_size: int = 15,\n    batch_size: int = 8,\n    invert: bool = False,\n    tile: bool = True,\n    tile_overlap: float = 0.1,\n    resample: bool = True,\n    interp: bool = True,\n    stitch_threshold: float = 0.0,\n) -&gt; np.ndarray:\n\"\"\"\n    Internal function that runs Cellpose segmentation for a single ROI.\n\n    Args:\n        x: 4D numpy array.\n        model: An instance of `models.CellposeModel`.\n        do_3D: If `True`, cellpose runs in 3D mode: runs on xy, xz &amp; yz planes,\n            then averages the flows.\n        channels: Which channels to use. If only one channel is provided, `[0,\n            0]` should be used. If two channels are provided (the first\n            dimension of `x` has length of 2), `[1, 2]` should be used\n            (`x[0, :, :,:]` contains the membrane channel and\n            `x[1, :, :, :]` contains the nuclear channel).\n        anisotropy: Set anisotropy rescaling factor for Z dimension.\n        diameter: Expected object diameter in pixels for cellpose.\n        cellprob_threshold: Cellpose model parameter.\n        flow_threshold: Cellpose model parameter.\n        normalize: normalize data so 0.0=1st percentile and 1.0=99th\n            percentile of image intensities in each channel. This automatic\n            normalization can lead to issues when the image to be segmented\n            is very sparse.\n        label_dtype: Label images are cast into this `np.dtype`.\n        augment: Whether to use cellpose augmentation to tile images with\n            overlap.\n        net_avg: Whether to use cellpose net averaging to run the 4 built-in\n            networks (useful for `nuclei`, `cyto` and `cyto2`, not sure it\n            works for the others).\n        min_size: Minimum size of the segmented objects.\n        batch_size: number of 224x224 patches to run simultaneously on the GPU\n            (can make smaller or bigger depending on GPU memory usage)\n        invert: invert image pixel intensity before running network (if True,\n            image is also normalized)\n        tile: tiles image to ensure GPU/CPU memory usage limited (recommended)\n        tile_overlap: fraction of overlap of tiles when computing flows\n        resample: run dynamics at original image size (will be slower but\n            create more accurate boundaries)\n        interp: interpolate during 2D dynamics (not available in 3D)\n            (in previous versions it was False, now it defaults to True)\n        stitch_threshold: if stitch_threshold&gt;0.0 and not do_3D and equal\n            image sizes, masks are stitched in 3D to return volume segmentation\n    \"\"\"\n\n    # Write some debugging info\n    logger.info(\n        \"[segment_ROI] START |\"\n        f\" x: {type(x)}, {x.shape} |\"\n        f\" {do_3D=} |\"\n        f\" {model.diam_mean=} |\"\n        f\" {diameter=} |\"\n        f\" {flow_threshold=} |\"\n        f\" {normalize.type=}\"\n    )\n\n    # Optionally perform custom normalization\n    if normalize.type == \"custom\":\n        x = normalized_img(\n            x,\n            lower_p=normalize.lower_percentile,\n            upper_p=normalize.upper_percentile,\n            lower_bound=normalize.lower_bound,\n            upper_bound=normalize.upper_bound,\n        )\n\n    # Actual labeling\n    t0 = time.perf_counter()\n    mask, _, _ = model.eval(\n        x,\n        channels=channels,\n        do_3D=do_3D,\n        net_avg=net_avg,\n        augment=augment,\n        diameter=diameter,\n        anisotropy=anisotropy,\n        cellprob_threshold=cellprob_threshold,\n        flow_threshold=flow_threshold,\n        normalize=normalize.cellpose_normalize,\n        min_size=min_size,\n        batch_size=batch_size,\n        invert=invert,\n        tile=tile,\n        tile_overlap=tile_overlap,\n        resample=resample,\n        interp=interp,\n        stitch_threshold=stitch_threshold,\n    )\n\n    if mask.ndim == 2:\n        # If we get a 2D image, we still return it as a 3D array\n        mask = np.expand_dims(mask, axis=0)\n    t1 = time.perf_counter()\n\n    # Write some debugging info\n    logger.info(\n        \"[segment_ROI] END   |\"\n        f\" Elapsed: {t1-t0:.3f} s |\"\n        f\" {mask.shape=},\"\n        f\" {mask.dtype=} (then {label_dtype}),\"\n        f\" {np.max(mask)=} |\"\n        f\" {model.diam_mean=} |\"\n        f\" {diameter=} |\"\n        f\" {flow_threshold=}\"\n    )\n\n    return mask.astype(label_dtype)\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/cellpose_transforms/","title":"cellpose_transforms","text":"<p>Helper functions for image normalization in</p>"},{"location":"reference/fractal_tasks_core/tasks/cellpose_transforms/#fractal_tasks_core.tasks.cellpose_transforms.CellposeCustomNormalizer","title":"<code>CellposeCustomNormalizer</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Validator to handle different normalization scenarios for Cellpose models</p> <p>If <code>type=\"default\"</code>, then Cellpose default normalization is used and no other parameters can be specified. If <code>type=\"no_normalization\"</code>, then no normalization is used and no other parameters can be specified. If <code>type=\"custom\"</code>, then either percentiles or explicit integer bounds can be applied.</p> ATTRIBUTE DESCRIPTION <code>type</code> <p>One of <code>default</code> (Cellpose default normalization), <code>custom</code> (using the other custom parameters) or <code>no_normalization</code>.</p> <p> TYPE: <code>Literal['default', 'custom', 'no_normalization']</code> </p> <code>lower_percentile</code> <p>Specify a custom lower-bound percentile for rescaling as a float value between 0 and 100. Set to 1 to run the same as default). You can only specify percentiles or bounds, not both.</p> <p> TYPE: <code>Optional[float]</code> </p> <code>upper_percentile</code> <p>Specify a custom upper-bound percentile for rescaling as a float value between 0 and 100. Set to 99 to run the same as default, set to e.g. 99.99 if the default rescaling was too harsh. You can only specify percentiles or bounds, not both.</p> <p> TYPE: <code>Optional[float]</code> </p> <code>lower_bound</code> <p>Explicit lower bound value to rescale the image at. Needs to be an integer, e.g. 100. You can only specify percentiles or bounds, not both.</p> <p> TYPE: <code>Optional[int]</code> </p> <code>upper_bound</code> <p>Explicit upper bound value to rescale the image at. Needs to be an integer, e.g. 2000. You can only specify percentiles or bounds, not both.</p> <p> TYPE: <code>Optional[int]</code> </p> Source code in <code>fractal_tasks_core/tasks/cellpose_transforms.py</code> <pre><code>class CellposeCustomNormalizer(BaseModel):\n\"\"\"\n    Validator to handle different normalization scenarios for Cellpose models\n\n    If `type=\"default\"`, then Cellpose default normalization is\n    used and no other parameters can be specified.\n    If `type=\"no_normalization\"`, then no normalization is used and no\n    other parameters can be specified.\n    If `type=\"custom\"`, then either percentiles or explicit integer\n    bounds can be applied.\n\n    Attributes:\n        type:\n            One of `default` (Cellpose default normalization), `custom`\n            (using the other custom parameters) or `no_normalization`.\n        lower_percentile: Specify a custom lower-bound percentile for rescaling\n            as a float value between 0 and 100. Set to 1 to run the same as\n            default). You can only specify percentiles or bounds, not both.\n        upper_percentile: Specify a custom upper-bound percentile for rescaling\n            as a float value between 0 and 100. Set to 99 to run the same as\n            default, set to e.g. 99.99 if the default rescaling was too harsh.\n            You can only specify percentiles or bounds, not both.\n        lower_bound: Explicit lower bound value to rescale the image at.\n            Needs to be an integer, e.g. 100.\n            You can only specify percentiles or bounds, not both.\n        upper_bound: Explicit upper bound value to rescale the image at.\n            Needs to be an integer, e.g. 2000.\n            You can only specify percentiles or bounds, not both.\n    \"\"\"\n\n    type: Literal[\"default\", \"custom\", \"no_normalization\"] = \"default\"\n    lower_percentile: Optional[float] = Field(None, ge=0, le=100)\n    upper_percentile: Optional[float] = Field(None, ge=0, le=100)\n    lower_bound: Optional[int] = None\n    upper_bound: Optional[int] = None\n\n    # In the future, add an option to allow using precomputed percentiles\n    # that are stored in OME-Zarr histograms and use this pydantic model that\n    # those histograms actually exist\n\n    @root_validator\n    def validate_conditions(cls, values):\n        # Extract values\n        type = values.get(\"type\")\n        lower_percentile = values.get(\"lower_percentile\")\n        upper_percentile = values.get(\"upper_percentile\")\n        lower_bound = values.get(\"lower_bound\")\n        upper_bound = values.get(\"upper_bound\")\n\n        # Verify that custom parameters are only provided when type=\"custom\"\n        if type != \"custom\":\n            if lower_percentile is not None:\n                raise ValueError(\n                    f\"Type='{type}' but {lower_percentile=}. \"\n                    \"Hint: set type='custom'.\"\n                )\n            if upper_percentile is not None:\n                raise ValueError(\n                    f\"Type='{type}' but {upper_percentile=}. \"\n                    \"Hint: set type='custom'.\"\n                )\n            if lower_bound is not None:\n                raise ValueError(\n                    f\"Type='{type}' but {lower_bound=}. \"\n                    \"Hint: set type='custom'.\"\n                )\n            if upper_bound is not None:\n                raise ValueError(\n                    f\"Type='{type}' but {upper_bound=}. \"\n                    \"Hint: set type='custom'.\"\n                )\n\n        # The only valid options are:\n        # 1. Both percentiles are set and both bounds are unset\n        # 2. Both bounds are set and both percentiles are unset\n        are_percentiles_set = (\n            lower_percentile is not None,\n            upper_percentile is not None,\n        )\n        are_bounds_set = (\n            lower_bound is not None,\n            upper_bound is not None,\n        )\n        if len(set(are_percentiles_set)) != 1:\n            raise ValueError(\n                \"Both lower_percentile and upper_percentile must be set \"\n                \"together.\"\n            )\n        if len(set(are_bounds_set)) != 1:\n            raise ValueError(\n                \"Both lower_bound and upper_bound must be set together\"\n            )\n        if lower_percentile is not None and lower_bound is not None:\n            raise ValueError(\n                \"You cannot set both explicit bounds and percentile bounds \"\n                \"at the same time. Hint: use only one of the two options.\"\n            )\n\n        return values\n\n    @property\n    def cellpose_normalize(self) -&gt; bool:\n\"\"\"\n        Determine whether cellpose should apply its internal normalization.\n\n        If type is set to `custom` or `no_normalization`, don't apply cellpose\n        internal normalization\n        \"\"\"\n        return self.type == \"default\"\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/cellpose_transforms/#fractal_tasks_core.tasks.cellpose_transforms.CellposeCustomNormalizer.cellpose_normalize","title":"<code>cellpose_normalize: bool</code>  <code>property</code>","text":"<p>Determine whether cellpose should apply its internal normalization.</p> <p>If type is set to <code>custom</code> or <code>no_normalization</code>, don't apply cellpose internal normalization</p>"},{"location":"reference/fractal_tasks_core/tasks/cellpose_transforms/#fractal_tasks_core.tasks.cellpose_transforms.normalize_bounds","title":"<code>normalize_bounds(Y, lower=0, upper=65535)</code>","text":"<p>normalize image so 0.0 is lower value and 1.0 is upper value</p> PARAMETER  DESCRIPTION <code>Y</code> <p>The image to be normalized</p> <p> TYPE: <code>ndarray</code> </p> <code>lower</code> <p>Lower normalization value</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>upper</code> <p>Upper normalization value</p> <p> TYPE: <code>int</code> DEFAULT: <code>65535</code> </p> Source code in <code>fractal_tasks_core/tasks/cellpose_transforms.py</code> <pre><code>def normalize_bounds(Y: np.ndarray, lower: int = 0, upper: int = 65535):\n\"\"\"normalize image so 0.0 is lower value and 1.0 is upper value\n\n    Args:\n        Y: The image to be normalized\n        lower: Lower normalization value\n        upper: Upper normalization value\n\n    \"\"\"\n    X = Y.copy()\n    X = (X - lower) / (upper - lower)\n    return X\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/cellpose_transforms/#fractal_tasks_core.tasks.cellpose_transforms.normalize_percentile","title":"<code>normalize_percentile(Y, lower=1, upper=99)</code>","text":"<p>normalize image so 0.0 is lower percentile and 1.0 is upper percentile Percentiles are passed as floats (must be between 0 and 100)</p> PARAMETER  DESCRIPTION <code>Y</code> <p>The image to be normalized</p> <p> TYPE: <code>ndarray</code> </p> <code>lower</code> <p>Lower percentile</p> <p> TYPE: <code>float</code> DEFAULT: <code>1</code> </p> <code>upper</code> <p>Upper percentile</p> <p> TYPE: <code>float</code> DEFAULT: <code>99</code> </p> Source code in <code>fractal_tasks_core/tasks/cellpose_transforms.py</code> <pre><code>def normalize_percentile(Y: np.ndarray, lower: float = 1, upper: float = 99):\n\"\"\"normalize image so 0.0 is lower percentile and 1.0 is upper percentile\n    Percentiles are passed as floats (must be between 0 and 100)\n\n    Args:\n        Y: The image to be normalized\n        lower: Lower percentile\n        upper: Upper percentile\n\n    \"\"\"\n    X = Y.copy()\n    x01 = np.percentile(X, lower)\n    x99 = np.percentile(X, upper)\n    X = (X - x01) / (x99 - x01)\n    return X\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/cellpose_transforms/#fractal_tasks_core.tasks.cellpose_transforms.normalized_img","title":"<code>normalized_img(img, axis=-1, invert=False, lower_p=1.0, upper_p=99.0, lower_bound=None, upper_bound=None)</code>","text":"<p>normalize each channel of the image so that so that 0.0=lower percentile or lower bound and 1.0=upper percentile or upper bound of image intensities.</p> <p>The normalization can result in values &lt; 0 or &gt; 1 (no clipping).</p> <p>Based on https://github.com/MouseLand/cellpose/blob/4f5661983c3787efa443bbbd3f60256f4fd8bf53/cellpose/transforms.py#L375 # noqa E501</p> <p>optional inversion</p>"},{"location":"reference/fractal_tasks_core/tasks/cellpose_transforms/#fractal_tasks_core.tasks.cellpose_transforms.normalized_img--parameters","title":"Parameters","text":"<p>img: ND-array (at least 3 dimensions)</p> <p>axis: channel axis to loop over for normalization</p> <p>invert: invert image (useful if cells are dark instead of bright)</p> <p>lower_p: Lower percentile for rescaling</p> <p>upper_p: Upper percentile for rescaling</p> <p>lower_bound: Lower fixed-value used for rescaling</p> <p>upper_bound: Upper fixed-value used for rescaling</p>"},{"location":"reference/fractal_tasks_core/tasks/cellpose_transforms/#fractal_tasks_core.tasks.cellpose_transforms.normalized_img--returns","title":"Returns","text":"ND-array, float32 <p>normalized image of same size</p> Source code in <code>fractal_tasks_core/tasks/cellpose_transforms.py</code> <pre><code>def normalized_img(\n    img: np.ndarray,\n    axis: int = -1,\n    invert: bool = False,\n    lower_p: float = 1.0,\n    upper_p: float = 99.0,\n    lower_bound: Optional[int] = None,\n    upper_bound: Optional[int] = None,\n):\n\"\"\"normalize each channel of the image so that so that 0.0=lower percentile\n    or lower bound and 1.0=upper percentile or upper bound of image intensities.\n\n    The normalization can result in values &lt; 0 or &gt; 1 (no clipping).\n\n    Based on https://github.com/MouseLand/cellpose/blob/4f5661983c3787efa443bbbd3f60256f4fd8bf53/cellpose/transforms.py#L375 # noqa E501\n\n    optional inversion\n\n    Parameters\n    ------------\n\n    img: ND-array (at least 3 dimensions)\n\n    axis: channel axis to loop over for normalization\n\n    invert: invert image (useful if cells are dark instead of bright)\n\n    lower_p: Lower percentile for rescaling\n\n    upper_p: Upper percentile for rescaling\n\n    lower_bound: Lower fixed-value used for rescaling\n\n    upper_bound: Upper fixed-value used for rescaling\n\n    Returns\n    ---------------\n\n    img: ND-array, float32\n        normalized image of same size\n\n    \"\"\"\n    if img.ndim &lt; 3:\n        error_message = \"Image needs to have at least 3 dimensions\"\n        logger.critical(error_message)\n        raise ValueError(error_message)\n\n    img = img.astype(np.float32)\n    img = np.moveaxis(img, axis, 0)\n    for k in range(img.shape[0]):\n        if lower_p is not None:\n            # ptp can still give nan's with weird images\n            i99 = np.percentile(img[k], upper_p)\n            i1 = np.percentile(img[k], lower_p)\n            if i99 - i1 &gt; +1e-3:  # np.ptp(img[k]) &gt; 1e-3:\n                img[k] = normalize_percentile(\n                    img[k], lower=lower_p, upper=upper_p\n                )\n                if invert:\n                    img[k] = -1 * img[k] + 1\n            else:\n                img[k] = 0\n        elif lower_bound is not None:\n            if upper_bound - lower_bound &gt; +1e-3:\n                img[k] = normalize_bounds(\n                    img[k], lower=lower_bound, upper=upper_bound\n                )\n                if invert:\n                    img[k] = -1 * img[k] + 1\n            else:\n                img[k] = 0\n        else:\n            raise ValueError(\"No normalization method specified\")\n    img = np.moveaxis(img, 0, axis)\n    return img\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/compress_tif/","title":"compress_tif","text":"<p>Task to compress tiff images.</p> <p>This task cannot be used in the current form, and it should first be aligned with the other tasks' structure.</p>"},{"location":"reference/fractal_tasks_core/tasks/compress_tif/#fractal_tasks_core.tasks.compress_tif.compress_tif","title":"<code>compress_tif(in_path, out_path, delete_input=False)</code>","text":"<p>Compress tiff files.</p> PARAMETER  DESCRIPTION <code>in_path</code> <p>directory containing the input files.</p> <p> TYPE: <code>str</code> </p> <code>out_path</code> <p>directory containing the output files.</p> <p> TYPE: <code>str</code> </p> <code>delete_input</code> <p>delete input files.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>fractal_tasks_core/tasks/compress_tif.py</code> <pre><code>def compress_tif(in_path: str, out_path: str, delete_input: bool = False):\n\n\"\"\"\n    Compress tiff files.\n\n    Args:\n        in_path: directory containing the input files.\n        out_path: directory containing the output files.\n        delete_input: delete input files.\n    \"\"\"\n\n    # Sanitize input/output paths\n    if not in_path.endswith(\"/\"):\n        in_path += \"/\"\n    if not out_path.endswith(\"/\"):\n        out_path += \"/\"\n\n    # Create output path, if needed\n    if not os.path.exists(out_path):\n        os.makedirs(out_path)\n\n    num_img_compressed = 0\n    num_img_deleted = 0\n    for filename in glob.glob(in_path + \"*.tif\"):\n        newfilename = os.path.join(out_path, os.path.basename(filename))\n\n        # Save compressed image\n        with Image.open(filename) as image:\n            image.save(newfilename, format=\"tiff\", compression=\"tiff_lzw\")\n        print(f\"Raw:        {filename}\\nCompressed: {newfilename}\")\n        num_img_compressed += 1\n\n        # Delete raw image, if needed\n        if delete_input:\n            try:\n                os.remove(filename)\n                print(f\"Deleted:    {filename}\")\n                num_img_deleted += 1\n            except OSError as e:\n                print(\"ERROR: %s : %s\" % (filename, e.strerror))\n\n        print()\n\n    return num_img_compressed, num_img_deleted\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/copy_ome_zarr/","title":"copy_ome_zarr","text":"<p>Task that copies the structure of an OME-NGFF zarr array to a new one.</p>"},{"location":"reference/fractal_tasks_core/tasks/copy_ome_zarr/#fractal_tasks_core.tasks.copy_ome_zarr.copy_ome_zarr","title":"<code>copy_ome_zarr(*, input_paths, output_path, metadata, project_to_2D=True, suffix='mip', ROI_table_names=('FOV_ROI_table', 'well_ROI_table'), overwrite=False)</code>","text":"<p>Duplicate an input zarr structure to a new path.</p> <p>This task copies all the structure, but none of the image data:</p> <ul> <li>For each plate, create a new zarr group with the same attributes as    the original one.</li> <li>For each well (in each plate), create a new zarr subgroup with the    same attributes as the original one.</li> <li>For each image (in each well), create a new zarr subgroup with the    same attributes as the original one.</li> <li>For each image (in each well), copy the relevant AnnData tables from    the original source.</li> </ul> <p>Note: this task makes use of methods from the <code>Attributes</code> class, see https://zarr.readthedocs.io/en/stable/api/attrs.html.</p> PARAMETER  DESCRIPTION <code>input_paths</code> <p>List of input paths where the image data is stored as OME-Zarrs. Should point to the parent folder containing one or many OME-Zarr files, not the actual OME-Zarr file. Example: <code>[\"/some/path/\"]</code>. This task only supports a single input path. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>Sequence[str]</code> </p> <code>output_path</code> <p>Path were the output of this task is stored. Example: <code>\"/some/path/\"</code> =&gt; puts the new OME-Zarr file in the same folder as the input OME-Zarr file <code>\"/some/new_path\"</code> =&gt; puts the new OME-Zarr file into a new folder at <code>/some/new_path</code>. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>str</code> </p> <code>metadata</code> <p>Dictionary containing metadata about the OME-Zarr. This task requires the following elements to be present in the metadata: <code>plate</code>: List of plates (e.g. <code>[\"MyPlate.zarr\"]</code>); <code>well</code>: List of wells in the OME-Zarr plate (e.g. <code>[\"MyPlate.zarr/B/03/MyPlate.zarr/B/05\"]</code>); \"image\": List of images in the OME-Zarr plate (e.g. <code>[\"MyPlate.zarr/B/03/0\", \"MyPlate.zarr/B/05/0\"]</code>). standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>project_to_2D</code> <p>If <code>True</code>, apply a 3D-&gt;2D projection to the ROI tables that are copied to the new OME-Zarr.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>suffix</code> <p>The suffix that is used to transform <code>plate.zarr</code> into <code>plate_suffix.zarr</code>. Note that <code>None</code> is not currently supported.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'mip'</code> </p> <code>ROI_table_names</code> <p>List of Anndata table names to be copied. Note: copying non-ROI tables may fail if <code>project_to_2D=True</code>.</p> <p> TYPE: <code>tuple[str, ...]</code> DEFAULT: <code>('FOV_ROI_table', 'well_ROI_table')</code> </p> <code>overwrite</code> <p>If <code>True</code>, overwrite the task output.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>dict[str, Any]</code> <p>An update to the metadata table with new <code>plate</code>, <code>well</code>, <code>image</code> entries (now with the suffix in the plate name).</p> Source code in <code>fractal_tasks_core/tasks/copy_ome_zarr.py</code> <pre><code>@validate_arguments\ndef copy_ome_zarr(\n    *,\n    input_paths: Sequence[str],\n    output_path: str,\n    metadata: dict[str, Any],\n    project_to_2D: bool = True,\n    suffix: str = \"mip\",\n    ROI_table_names: tuple[str, ...] = (\"FOV_ROI_table\", \"well_ROI_table\"),\n    overwrite: bool = False,\n) -&gt; dict[str, Any]:\n\n\"\"\"\n    Duplicate an input zarr structure to a new path.\n\n    This task copies all the structure, but none of the image data:\n\n    - For each plate, create a new zarr group with the same attributes as\n       the original one.\n    - For each well (in each plate), create a new zarr subgroup with the\n       same attributes as the original one.\n    - For each image (in each well), create a new zarr subgroup with the\n       same attributes as the original one.\n    - For each image (in each well), copy the relevant AnnData tables from\n       the original source.\n\n    Note: this task makes use of methods from the `Attributes` class, see\n    https://zarr.readthedocs.io/en/stable/api/attrs.html.\n\n    Args:\n        input_paths: List of input paths where the image data is stored as\n            OME-Zarrs. Should point to the parent folder containing one or many\n            OME-Zarr files, not the actual OME-Zarr file. Example:\n            `[\"/some/path/\"]`. This task only supports a single input path.\n            (standard argument for Fractal tasks, managed by Fractal server).\n        output_path: Path were the output of this task is stored. Example:\n            `\"/some/path/\"` =&gt; puts the new OME-Zarr file in the same folder as\n            the input OME-Zarr file `\"/some/new_path\"` =&gt; puts the new OME-Zarr\n            file into a new folder at `/some/new_path`. (standard argument for\n            Fractal tasks, managed by Fractal server).\n        metadata: Dictionary containing metadata about the OME-Zarr. This task\n            requires the following elements to be present in the metadata:\n            `plate`: List of plates\n            (e.g. `[\"MyPlate.zarr\"]`);\n            `well`: List of wells in the OME-Zarr plate\n            (e.g. `[\"MyPlate.zarr/B/03/MyPlate.zarr/B/05\"]`);\n            \"image\": List of images in the OME-Zarr plate\n            (e.g. `[\"MyPlate.zarr/B/03/0\", \"MyPlate.zarr/B/05/0\"]`).\n            standard argument for Fractal tasks, managed by Fractal server).\n        project_to_2D: If `True`, apply a 3D-&gt;2D projection to the ROI tables\n            that are copied to the new OME-Zarr.\n        suffix: The suffix that is used to transform `plate.zarr` into\n            `plate_suffix.zarr`. Note that `None` is not currently supported.\n        ROI_table_names: List of Anndata table names to be copied. Note:\n            copying non-ROI tables may fail if `project_to_2D=True`.\n        overwrite: If `True`, overwrite the task output.\n\n    Returns:\n        An update to the metadata table with new `plate`, `well`, `image`\n            entries (now with the suffix in the plate name).\n    \"\"\"\n\n    # Preliminary check\n    if len(input_paths) &gt; 1:\n        raise NotImplementedError\n    if suffix is None:\n        # FIXME create a standard suffix (with timestamp)\n        raise NotImplementedError\n\n    # List all plates\n    in_path = Path(input_paths[0])\n    list_plates = [\n        p.as_posix()\n        for p in Path(in_path).glob(\"*.zarr\")\n        if p.name in metadata[\"plate\"]\n    ]\n    logger.info(f\"{list_plates=}\")\n\n    meta_update: dict[str, Any] = {\"copy_ome_zarr\": {}}\n    meta_update[\"copy_ome_zarr\"][\"suffix\"] = suffix\n    meta_update[\"copy_ome_zarr\"][\"sources\"] = {}\n\n    # Loop over all plates\n    for zarrurl_old in list_plates:\n        zarrfile = zarrurl_old.split(\"/\")[-1]\n        old_plate_name = zarrfile.split(\".zarr\")[0]\n        new_plate_name = f\"{old_plate_name}_{suffix}\"\n        new_plate_dir = Path(output_path).resolve()\n        zarrurl_new = f\"{(new_plate_dir / new_plate_name).as_posix()}.zarr\"\n        meta_update[\"copy_ome_zarr\"][\"sources\"][new_plate_name] = zarrurl_old\n\n        logger.info(f\"{zarrurl_old=}\")\n        logger.info(f\"{zarrurl_new=}\")\n        logger.info(f\"{meta_update=}\")\n\n        # Replicate plate attrs\n        old_plate_group = zarr.open_group(zarrurl_old, mode=\"r\")\n        new_plate_group = open_zarr_group_with_overwrite(\n            zarrurl_new, overwrite=overwrite\n        )\n        new_plate_group.attrs.put(old_plate_group.attrs.asdict())\n\n        well_paths = [\n            well[\"path\"] for well in new_plate_group.attrs[\"plate\"][\"wells\"]\n        ]\n        logger.info(f\"{well_paths=}\")\n        for well_path in well_paths:\n\n            # Replicate well attrs\n            old_well_group = zarr.open_group(\n                f\"{zarrurl_old}/{well_path}\", mode=\"r\"\n            )\n            new_well_group = zarr.group(f\"{zarrurl_new}/{well_path}\")\n            new_well_group.attrs.put(old_well_group.attrs.asdict())\n\n            image_paths = [\n                image[\"path\"]\n                for image in new_well_group.attrs[\"well\"][\"images\"]\n            ]\n            logger.info(f\"{image_paths=}\")\n\n            for image_path in image_paths:\n\n                # Replicate image attrs\n                old_image_group = zarr.open_group(\n                    f\"{zarrurl_old}/{well_path}/{image_path}\", mode=\"r\"\n                )\n                new_image_group = zarr.group(\n                    f\"{zarrurl_new}/{well_path}/{image_path}\"\n                )\n                new_image_group.attrs.put(old_image_group.attrs.asdict())\n\n                # Extract pixel sizes, if needed\n                if ROI_table_names:\n\n                    if project_to_2D:\n                        path_image = f\"{zarrurl_old}/{well_path}/{image_path}\"\n                        ngff_image_meta = load_NgffImageMeta(path_image)\n                        pxl_sizes_zyx = ngff_image_meta.get_pixel_sizes_zyx(\n                            level=0\n                        )\n                        pxl_size_z = pxl_sizes_zyx[0]\n\n                    # Copy the tables in ROI_table_names\n                    for ROI_table_name in ROI_table_names:\n\n                        logger.info(\n                            f\"I will now read {ROI_table_name} from \"\n                            f\"{zarrurl_old=}, convert it to 2D, and \"\n                            \"write it back to the new zarr file.\"\n                        )\n                        new_ROI_table = ad.read_zarr(\n                            f\"{zarrurl_old}/{well_path}/{image_path}/\"\n                            f\"tables/{ROI_table_name}\"\n                        )\n                        old_ROI_table_attrs = zarr.open_group(\n                            f\"{zarrurl_old}/{well_path}/{image_path}/\"\n                            f\"tables/{ROI_table_name}\"\n                        ).attrs.asdict()\n                        # Convert 3D ROIs to 2D\n                        if project_to_2D:\n                            new_ROI_table = convert_ROIs_from_3D_to_2D(\n                                new_ROI_table, pxl_size_z\n                            )\n                        # Write new table\n                        write_table(\n                            new_image_group,\n                            ROI_table_name,\n                            new_ROI_table,\n                            table_attrs=old_ROI_table_attrs,\n                        )\n\n    for key in [\"plate\", \"well\", \"image\"]:\n        meta_update[key] = [\n            component.replace(\".zarr\", f\"_{suffix}.zarr\")\n            for component in metadata[key]\n        ]\n\n    return meta_update\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/create_ome_zarr/","title":"create_ome_zarr","text":"<p>Create structure for OME-NGFF zarr array.</p>"},{"location":"reference/fractal_tasks_core/tasks/create_ome_zarr/#fractal_tasks_core.tasks.create_ome_zarr.create_ome_zarr","title":"<code>create_ome_zarr(*, input_paths, output_path, metadata, allowed_channels, image_glob_patterns=None, num_levels=5, coarsening_xy=2, image_extension='tif', metadata_table_file=None, overwrite=False)</code>","text":"<p>Create a OME-NGFF zarr folder, without reading/writing image data.</p> <p>Find plates (for each folder in input_paths):</p> <ul> <li>glob image files,</li> <li>parse metadata from image filename to identify plates,</li> <li>identify populated channels.</li> </ul> <p>Create a zarr folder (for each plate):</p> <ul> <li>parse mlf metadata,</li> <li>identify wells and field of view (FOV),</li> <li>create FOV ZARR,</li> <li>verify that channels are uniform (i.e., same channels).</li> </ul> PARAMETER  DESCRIPTION <code>input_paths</code> <p>List of input paths where the image data from the microscope is stored (as TIF or PNG).  Should point to the parent folder containing the images and the metadata files <code>MeasurementData.mlf</code> and <code>MeasurementDetail.mrf</code> (if present). Example: <code>[\"/some/path/\"]</code>. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>Sequence[str]</code> </p> <code>output_path</code> <p>Path were the output of this task is stored. Example: \"/some/path/\" =&gt; puts the new OME-Zarr file in the \"/some/path/\". (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>str</code> </p> <code>metadata</code> <p>This parameter is not used by this task. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>allowed_channels</code> <p>A list of <code>OmeroChannel</code> s, where each channel must include the <code>wavelength_id</code> attribute and where the <code>wavelength_id</code> values must be unique across the list.</p> <p> TYPE: <code>list[OmeroChannel]</code> </p> <code>image_glob_patterns</code> <p>If specified, only parse images with filenames that match with all these patterns. Patterns must be defined as in https://docs.python.org/3/library/fnmatch.html, Example: <code>image_glob_pattern=[\"*_B03_*\"]</code> =&gt; only process well B03 <code>image_glob_pattern=[\"*_C09_*\", \"*F016*\", \"*Z[0-5][0-9]C*\"]</code> =&gt; only process well C09, field of view 16 and Z planes 0-59.</p> <p> TYPE: <code>Optional[list[str]]</code> DEFAULT: <code>None</code> </p> <code>num_levels</code> <p>Number of resolution-pyramid levels. If set to <code>5</code>, there will be the full-resolution level and 4 levels of downsampled images.</p> <p> TYPE: <code>int</code> DEFAULT: <code>5</code> </p> <code>coarsening_xy</code> <p>Linear coarsening factor between subsequent levels. If set to <code>2</code>, level 1 is 2x downsampled, level 2 is 4x downsampled etc.</p> <p> TYPE: <code>int</code> DEFAULT: <code>2</code> </p> <code>image_extension</code> <p>Filename extension of images (e.g. <code>\"tif\"</code> or <code>\"png\"</code>)</p> <p> TYPE: <code>str</code> DEFAULT: <code>'tif'</code> </p> <code>metadata_table_file</code> <p>If <code>None</code>, parse Yokogawa metadata from mrf/mlf files in the input_path folder; else, the full path to a csv file containing the parsed metadata table.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>overwrite</code> <p>If <code>True</code>, overwrite the task output.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>dict[str, Any]</code> <p>A metadata dictionary containing important metadata about the OME-Zarr plate, the images and some parameters required by downstream tasks (like <code>num_levels</code>).</p> Source code in <code>fractal_tasks_core/tasks/create_ome_zarr.py</code> <pre><code>@validate_arguments\ndef create_ome_zarr(\n    *,\n    input_paths: Sequence[str],\n    output_path: str,\n    metadata: dict[str, Any],\n    allowed_channels: list[OmeroChannel],\n    image_glob_patterns: Optional[list[str]] = None,\n    num_levels: int = 5,\n    coarsening_xy: int = 2,\n    image_extension: str = \"tif\",\n    metadata_table_file: Optional[str] = None,\n    overwrite: bool = False,\n) -&gt; dict[str, Any]:\n\"\"\"\n    Create a OME-NGFF zarr folder, without reading/writing image data.\n\n    Find plates (for each folder in input_paths):\n\n    - glob image files,\n    - parse metadata from image filename to identify plates,\n    - identify populated channels.\n\n    Create a zarr folder (for each plate):\n\n    - parse mlf metadata,\n    - identify wells and field of view (FOV),\n    - create FOV ZARR,\n    - verify that channels are uniform (i.e., same channels).\n\n    Args:\n        input_paths: List of input paths where the image data from\n            the microscope is stored (as TIF or PNG).  Should point to the\n            parent folder containing the images and the metadata files\n            `MeasurementData.mlf` and `MeasurementDetail.mrf` (if present).\n            Example: `[\"/some/path/\"]`.\n            (standard argument for Fractal tasks, managed by Fractal server).\n        output_path: Path were the output of this task is stored.\n            Example: \"/some/path/\" =&gt; puts the new OME-Zarr file in the\n            \"/some/path/\".\n            (standard argument for Fractal tasks, managed by Fractal server).\n        metadata: This parameter is not used by this task.\n            (standard argument for Fractal tasks, managed by Fractal server).\n        allowed_channels: A list of `OmeroChannel` s, where each channel must\n            include the `wavelength_id` attribute and where the\n            `wavelength_id` values must be unique across the list.\n        image_glob_patterns: If specified, only parse images with filenames\n            that match with all these patterns. Patterns must be defined as in\n            https://docs.python.org/3/library/fnmatch.html, Example:\n            `image_glob_pattern=[\"*_B03_*\"]` =&gt; only process well B03\n            `image_glob_pattern=[\"*_C09_*\", \"*F016*\", \"*Z[0-5][0-9]C*\"]` =&gt;\n            only process well C09, field of view 16 and Z planes 0-59.\n        num_levels: Number of resolution-pyramid levels. If set to `5`, there\n            will be the full-resolution level and 4 levels of\n            downsampled images.\n        coarsening_xy: Linear coarsening factor between subsequent levels.\n            If set to `2`, level 1 is 2x downsampled, level 2 is\n            4x downsampled etc.\n        image_extension: Filename extension of images (e.g. `\"tif\"` or `\"png\"`)\n        metadata_table_file: If `None`, parse Yokogawa metadata from mrf/mlf\n            files in the input_path folder; else, the full path to a csv file\n            containing the parsed metadata table.\n        overwrite: If `True`, overwrite the task output.\n\n    Returns:\n        A metadata dictionary containing important metadata about the OME-Zarr\n            plate, the images and some parameters required by downstream tasks\n            (like `num_levels`).\n    \"\"\"\n\n    # Preliminary checks on metadata_table_file\n    if metadata_table_file:\n        if not metadata_table_file.endswith(\".csv\"):\n            raise ValueError(f\"{metadata_table_file=} is not a csv file\")\n        if not os.path.isfile(metadata_table_file):\n            raise FileNotFoundError(f\"{metadata_table_file=} does not exist\")\n\n    # Identify all plates and all channels, across all input folders\n    plates = []\n    actual_wavelength_ids = None\n    dict_plate_paths = {}\n    dict_plate_prefixes: dict[str, Any] = {}\n\n    # Preliminary checks on allowed_channels argument\n    check_unique_wavelength_ids(allowed_channels)\n\n    for in_path_str in input_paths:\n        in_path = Path(in_path_str)\n\n        # Glob image filenames\n        patterns = [f\"*.{image_extension}\"]\n        if image_glob_patterns:\n            patterns.extend(image_glob_patterns)\n        input_filenames = glob_with_multiple_patterns(\n            folder=in_path_str,\n            patterns=patterns,\n        )\n\n        tmp_wavelength_ids = []\n        tmp_plates = []\n        for fn in input_filenames:\n            try:\n                filename_metadata = parse_filename(Path(fn).name)\n                plate_prefix = filename_metadata[\"plate_prefix\"]\n                plate = filename_metadata[\"plate\"]\n                if plate not in dict_plate_prefixes.keys():\n                    dict_plate_prefixes[plate] = plate_prefix\n                tmp_plates.append(plate)\n                A = filename_metadata[\"A\"]\n                C = filename_metadata[\"C\"]\n                tmp_wavelength_ids.append(f\"A{A}_C{C}\")\n            except ValueError as e:\n                logger.warning(\n                    f'Skipping \"{Path(fn).name}\". Original error: ' + str(e)\n                )\n        tmp_plates = sorted(list(set(tmp_plates)))\n        tmp_wavelength_ids = sorted(list(set(tmp_wavelength_ids)))\n\n        info = (\n            \"Listing plates/channels:\\n\"\n            f\"Folder:   {in_path_str}\\n\"\n            f\"Patterns: {patterns}\\n\"\n            f\"Plates:   {tmp_plates}\\n\"\n            f\"Channels: {tmp_wavelength_ids}\\n\"\n        )\n\n        # Check that only one plate is found\n        if len(tmp_plates) &gt; 1:\n            raise ValueError(f\"{info}ERROR: {len(tmp_plates)} plates detected\")\n        elif len(tmp_plates) == 0:\n            raise ValueError(f\"{info}ERROR: No plates detected\")\n        plate = tmp_plates[0]\n\n        # If plate already exists in other folder, add suffix\n        if plate in plates:\n            ind = 1\n            new_plate = f\"{plate}_{ind}\"\n            while new_plate in plates:\n                new_plate = f\"{plate}_{ind}\"\n                ind += 1\n            logger.info(\n                f\"WARNING: {plate} already exists, renaming it as {new_plate}\"\n            )\n            plates.append(new_plate)\n            dict_plate_prefixes[new_plate] = dict_plate_prefixes[plate]\n            plate = new_plate\n        else:\n            plates.append(plate)\n\n        # Check that channels are the same as in previous plates\n        if actual_wavelength_ids is None:\n            actual_wavelength_ids = tmp_wavelength_ids[:]\n        else:\n            if actual_wavelength_ids != tmp_wavelength_ids:\n                raise ValueError(\n                    f\"ERROR\\n{info}\\nERROR:\"\n                    f\" expected channels {actual_wavelength_ids}\"\n                )\n\n        # Update dict_plate_paths\n        dict_plate_paths[plate] = in_path\n\n    # Check that all channels are in the allowed_channels\n    allowed_wavelength_ids = [\n        channel.wavelength_id for channel in allowed_channels\n    ]\n    if not set(actual_wavelength_ids).issubset(set(allowed_wavelength_ids)):\n        msg = \"ERROR in create_ome_zarr\\n\"\n        msg += f\"actual_wavelength_ids: {actual_wavelength_ids}\\n\"\n        msg += f\"allowed_wavelength_ids: {allowed_wavelength_ids}\\n\"\n        raise ValueError(msg)\n\n    # Create actual_channels, i.e. a list of the channel dictionaries which are\n    # present\n    actual_channels = [\n        channel\n        for channel in allowed_channels\n        if channel.wavelength_id in actual_wavelength_ids\n    ]\n\n    zarrurls: dict[str, list[str]] = {\"plate\": [], \"well\": [], \"image\": []}\n\n    ################################################################\n    for plate in plates:\n        # Define plate zarr\n        zarrurl = f\"{plate}.zarr\"\n        in_path = dict_plate_paths[plate]\n        logger.info(f\"Creating {zarrurl}\")\n        # Call zarr.open_group wrapper, which handles overwrite=True/False\n        group_plate = open_zarr_group_with_overwrite(\n            str(Path(output_path) / zarrurl),\n            overwrite=overwrite,\n        )\n        zarrurls[\"plate\"].append(zarrurl)\n\n        # Obtain FOV-metadata dataframe\n\n        if metadata_table_file is None:\n            mrf_path = f\"{in_path}/MeasurementDetail.mrf\"\n            mlf_path = f\"{in_path}/MeasurementData.mlf\"\n\n            site_metadata, number_images_mlf = parse_yokogawa_metadata(\n                mrf_path,\n                mlf_path,\n                filename_patterns=image_glob_patterns,\n            )\n            site_metadata = remove_FOV_overlaps(site_metadata)\n\n        # If a metadata table was passed, load it and use it directly\n        else:\n            logger.warning(\n                \"Since a custom metadata table was provided, there will \"\n                \"be no additional check on the number of image files.\"\n            )\n            site_metadata = pd.read_csv(metadata_table_file)\n            site_metadata.set_index([\"well_id\", \"FieldIndex\"], inplace=True)\n\n        # Extract pixel sizes and bit_depth\n        pixel_size_z = site_metadata[\"pixel_size_z\"][0]\n        pixel_size_y = site_metadata[\"pixel_size_y\"][0]\n        pixel_size_x = site_metadata[\"pixel_size_x\"][0]\n        bit_depth = site_metadata[\"bit_depth\"][0]\n\n        if min(pixel_size_z, pixel_size_y, pixel_size_x) &lt; 1e-9:\n            raise ValueError(pixel_size_z, pixel_size_y, pixel_size_x)\n\n        # Identify all wells\n        plate_prefix = dict_plate_prefixes[plate]\n\n        patterns = [f\"{plate_prefix}_*.{image_extension}\"]\n        if image_glob_patterns:\n            patterns.extend(image_glob_patterns)\n        plate_images = glob_with_multiple_patterns(\n            folder=str(in_path), patterns=patterns\n        )\n\n        wells = [\n            parse_filename(os.path.basename(fn))[\"well\"] for fn in plate_images\n        ]\n        wells = sorted(list(set(wells)))\n\n        # Verify that all wells have all channels\n        for well in wells:\n            patterns = [f\"{plate_prefix}_{well}_*.{image_extension}\"]\n            if image_glob_patterns:\n                patterns.extend(image_glob_patterns)\n            well_images = glob_with_multiple_patterns(\n                folder=str(in_path), patterns=patterns\n            )\n\n            # Check number of images matches with expected one\n            if metadata_table_file is None:\n                num_images_glob = len(well_images)\n                num_images_expected = number_images_mlf[well]\n                if num_images_glob != num_images_expected:\n                    raise ValueError(\n                        f\"Wrong number of images for {well=}\\n\"\n                        f\"Expected {num_images_expected} (from mlf file)\\n\"\n                        f\"Found {num_images_glob} files\\n\"\n                        \"Other parameters:\\n\"\n                        f\"  {image_extension=}\\n\"\n                        f\"  {image_glob_patterns=}\"\n                    )\n\n            well_wavelength_ids = []\n            for fpath in well_images:\n                try:\n                    filename_metadata = parse_filename(os.path.basename(fpath))\n                    well_wavelength_ids.append(\n                        f\"A{filename_metadata['A']}_C{filename_metadata['C']}\"\n                    )\n                except IndexError:\n                    logger.info(f\"Skipping {fpath}\")\n            well_wavelength_ids = sorted(list(set(well_wavelength_ids)))\n            if well_wavelength_ids != actual_wavelength_ids:\n                raise ValueError(\n                    f\"ERROR: well {well} in plate {plate} (prefix: \"\n                    f\"{plate_prefix}) has missing channels.\\n\"\n                    f\"Expected: {actual_channels}\\n\"\n                    f\"Found: {well_wavelength_ids}.\\n\"\n                )\n\n        well_rows_columns = [\n            ind for ind in sorted([(n[0], n[1:]) for n in wells])\n        ]\n        row_list = [\n            well_row_column[0] for well_row_column in well_rows_columns\n        ]\n        col_list = [\n            well_row_column[1] for well_row_column in well_rows_columns\n        ]\n        row_list = sorted(list(set(row_list)))\n        col_list = sorted(list(set(col_list)))\n\n        group_plate.attrs[\"plate\"] = {\n            \"acquisitions\": [{\"id\": 0, \"name\": plate}],\n            \"columns\": [{\"name\": col} for col in col_list],\n            \"rows\": [{\"name\": row} for row in row_list],\n            \"wells\": [\n                {\n                    \"path\": well_row_column[0] + \"/\" + well_row_column[1],\n                    \"rowIndex\": row_list.index(well_row_column[0]),\n                    \"columnIndex\": col_list.index(well_row_column[1]),\n                }\n                for well_row_column in well_rows_columns\n            ],\n        }\n\n        for row, column in well_rows_columns:\n\n            group_well = group_plate.create_group(f\"{row}/{column}/\")\n\n            group_well.attrs[\"well\"] = {\n                \"images\": [{\"path\": \"0\"}],\n                \"version\": __OME_NGFF_VERSION__,\n            }\n\n            group_image = group_well.create_group(\"0/\")  # noqa: F841\n            zarrurls[\"well\"].append(f\"{plate}.zarr/{row}/{column}/\")\n            zarrurls[\"image\"].append(f\"{plate}.zarr/{row}/{column}/0/\")\n\n            group_image.attrs[\"multiscales\"] = [\n                {\n                    \"version\": __OME_NGFF_VERSION__,\n                    \"axes\": [\n                        {\"name\": \"c\", \"type\": \"channel\"},\n                        {\n                            \"name\": \"z\",\n                            \"type\": \"space\",\n                            \"unit\": \"micrometer\",\n                        },\n                        {\n                            \"name\": \"y\",\n                            \"type\": \"space\",\n                            \"unit\": \"micrometer\",\n                        },\n                        {\n                            \"name\": \"x\",\n                            \"type\": \"space\",\n                            \"unit\": \"micrometer\",\n                        },\n                    ],\n                    \"datasets\": [\n                        {\n                            \"path\": f\"{ind_level}\",\n                            \"coordinateTransformations\": [\n                                {\n                                    \"type\": \"scale\",\n                                    \"scale\": [\n                                        1,\n                                        pixel_size_z,\n                                        pixel_size_y\n                                        * coarsening_xy**ind_level,\n                                        pixel_size_x\n                                        * coarsening_xy**ind_level,\n                                    ],\n                                }\n                            ],\n                        }\n                        for ind_level in range(num_levels)\n                    ],\n                }\n            ]\n\n            group_image.attrs[\"omero\"] = {\n                \"id\": 1,  # FIXME does this depend on the plate number?\n                \"name\": \"TBD\",\n                \"version\": __OME_NGFF_VERSION__,\n                \"channels\": define_omero_channels(\n                    channels=actual_channels, bit_depth=bit_depth\n                ),\n            }\n\n            # Prepare AnnData tables for FOV/well ROIs\n            well_id = row + column\n            FOV_ROIs_table = prepare_FOV_ROI_table(site_metadata.loc[well_id])\n            well_ROIs_table = prepare_well_ROI_table(\n                site_metadata.loc[well_id]\n            )\n\n            # Write AnnData tables into the `tables` zarr group\n            write_table(\n                group_image,\n                \"FOV_ROI_table\",\n                FOV_ROIs_table,\n                overwrite=overwrite,\n                table_attrs={\"type\": \"roi_table\"},\n            )\n            write_table(\n                group_image,\n                \"well_ROI_table\",\n                well_ROIs_table,\n                overwrite=overwrite,\n                table_attrs={\"type\": \"roi_table\"},\n            )\n\n    # Check that the different images in each well have unique channel labels.\n    # Since we currently merge all fields of view in the same image, this check\n    # is useless. It should remain there to catch an error in case we switch\n    # back to one-image-per-field-of-view mode\n    for well_path in zarrurls[\"well\"]:\n        check_well_channel_labels(\n            well_zarr_path=str(Path(output_path) / well_path)\n        )\n\n    metadata_update = dict(\n        plate=zarrurls[\"plate\"],\n        well=zarrurls[\"well\"],\n        image=zarrurls[\"image\"],\n        num_levels=num_levels,\n        coarsening_xy=coarsening_xy,\n        image_extension=image_extension,\n        image_glob_patterns=image_glob_patterns,\n        original_paths=input_paths[:],\n    )\n    return metadata_update\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/create_ome_zarr_multiplex/","title":"create_ome_zarr_multiplex","text":"<p>Create OME-NGFF zarr group, for multiplexing dataset.</p>"},{"location":"reference/fractal_tasks_core/tasks/create_ome_zarr_multiplex/#fractal_tasks_core.tasks.create_ome_zarr_multiplex.create_ome_zarr_multiplex","title":"<code>create_ome_zarr_multiplex(*, input_paths, output_path, metadata, allowed_channels, image_glob_patterns=None, num_levels=5, coarsening_xy=2, image_extension='tif', metadata_table_files=None, overwrite=False)</code>","text":"<p>Create OME-NGFF structure and metadata to host a multiplexing dataset.</p> <p>This task takes a set of image folders (i.e. different acquisition cycles) and build the internal structure and metadata of a OME-NGFF zarr group, without actually loading/writing the image data.</p> <p>Each element in input_paths should be treated as a different acquisition.</p> PARAMETER  DESCRIPTION <code>input_paths</code> <p>List of input paths where the image data from the microscope is stored (as TIF or PNG).  Each element of the list is treated as another cycle of the multiplexing data, the cycles are ordered by their order in this list.  Should point to the parent folder containing the images and the metadata files <code>MeasurementData.mlf</code> and <code>MeasurementDetail.mrf</code> (if present). Example: <code>[\"/path/cycle1/\", \"/path/cycle2/\"]</code>. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>Sequence[str]</code> </p> <code>output_path</code> <p>Path were the output of this task is stored. Example: <code>\"/some/path/\"</code> =&gt; puts the new OME-Zarr file in the <code>/some/path/</code>. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>str</code> </p> <code>metadata</code> <p>This parameter is not used by this task. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>allowed_channels</code> <p>A dictionary of lists of <code>OmeroChannel</code>s, where each channel must include the <code>wavelength_id</code> attribute and where the <code>wavelength_id</code> values must be unique across each list. Dictionary keys represent channel indices (<code>\"0\",\"1\",..</code>).</p> <p> TYPE: <code>dict[str, list[OmeroChannel]]</code> </p> <code>image_glob_patterns</code> <p>If specified, only parse images with filenames that match with all these patterns. Patterns must be defined as in https://docs.python.org/3/library/fnmatch.html, Example: <code>image_glob_pattern=[\"*_B03_*\"]</code> =&gt; only process well B03 <code>image_glob_pattern=[\"*_C09_*\", \"*F016*\", \"*Z[0-5][0-9]C*\"]</code> =&gt; only process well C09, field of view 16 and Z planes 0-59.</p> <p> TYPE: <code>Optional[list[str]]</code> DEFAULT: <code>None</code> </p> <code>num_levels</code> <p>Number of resolution-pyramid levels. If set to <code>5</code>, there will be the full-resolution level and 4 levels of downsampled images.</p> <p> TYPE: <code>int</code> DEFAULT: <code>5</code> </p> <code>coarsening_xy</code> <p>Linear coarsening factor between subsequent levels. If set to <code>2</code>, level 1 is 2x downsampled, level 2 is 4x downsampled etc.</p> <p> TYPE: <code>int</code> DEFAULT: <code>2</code> </p> <code>image_extension</code> <p>Filename extension of images (e.g. <code>\"tif\"</code> or <code>\"png\"</code>).</p> <p> TYPE: <code>str</code> DEFAULT: <code>'tif'</code> </p> <code>metadata_table_files</code> <p>If <code>None</code>, parse Yokogawa metadata from mrf/mlf files in the input_path folder; else, a dictionary of key-value pairs like <code>(acquisition, path)</code> with <code>acquisition</code> a string and <code>path</code> pointing to a csv file containing the parsed metadata table.</p> <p> TYPE: <code>Optional[dict[str, str]]</code> DEFAULT: <code>None</code> </p> <code>overwrite</code> <p>If <code>True</code>, overwrite the task output.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>dict[str, Any]</code> <p>A metadata dictionary containing important metadata about the OME-Zarr plate, the images and some parameters required by downstream tasks (like <code>num_levels</code>).</p> Source code in <code>fractal_tasks_core/tasks/create_ome_zarr_multiplex.py</code> <pre><code>@validate_arguments\ndef create_ome_zarr_multiplex(\n    *,\n    input_paths: Sequence[str],\n    output_path: str,\n    metadata: dict[str, Any],\n    allowed_channels: dict[str, list[OmeroChannel]],\n    image_glob_patterns: Optional[list[str]] = None,\n    num_levels: int = 5,\n    coarsening_xy: int = 2,\n    image_extension: str = \"tif\",\n    metadata_table_files: Optional[dict[str, str]] = None,\n    overwrite: bool = False,\n) -&gt; dict[str, Any]:\n\"\"\"\n    Create OME-NGFF structure and metadata to host a multiplexing dataset.\n\n    This task takes a set of image folders (i.e. different acquisition cycles)\n    and build the internal structure and metadata of a OME-NGFF zarr group,\n    without actually loading/writing the image data.\n\n    Each element in input_paths should be treated as a different acquisition.\n\n    Args:\n        input_paths: List of input paths where the image data from the\n            microscope is stored (as TIF or PNG).  Each element of the list is\n            treated as another cycle of the multiplexing data, the cycles are\n            ordered by their order in this list.  Should point to the parent\n            folder containing the images and the metadata files\n            `MeasurementData.mlf` and `MeasurementDetail.mrf` (if present).\n            Example: `[\"/path/cycle1/\", \"/path/cycle2/\"]`. (standard argument\n            for Fractal tasks, managed by Fractal server).\n        output_path: Path were the output of this task is stored.\n            Example: `\"/some/path/\"` =&gt; puts the new OME-Zarr file in the\n            `/some/path/`.\n            (standard argument for Fractal tasks, managed by Fractal server).\n        metadata: This parameter is not used by this task.\n            (standard argument for Fractal tasks, managed by Fractal server).\n        allowed_channels: A dictionary of lists of `OmeroChannel`s, where\n            each channel must include the `wavelength_id` attribute and where\n            the `wavelength_id` values must be unique across each list.\n            Dictionary keys represent channel indices (`\"0\",\"1\",..`).\n        image_glob_patterns: If specified, only parse images with filenames\n            that match with all these patterns. Patterns must be defined as in\n            https://docs.python.org/3/library/fnmatch.html, Example:\n            `image_glob_pattern=[\"*_B03_*\"]` =&gt; only process well B03\n            `image_glob_pattern=[\"*_C09_*\", \"*F016*\", \"*Z[0-5][0-9]C*\"]` =&gt;\n            only process well C09, field of view 16 and Z planes 0-59.\n        num_levels: Number of resolution-pyramid levels. If set to `5`, there\n            will be the full-resolution level and 4 levels of downsampled\n            images.\n        coarsening_xy: Linear coarsening factor between subsequent levels.\n            If set to `2`, level 1 is 2x downsampled, level 2 is 4x downsampled\n            etc.\n        image_extension: Filename extension of images\n            (e.g. `\"tif\"` or `\"png\"`).\n        metadata_table_files: If `None`, parse Yokogawa metadata from mrf/mlf\n            files in the input_path folder; else, a dictionary of key-value\n            pairs like `(acquisition, path)` with `acquisition` a string\n            and `path` pointing to a csv file containing the parsed metadata\n            table.\n        overwrite: If `True`, overwrite the task output.\n\n    Returns:\n        A metadata dictionary containing important metadata about the OME-Zarr\n            plate, the images and some parameters required by downstream tasks\n            (like `num_levels`).\n    \"\"\"\n\n    if metadata_table_files:\n\n        # Checks on the dict:\n        # 1. Acquisitions as keys (same as keys of allowed_channels)\n        # 2. Files end with \".csv\"\n        # 3. Files exist.\n        if set(allowed_channels.keys()) != set(metadata_table_files.keys()):\n            raise ValueError(\n                \"Mismatch in acquisition keys between \"\n                f\"{allowed_channels.keys()=} and \"\n                f\"{metadata_table_files.keys()=}\"\n            )\n        for f in metadata_table_files.values():\n            if not f.endswith(\".csv\"):\n                raise ValueError(\n                    f\"{f} (in metadata_table_file) is not a csv file.\"\n                )\n            if not os.path.isfile(f):\n                raise ValueError(\n                    f\"{f} (in metadata_table_file) does not exist.\"\n                )\n\n    # Preliminary checks on allowed_channels\n    # Note that in metadata the keys of dictionary arguments should be\n    # strings (and not integers), so that they can be read from a JSON file\n    for key, _channels in allowed_channels.items():\n        if not isinstance(key, str):\n            raise ValueError(f\"{allowed_channels=} has non-string keys\")\n        check_unique_wavelength_ids(_channels)\n\n    # Identify all plates and all channels, per input folders\n    dict_acquisitions: dict = {}\n\n    for ind_in_path, in_path_str in enumerate(input_paths):\n        acquisition = str(ind_in_path)\n        in_path = Path(in_path_str)\n        dict_acquisitions[acquisition] = {}\n\n        actual_wavelength_ids = []\n        plates = []\n        plate_prefixes = []\n\n        # Loop over all images\n        patterns = [f\"*.{image_extension}\"]\n        if image_glob_patterns:\n            patterns.extend(image_glob_patterns)\n        input_filenames = glob_with_multiple_patterns(\n            folder=in_path_str,\n            patterns=patterns,\n        )\n        for fn in input_filenames:\n            try:\n                filename_metadata = parse_filename(Path(fn).name)\n                plate = filename_metadata[\"plate\"]\n                plates.append(plate)\n                plate_prefix = filename_metadata[\"plate_prefix\"]\n                plate_prefixes.append(plate_prefix)\n                A = filename_metadata[\"A\"]\n                C = filename_metadata[\"C\"]\n                actual_wavelength_ids.append(f\"A{A}_C{C}\")\n            except ValueError as e:\n                logger.warning(\n                    f'Skipping \"{Path(fn).name}\". Original error: ' + str(e)\n                )\n        plates = sorted(list(set(plates)))\n        actual_wavelength_ids = sorted(list(set(actual_wavelength_ids)))\n\n        info = (\n            \"Listing all plates/channels:\\n\"\n            f\"Patterns: {patterns}\\n\"\n            f\"Plates:   {plates}\\n\"\n            f\"Actual wavelength IDs: {actual_wavelength_ids}\\n\"\n        )\n\n        # Check that a folder includes a single plate\n        if len(plates) &gt; 1:\n            raise ValueError(f\"{info}ERROR: {len(plates)} plates detected\")\n        elif len(plates) == 0:\n            raise ValueError(f\"{info}ERROR: No plates detected\")\n        original_plate = plates[0]\n        plate_prefix = plate_prefixes[0]\n\n        # Replace plate with the one of acquisition 0, if needed\n        if int(acquisition) &gt; 0:\n            plate = dict_acquisitions[\"0\"][\"plate\"]\n            logger.warning(\n                f\"For {acquisition=}, we replace {original_plate=} with \"\n                f\"{plate=} (the one for acquisition 0)\"\n            )\n\n        # Check that all channels are in the allowed_channels\n        allowed_wavelength_ids = [\n            c.wavelength_id for c in allowed_channels[acquisition]\n        ]\n        if not set(actual_wavelength_ids).issubset(\n            set(allowed_wavelength_ids)\n        ):\n            msg = \"ERROR in create_ome_zarr\\n\"\n            msg += f\"actual_wavelength_ids: {actual_wavelength_ids}\\n\"\n            msg += f\"allowed_wavelength_ids: {allowed_wavelength_ids}\\n\"\n            raise ValueError(msg)\n\n        # Create actual_channels, i.e. a list of the channel dictionaries which\n        # are present\n        actual_channels = [\n            channel\n            for channel in allowed_channels[acquisition]\n            if channel.wavelength_id in actual_wavelength_ids\n        ]\n\n        logger.info(f\"plate: {plate}\")\n        logger.info(f\"actual_channels: {actual_channels}\")\n\n        dict_acquisitions[acquisition] = {}\n        dict_acquisitions[acquisition][\"plate\"] = plate\n        dict_acquisitions[acquisition][\"original_plate\"] = original_plate\n        dict_acquisitions[acquisition][\"plate_prefix\"] = plate_prefix\n        dict_acquisitions[acquisition][\"image_folder\"] = in_path\n        dict_acquisitions[acquisition][\"original_paths\"] = [in_path]\n        dict_acquisitions[acquisition][\"actual_channels\"] = actual_channels\n        dict_acquisitions[acquisition][\n            \"actual_wavelength_ids\"\n        ] = actual_wavelength_ids\n\n    acquisitions = sorted(list(dict_acquisitions.keys()))\n    current_plates = [item[\"plate\"] for item in dict_acquisitions.values()]\n    if len(set(current_plates)) &gt; 1:\n        raise ValueError(f\"{current_plates=}\")\n    plate = current_plates[0]\n\n    zarrurl = dict_acquisitions[acquisitions[0]][\"plate\"] + \".zarr\"\n    full_zarrurl = str(Path(output_path) / zarrurl)\n    logger.info(f\"Creating {full_zarrurl=}\")\n    # Call zarr.open_group wrapper, which handles overwrite=True/False\n    group_plate = open_zarr_group_with_overwrite(\n        full_zarrurl, overwrite=overwrite\n    )\n    group_plate.attrs[\"plate\"] = {\n        \"acquisitions\": [\n            {\n                \"id\": int(acquisition),\n                \"name\": dict_acquisitions[acquisition][\"original_plate\"],\n            }\n            for acquisition in acquisitions\n        ]\n    }\n\n    zarrurls: dict[str, list[str]] = {\"well\": [], \"image\": []}\n    zarrurls[\"plate\"] = [f\"{plate}.zarr\"]\n\n    ################################################################\n    logging.info(f\"{acquisitions=}\")\n\n    for acquisition in acquisitions:\n\n        # Define plate zarr\n        image_folder = dict_acquisitions[acquisition][\"image_folder\"]\n        logger.info(f\"Looking at {image_folder=}\")\n\n        # Obtain FOV-metadata dataframe\n        if metadata_table_files is None:\n            mrf_path = f\"{image_folder}/MeasurementDetail.mrf\"\n            mlf_path = f\"{image_folder}/MeasurementData.mlf\"\n            site_metadata, total_files = parse_yokogawa_metadata(\n                mrf_path, mlf_path, filename_patterns=image_glob_patterns\n            )\n            site_metadata = remove_FOV_overlaps(site_metadata)\n        else:\n            site_metadata = pd.read_csv(metadata_table_files[acquisition])\n            site_metadata.set_index([\"well_id\", \"FieldIndex\"], inplace=True)\n\n        # Extract pixel sizes and bit_depth\n        pixel_size_z = site_metadata[\"pixel_size_z\"][0]\n        pixel_size_y = site_metadata[\"pixel_size_y\"][0]\n        pixel_size_x = site_metadata[\"pixel_size_x\"][0]\n        bit_depth = site_metadata[\"bit_depth\"][0]\n\n        if min(pixel_size_z, pixel_size_y, pixel_size_x) &lt; 1e-9:\n            raise ValueError(pixel_size_z, pixel_size_y, pixel_size_x)\n\n        # Identify all wells\n        plate_prefix = dict_acquisitions[acquisition][\"plate_prefix\"]\n        patterns = [f\"{plate_prefix}_*.{image_extension}\"]\n        if image_glob_patterns:\n            patterns.extend(image_glob_patterns)\n        plate_images = glob_with_multiple_patterns(\n            folder=str(image_folder),\n            patterns=patterns,\n        )\n\n        wells = [\n            parse_filename(os.path.basename(fn))[\"well\"] for fn in plate_images\n        ]\n        wells = sorted(list(set(wells)))\n        logger.info(f\"{wells=}\")\n\n        # Verify that all wells have all channels\n        actual_channels = dict_acquisitions[acquisition][\"actual_channels\"]\n        for well in wells:\n            patterns = [f\"{plate_prefix}_{well}_*.{image_extension}\"]\n            if image_glob_patterns:\n                patterns.extend(image_glob_patterns)\n            well_images = glob_with_multiple_patterns(\n                folder=str(image_folder),\n                patterns=patterns,\n            )\n\n            well_wavelength_ids = []\n            for fpath in well_images:\n                try:\n                    filename_metadata = parse_filename(os.path.basename(fpath))\n                    A = filename_metadata[\"A\"]\n                    C = filename_metadata[\"C\"]\n                    well_wavelength_ids.append(f\"A{A}_C{C}\")\n                except IndexError:\n                    logger.info(f\"Skipping {fpath}\")\n            well_wavelength_ids = sorted(list(set(well_wavelength_ids)))\n            actual_wavelength_ids = dict_acquisitions[acquisition][\n                \"actual_wavelength_ids\"\n            ]\n            if well_wavelength_ids != actual_wavelength_ids:\n                raise ValueError(\n                    f\"ERROR: well {well} in plate {plate} (prefix: \"\n                    f\"{plate_prefix}) has missing channels.\\n\"\n                    f\"Expected: {actual_wavelength_ids}\\n\"\n                    f\"Found: {well_wavelength_ids}.\\n\"\n                )\n\n        well_rows_columns = [\n            ind for ind in sorted([(n[0], n[1:]) for n in wells])\n        ]\n        row_list = [\n            well_row_column[0] for well_row_column in well_rows_columns\n        ]\n        col_list = [\n            well_row_column[1] for well_row_column in well_rows_columns\n        ]\n        row_list = sorted(list(set(row_list)))\n        col_list = sorted(list(set(col_list)))\n\n        plate_attrs = group_plate.attrs[\"plate\"]\n        plate_attrs[\"columns\"] = [{\"name\": col} for col in col_list]\n        plate_attrs[\"rows\"] = [{\"name\": row} for row in row_list]\n        plate_attrs[\"wells\"] = [\n            {\n                \"path\": well_row_column[0] + \"/\" + well_row_column[1],\n                \"rowIndex\": row_list.index(well_row_column[0]),\n                \"columnIndex\": col_list.index(well_row_column[1]),\n            }\n            for well_row_column in well_rows_columns\n        ]\n        group_plate.attrs[\"plate\"] = plate_attrs\n\n        for row, column in well_rows_columns:\n\n            try:\n                group_well = group_plate.create_group(f\"{row}/{column}/\")\n                logging.info(f\"Created new group_well at {row}/{column}/\")\n                group_well.attrs[\"well\"] = {\n                    \"images\": [\n                        {\n                            \"path\": f\"{acquisition}\",\n                            \"acquisition\": int(acquisition),\n                        }\n                    ],\n                    \"version\": __OME_NGFF_VERSION__,\n                }\n                zarrurls[\"well\"].append(f\"{plate}.zarr/{row}/{column}\")\n            except ContainsGroupError:\n                group_well = zarr.open_group(\n                    f\"{full_zarrurl}/{row}/{column}/\", mode=\"r+\"\n                )\n                logging.info(\n                    f\"Loaded group_well from {full_zarrurl}/{row}/{column}\"\n                )\n                current_images = group_well.attrs[\"well\"][\"images\"] + [\n                    {\"path\": f\"{acquisition}\", \"acquisition\": int(acquisition)}\n                ]\n                group_well.attrs[\"well\"] = dict(\n                    images=current_images,\n                    version=group_well.attrs[\"well\"][\"version\"],\n                )\n\n            group_image = group_well.create_group(\n                f\"{acquisition}/\"\n            )  # noqa: F841\n            logging.info(f\"Created image group {row}/{column}/{acquisition}\")\n            image = f\"{plate}.zarr/{row}/{column}/{acquisition}\"\n            zarrurls[\"image\"].append(image)\n\n            group_image.attrs[\"multiscales\"] = [\n                {\n                    \"version\": __OME_NGFF_VERSION__,\n                    \"axes\": [\n                        {\"name\": \"c\", \"type\": \"channel\"},\n                        {\n                            \"name\": \"z\",\n                            \"type\": \"space\",\n                            \"unit\": \"micrometer\",\n                        },\n                        {\n                            \"name\": \"y\",\n                            \"type\": \"space\",\n                            \"unit\": \"micrometer\",\n                        },\n                        {\n                            \"name\": \"x\",\n                            \"type\": \"space\",\n                            \"unit\": \"micrometer\",\n                        },\n                    ],\n                    \"datasets\": [\n                        {\n                            \"path\": f\"{ind_level}\",\n                            \"coordinateTransformations\": [\n                                {\n                                    \"type\": \"scale\",\n                                    \"scale\": [\n                                        1,\n                                        pixel_size_z,\n                                        pixel_size_y\n                                        * coarsening_xy**ind_level,\n                                        pixel_size_x\n                                        * coarsening_xy**ind_level,\n                                    ],\n                                }\n                            ],\n                        }\n                        for ind_level in range(num_levels)\n                    ],\n                }\n            ]\n\n            group_image.attrs[\"omero\"] = {\n                \"id\": 1,  # FIXME does this depend on the plate number?\n                \"name\": \"TBD\",\n                \"version\": __OME_NGFF_VERSION__,\n                \"channels\": define_omero_channels(\n                    channels=actual_channels,\n                    bit_depth=bit_depth,\n                    label_prefix=acquisition,\n                ),\n            }\n\n            # Prepare AnnData tables for FOV/well ROIs\n            well_id = row + column\n            FOV_ROIs_table = prepare_FOV_ROI_table(site_metadata.loc[well_id])\n            well_ROIs_table = prepare_well_ROI_table(\n                site_metadata.loc[well_id]\n            )\n\n            # Write AnnData tables into the `tables` zarr group\n            write_table(\n                group_image,\n                \"FOV_ROI_table\",\n                FOV_ROIs_table,\n                overwrite=overwrite,\n                table_attrs={\"type\": \"roi_table\"},\n            )\n            write_table(\n                group_image,\n                \"well_ROI_table\",\n                well_ROIs_table,\n                overwrite=overwrite,\n                table_attrs={\"type\": \"roi_table\"},\n            )\n\n    # Check that the different images (e.g. different cycles) in the each well\n    # have unique labels\n    for well_path in zarrurls[\"well\"]:\n        check_well_channel_labels(\n            well_zarr_path=str(Path(output_path) / well_path)\n        )\n\n    original_paths = {\n        acquisition: dict_acquisitions[acquisition][\"original_paths\"]\n        for acquisition in acquisitions\n    }\n\n    metadata_update = dict(\n        plate=zarrurls[\"plate\"],\n        well=zarrurls[\"well\"],\n        image=zarrurls[\"image\"],\n        num_levels=num_levels,\n        coarsening_xy=coarsening_xy,\n        original_paths=original_paths,\n        image_extension=image_extension,\n        image_glob_patterns=image_glob_patterns,\n    )\n    return metadata_update\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/illumination_correction/","title":"illumination_correction","text":"<p>Apply illumination correction to all fields of view.</p>"},{"location":"reference/fractal_tasks_core/tasks/illumination_correction/#fractal_tasks_core.tasks.illumination_correction.correct","title":"<code>correct(img_stack, corr_img, background=110)</code>","text":"<p>Corrects a stack of images, using a given illumination profile (e.g. bright in the center of the image, dim outside).</p> PARAMETER  DESCRIPTION <code>img_stack</code> <p>4D numpy array (czyx), with dummy size along c.</p> <p> TYPE: <code>ndarray</code> </p> <code>corr_img</code> <p>2D numpy array (yx)</p> <p> TYPE: <code>ndarray</code> </p> <code>background</code> <p>Background value that is subtracted from the image before the illumination correction is applied.</p> <p> TYPE: <code>int</code> DEFAULT: <code>110</code> </p> Source code in <code>fractal_tasks_core/tasks/illumination_correction.py</code> <pre><code>def correct(\n    img_stack: np.ndarray,\n    corr_img: np.ndarray,\n    background: int = 110,\n):\n\"\"\"\n    Corrects a stack of images, using a given illumination profile (e.g. bright\n    in the center of the image, dim outside).\n\n    Args:\n        img_stack: 4D numpy array (czyx), with dummy size along c.\n        corr_img: 2D numpy array (yx)\n        background: Background value that is subtracted from the image before\n            the illumination correction is applied.\n    \"\"\"\n\n    logger.info(f\"Start correct, {img_stack.shape}\")\n\n    # Check shapes\n    if corr_img.shape != img_stack.shape[2:] or img_stack.shape[0] != 1:\n        raise ValueError(\n            \"Error in illumination_correction:\\n\"\n            f\"{img_stack.shape=}\\n{corr_img.shape=}\"\n        )\n\n    # Store info about dtype\n    dtype = img_stack.dtype\n    dtype_max = np.iinfo(dtype).max\n\n    # Background subtraction\n    img_stack[img_stack &lt;= background] = 0\n    img_stack[img_stack &gt; background] -= background\n\n    #  Apply the normalized correction matrix (requires a float array)\n    # img_stack = img_stack.astype(np.float64)\n    new_img_stack = img_stack / (corr_img / np.max(corr_img))[None, None, :, :]\n\n    # Handle edge case: corrected image may have values beyond the limit of\n    # the encoding, e.g. beyond 65535 for 16bit images. This clips values\n    # that surpass this limit and triggers a warning\n    if np.sum(new_img_stack &gt; dtype_max) &gt; 0:\n        warnings.warn(\n            \"Illumination correction created values beyond the max range of \"\n            f\"the current image type. These have been clipped to {dtype_max=}.\"\n        )\n        new_img_stack[new_img_stack &gt; dtype_max] = dtype_max\n\n    logger.info(\"End correct\")\n\n    # Cast back to original dtype and return\n    return new_img_stack.astype(dtype)\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/illumination_correction/#fractal_tasks_core.tasks.illumination_correction.illumination_correction","title":"<code>illumination_correction(*, input_paths, output_path, component, metadata, illumination_profiles_folder, dict_corr, background=110, overwrite_input=True, new_component=None)</code>","text":"<p>Applies illumination correction to the images in the OME-Zarr.</p> PARAMETER  DESCRIPTION <code>input_paths</code> <p>List of input paths where the image data is stored as OME-Zarrs. Should point to the parent folder containing one or many OME-Zarr files, not the actual OME-Zarr file. Example: <code>[\"/some/path/\"]</code>. This task only supports a single input path. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>Sequence[str]</code> </p> <code>output_path</code> <p>Path were the output of this task is stored. Examples: <code>\"/some/path/\"</code> =&gt; puts the new OME-Zarr file in the same folder as the input OME-Zarr file; <code>\"/some/new_path\"</code> =&gt; puts the new OME-Zarr file into a new folder at <code>/some/new_path</code>. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>str</code> </p> <code>component</code> <p>Path to the OME-Zarr image in the OME-Zarr plate that is processed. Example: <code>\"some_plate.zarr/B/03/0\"</code>. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>str</code> </p> <code>metadata</code> <p>This parameter is not used by this task. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>illumination_profiles_folder</code> <p>Path of folder of illumination profiles.</p> <p> TYPE: <code>str</code> </p> <code>dict_corr</code> <p>Dictionary where keys match the <code>wavelength_id</code> attributes of existing channels (e.g.  <code>A01_C01</code> ) and values are the filenames of the corresponding illumination profiles.</p> <p> TYPE: <code>dict[str, str]</code> </p> <code>background</code> <p>Background value that is subtracted from the image before the illumination correction is applied. Set it to <code>0</code> if you don't want any background subtraction.</p> <p> TYPE: <code>int</code> DEFAULT: <code>110</code> </p> <code>overwrite_input</code> <p>If <code>True</code>, the results of this task will overwrite the input image data. In the current version, <code>overwrite_input=False</code> is not implemented.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>new_component</code> <p>Not implemented yet. This is not implemented well in Fractal server at the moment, it's unclear how a user would specify fitting new components. If the results shall not overwrite the input data and the output path is the same as the input path, a new component needs to be provided. Example: <code>myplate_new_name.zarr/B/03/0/</code>.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> Source code in <code>fractal_tasks_core/tasks/illumination_correction.py</code> <pre><code>@validate_arguments\ndef illumination_correction(\n    *,\n    # Standard arguments\n    input_paths: Sequence[str],\n    output_path: str,\n    component: str,\n    metadata: dict[str, Any],\n    # Task-specific arguments\n    illumination_profiles_folder: str,\n    dict_corr: dict[str, str],\n    background: int = 110,\n    overwrite_input: bool = True,\n    new_component: Optional[str] = None,\n) -&gt; dict[str, Any]:\n\n\"\"\"\n    Applies illumination correction to the images in the OME-Zarr.\n\n    Args:\n        input_paths: List of input paths where the image data is stored as\n            OME-Zarrs. Should point to the parent folder containing one or many\n            OME-Zarr files, not the actual OME-Zarr file. Example:\n            `[\"/some/path/\"]`. This task only supports a single input path.\n            (standard argument for Fractal tasks, managed by Fractal server).\n        output_path: Path were the output of this task is stored. Examples:\n            `\"/some/path/\"` =&gt; puts the new OME-Zarr file in the same folder as\n            the input OME-Zarr file; `\"/some/new_path\"` =&gt; puts the new\n            OME-Zarr file into a new folder at `/some/new_path`.\n            (standard argument for Fractal tasks, managed by Fractal server).\n        component: Path to the OME-Zarr image in the OME-Zarr plate that is\n            processed. Example: `\"some_plate.zarr/B/03/0\"`.\n            (standard argument for Fractal tasks, managed by Fractal server).\n        metadata: This parameter is not used by this task.\n            (standard argument for Fractal tasks, managed by Fractal server).\n        illumination_profiles_folder: Path of folder of illumination profiles.\n        dict_corr: Dictionary where keys match the `wavelength_id` attributes\n            of existing channels (e.g.  `A01_C01` ) and values are the\n            filenames of the corresponding illumination profiles.\n        background: Background value that is subtracted from the image before\n            the illumination correction is applied. Set it to `0` if you don't\n            want any background subtraction.\n        overwrite_input:\n            If `True`, the results of this task will overwrite the input image\n            data. In the current version, `overwrite_input=False` is not\n            implemented.\n        new_component: Not implemented yet. This is not implemented well in\n            Fractal server at the moment, it's unclear how a user would specify\n            fitting new components. If the results shall not overwrite the\n            input data and the output path is the same as the input path, a new\n            component needs to be provided.\n            Example: `myplate_new_name.zarr/B/03/0/`.\n    \"\"\"\n\n    # Preliminary checks\n    if len(input_paths) &gt; 1:\n        raise NotImplementedError\n    if (overwrite_input and new_component is not None) or (\n        new_component is None and not overwrite_input\n    ):\n        raise ValueError(f\"{overwrite_input=}, but {new_component=}\")\n\n    if not overwrite_input:\n        msg = (\n            \"We still have to harmonize illumination_correction(\"\n            \"overwrite_input=False) with replicate_zarr_structure(..., \"\n            \"suffix=..)\"\n        )\n        raise NotImplementedError(msg)\n\n    # Defione old/new zarrurls\n    plate, well = component.split(\".zarr/\")\n    in_path = Path(input_paths[0])\n    zarrurl_old = (in_path / component).as_posix()\n    if overwrite_input:\n        zarrurl_new = zarrurl_old\n    else:\n        new_plate, new_well = new_component.split(\".zarr/\")\n        if new_well != well:\n            raise ValueError(f\"{well=}, {new_well=}\")\n        zarrurl_new = (Path(output_path) / new_component).as_posix()\n\n    t_start = time.perf_counter()\n    logger.info(\"Start illumination_correction\")\n    logger.info(f\"  {overwrite_input=}\")\n    logger.info(f\"  {zarrurl_old=}\")\n    logger.info(f\"  {zarrurl_new=}\")\n\n    # Read attributes from NGFF metadata\n    ngff_image_meta = load_NgffImageMeta(zarrurl_old)\n    num_levels = ngff_image_meta.num_levels\n    coarsening_xy = ngff_image_meta.coarsening_xy\n    full_res_pxl_sizes_zyx = ngff_image_meta.get_pixel_sizes_zyx(level=0)\n    logger.info(f\"NGFF image has {num_levels=}\")\n    logger.info(f\"NGFF image has {coarsening_xy=}\")\n    logger.info(\n        f\"NGFF image has full-res pixel sizes {full_res_pxl_sizes_zyx}\"\n    )\n\n    # Read channels from .zattrs\n    channels: list[OmeroChannel] = get_omero_channel_list(\n        image_zarr_path=zarrurl_old\n    )\n    num_channels = len(channels)\n\n    # Read FOV ROIs\n    FOV_ROI_table = ad.read_zarr(f\"{zarrurl_old}/tables/FOV_ROI_table\")\n\n    # Create list of indices for 3D FOVs spanning the entire Z direction\n    list_indices = convert_ROI_table_to_indices(\n        FOV_ROI_table,\n        level=0,\n        coarsening_xy=coarsening_xy,\n        full_res_pxl_sizes_zyx=full_res_pxl_sizes_zyx,\n    )\n    check_valid_ROI_indices(list_indices, \"FOV_ROI_table\")\n\n    # Extract image size from FOV-ROI indices. Note: this works at level=0,\n    # where FOVs should all be of the exact same size (in pixels)\n    ref_img_size = None\n    for indices in list_indices:\n        img_size = (indices[3] - indices[2], indices[5] - indices[4])\n        if ref_img_size is None:\n            ref_img_size = img_size\n        else:\n            if img_size != ref_img_size:\n                raise ValueError(\n                    \"ERROR: inconsistent image sizes in list_indices\"\n                )\n    img_size_y, img_size_x = img_size[:]\n\n    # Assemble dictionary of matrices and check their shapes\n    corrections = {}\n    for channel in channels:\n        wavelength_id = channel.wavelength_id\n        corrections[wavelength_id] = imread(\n            (\n                Path(illumination_profiles_folder) / dict_corr[wavelength_id]\n            ).as_posix()\n        )\n        if corrections[wavelength_id].shape != (img_size_y, img_size_x):\n            raise ValueError(\n                \"Error in illumination_correction, \"\n                \"correction matrix has wrong shape.\"\n            )\n\n    # Lazily load highest-res level from original zarr array\n    data_czyx = da.from_zarr(f\"{zarrurl_old}/0\")\n\n    # Create zarr for output\n    if overwrite_input:\n        fov_path = zarrurl_old\n        new_zarr = zarr.open(f\"{zarrurl_old}/0\")\n    else:\n        fov_path = zarrurl_new\n        new_zarr = zarr.create(\n            shape=data_czyx.shape,\n            chunks=data_czyx.chunksize,\n            dtype=data_czyx.dtype,\n            store=zarr.storage.FSStore(f\"{zarrurl_new}/0\"),\n            overwrite=False,\n            dimension_separator=\"/\",\n        )\n\n    # Iterate over FOV ROIs\n    num_ROIs = len(list_indices)\n    for i_c, channel in enumerate(channels):\n        for i_ROI, indices in enumerate(list_indices):\n            # Define region\n            s_z, e_z, s_y, e_y, s_x, e_x = indices[:]\n            region = (\n                slice(i_c, i_c + 1),\n                slice(s_z, e_z),\n                slice(s_y, e_y),\n                slice(s_x, e_x),\n            )\n            logger.info(\n                f\"Now processing ROI {i_ROI+1}/{num_ROIs} \"\n                f\"for channel {i_c+1}/{num_channels}\"\n            )\n            # Execute illumination correction\n            corrected_fov = correct(\n                data_czyx[region].compute(),\n                corrections[channel.wavelength_id],\n                background=background,\n            )\n            # Write to disk\n            da.array(corrected_fov).to_zarr(\n                url=new_zarr,\n                region=region,\n                compute=True,\n            )\n\n    # Starting from on-disk highest-resolution data, build and write to disk a\n    # pyramid of coarser levels\n    build_pyramid(\n        zarrurl=fov_path,\n        overwrite=True,\n        num_levels=num_levels,\n        coarsening_xy=coarsening_xy,\n        chunksize=data_czyx.chunksize,\n    )\n\n    t_end = time.perf_counter()\n    logger.info(f\"End illumination_correction, elapsed: {t_end-t_start}\")\n\n    return {}\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/import_ome_zarr/","title":"import_ome_zarr","text":"<p>Task to import an existing OME-Zarr.</p>"},{"location":"reference/fractal_tasks_core/tasks/import_ome_zarr/#fractal_tasks_core.tasks.import_ome_zarr._process_single_image","title":"<code>_process_single_image(image_path, add_image_ROI_table, add_grid_ROI_table, update_omero_metadata, *, grid_YX_shape=None, overwrite=False)</code>","text":"<p>Validate OME-NGFF metadata and optionally generate ROI tables.</p> <p>This task:</p> <ol> <li>Validates OME-NGFF image metadata, via <code>NgffImageMeta</code>;</li> <li>Optionally generates and writes two ROI tables;</li> <li>Optionally update OME-NGFF omero metadata.</li> </ol> PARAMETER  DESCRIPTION <code>image_path</code> <p>Absolute path to the image Zarr group.</p> <p> TYPE: <code>str</code> </p> <code>add_image_ROI_table</code> <p>Whether to add a <code>image_ROI_table</code> table (argument propagated from <code>import_ome_zarr</code>).</p> <p> TYPE: <code>bool</code> </p> <code>add_grid_ROI_table</code> <p>Whether to add a <code>grid_ROI_table</code> table (argument propagated from <code>import_ome_zarr</code>).</p> <p> TYPE: <code>bool</code> </p> <code>update_omero_metadata</code> <p>Whether to update Omero-channels metadata (argument propagated from <code>import_ome_zarr</code>).</p> <p> TYPE: <code>bool</code> </p> <code>grid_YX_shape</code> <p>YX shape of the ROI grid (it must be not <code>None</code>, if <code>add_grid_ROI_table=True</code>.</p> <p> TYPE: <code>Optional[tuple[int, int]]</code> DEFAULT: <code>None</code> </p> Source code in <code>fractal_tasks_core/tasks/import_ome_zarr.py</code> <pre><code>def _process_single_image(\n    image_path: str,\n    add_image_ROI_table: bool,\n    add_grid_ROI_table: bool,\n    update_omero_metadata: bool,\n    *,\n    grid_YX_shape: Optional[tuple[int, int]] = None,\n    overwrite: bool = False,\n) -&gt; None:\n\"\"\"\n    Validate OME-NGFF metadata and optionally generate ROI tables.\n\n    This task:\n\n    1. Validates OME-NGFF image metadata, via `NgffImageMeta`;\n    2. Optionally generates and writes two ROI tables;\n    3. Optionally update OME-NGFF omero metadata.\n\n    Args:\n        image_path: Absolute path to the image Zarr group.\n        add_image_ROI_table: Whether to add a `image_ROI_table` table\n            (argument propagated from `import_ome_zarr`).\n        add_grid_ROI_table: Whether to add a `grid_ROI_table` table (argument\n            propagated from `import_ome_zarr`).\n        update_omero_metadata: Whether to update Omero-channels metadata\n            (argument propagated from `import_ome_zarr`).\n        grid_YX_shape: YX shape of the ROI grid (it must be not `None`, if\n            `add_grid_ROI_table=True`.\n    \"\"\"\n\n    # Note from zarr docs: `r+` means read/write (must exist)\n    image_group = zarr.open_group(image_path, mode=\"r+\")\n    image_meta = NgffImageMeta(**image_group.attrs.asdict())\n\n    # Preliminary checks\n    if not (add_image_ROI_table or add_grid_ROI_table):\n        return\n    if add_grid_ROI_table and (grid_YX_shape is None):\n        raise ValueError(\n            f\"_process_single_image called with {add_grid_ROI_table=}, \"\n            f\"but {grid_YX_shape=}.\"\n        )\n\n    pixels_ZYX = image_meta.get_pixel_sizes_zyx(level=0)\n\n    # Read zarr array\n    dataset_subpath = image_meta.datasets[0].path\n    array = da.from_zarr(f\"{image_path}/{dataset_subpath}\")\n\n    # Prepare image_ROI_table and write it into the zarr group\n    if add_image_ROI_table:\n        image_ROI_table = get_single_image_ROI(array.shape, pixels_ZYX)\n        write_table(\n            image_group,\n            \"image_ROI_table\",\n            image_ROI_table,\n            overwrite=overwrite,\n            table_attrs={\"type\": \"roi_table\"},\n        )\n\n    # Prepare grid_ROI_table and write it into the zarr group\n    if add_grid_ROI_table:\n        grid_ROI_table = get_image_grid_ROIs(\n            array.shape,\n            pixels_ZYX,\n            grid_YX_shape,\n        )\n        write_table(\n            image_group,\n            \"grid_ROI_table\",\n            grid_ROI_table,\n            overwrite=overwrite,\n            table_attrs={\"type\": \"roi_table\"},\n        )\n\n    # Update Omero-channels metadata\n    if update_omero_metadata:\n        # Extract number of channels from zarr array\n        try:\n            channel_axis_index = image_meta.axes_names.index(\"c\")\n        except ValueError:\n            logger.error(f\"Existing axes: {image_meta.axes_names}\")\n            msg = (\n                \"OME-Zarrs with no channel axis are not currently \"\n                \"supported in fractal-tasks-core. Upcoming flexibility \"\n                \"improvements are tracked in https://github.com/\"\n                \"fractal-analytics-platform/fractal-tasks-core/issues/150.\"\n            )\n            logger.error(msg)\n            raise NotImplementedError(msg)\n        logger.info(f\"Existing axes: {image_meta.axes_names}\")\n        logger.info(f\"Channel-axis index: {channel_axis_index}\")\n        num_channels_zarr = array.shape[channel_axis_index]\n        logger.info(\n            f\"{num_channels_zarr} channel(s) found in Zarr array \"\n            f\"at {image_path}/{dataset_subpath}\"\n        )\n        # Update or create omero channels metadata\n        old_omero = image_group.attrs.get(\"omero\", {})\n        old_channels = old_omero.get(\"channels\", [])\n        if len(old_channels) &gt; 0:\n            logger.info(\n                f\"{len(old_channels)} channel(s) found in NGFF omero metadata\"\n            )\n            if len(old_channels) != num_channels_zarr:\n                error_msg = (\n                    \"Channels-number mismatch: Number of channels in the \"\n                    f\"zarr array ({num_channels_zarr}) differs from number \"\n                    \"of channels listed in NGFF omero metadata \"\n                    f\"({len(old_channels)}).\"\n                )\n                logging.error(error_msg)\n                raise ValueError(error_msg)\n        else:\n            old_channels = [{} for ind in range(num_channels_zarr)]\n        new_channels = update_omero_channels(old_channels)\n        new_omero = old_omero.copy()\n        new_omero[\"channels\"] = new_channels\n        image_group.attrs.update(omero=new_omero)\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/import_ome_zarr/#fractal_tasks_core.tasks.import_ome_zarr.import_ome_zarr","title":"<code>import_ome_zarr(*, input_paths, output_path, metadata, zarr_name, add_image_ROI_table=True, add_grid_ROI_table=True, grid_y_shape=2, grid_x_shape=2, update_omero_metadata=True, overwrite=False)</code>","text":"<p>Import an OME-Zarr into Fractal.</p> <p>The current version of this task:</p> <ol> <li>Creates the appropriate components-related metadata, needed for    processing an existing OME-Zarr through Fractal.</li> <li>Optionally adds new ROI tables to the existing OME-Zarr.</li> </ol> PARAMETER  DESCRIPTION <code>input_paths</code> <p>A length-one list with the parent folder of the OME-Zarr to be imported; e.g. <code>input_paths=[\"/somewhere\"]</code>, if the OME-Zarr path is <code>/somewhere/array.zarr</code>. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>Sequence[str]</code> </p> <code>output_path</code> <p>Not used in this task. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>str</code> </p> <code>metadata</code> <p>Not used in this task. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>zarr_name</code> <p>The OME-Zarr name, without its parent folder; e.g. <code>zarr_name=\"array.zarr\"</code>, if the OME-Zarr path is <code>/somewhere/array.zarr</code>.</p> <p> TYPE: <code>str</code> </p> <code>add_image_ROI_table</code> <p>Whether to add a <code>image_ROI_table</code> table to each image, with a single ROI covering the whole image.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>add_grid_ROI_table</code> <p>Whether to add a <code>grid_ROI_table</code> table to each image, with the image split into a rectangular grid of ROIs.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>grid_y_shape</code> <p>Y shape of the ROI grid in <code>grid_ROI_table</code>.</p> <p> TYPE: <code>int</code> DEFAULT: <code>2</code> </p> <code>grid_x_shape</code> <p>X shape of the ROI grid in <code>grid_ROI_table</code>.</p> <p> TYPE: <code>int</code> DEFAULT: <code>2</code> </p> <code>update_omero_metadata</code> <p>Whether to update Omero-channels metadata, to make them Fractal-compatible.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>overwrite</code> <p>Whether new ROI tables (added when <code>add_image_ROI_table</code> and/or <code>add_grid_ROI_table</code> are <code>True</code>) can overwite existing ones.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>fractal_tasks_core/tasks/import_ome_zarr.py</code> <pre><code>@validate_arguments\ndef import_ome_zarr(\n    *,\n    input_paths: Sequence[str],\n    output_path: str,\n    metadata: dict[str, Any],\n    zarr_name: str,\n    add_image_ROI_table: bool = True,\n    add_grid_ROI_table: bool = True,\n    grid_y_shape: int = 2,\n    grid_x_shape: int = 2,\n    update_omero_metadata: bool = True,\n    overwrite: bool = False,\n) -&gt; dict[str, Any]:\n\"\"\"\n    Import an OME-Zarr into Fractal.\n\n    The current version of this task:\n\n    1. Creates the appropriate components-related metadata, needed for\n       processing an existing OME-Zarr through Fractal.\n    2. Optionally adds new ROI tables to the existing OME-Zarr.\n\n    Args:\n        input_paths: A length-one list with the parent folder of the OME-Zarr\n            to be imported; e.g. `input_paths=[\"/somewhere\"]`, if the OME-Zarr\n            path is `/somewhere/array.zarr`.\n            (standard argument for Fractal tasks, managed by Fractal server).\n        output_path: Not used in this task.\n            (standard argument for Fractal tasks, managed by Fractal server).\n        metadata: Not used in this task.\n            (standard argument for Fractal tasks, managed by Fractal server).\n        zarr_name: The OME-Zarr name, without its parent folder; e.g.\n            `zarr_name=\"array.zarr\"`, if the OME-Zarr path is\n            `/somewhere/array.zarr`.\n        add_image_ROI_table: Whether to add a `image_ROI_table` table to each\n            image, with a single ROI covering the whole image.\n        add_grid_ROI_table: Whether to add a `grid_ROI_table` table to each\n            image, with the image split into a rectangular grid of ROIs.\n        grid_y_shape: Y shape of the ROI grid in `grid_ROI_table`.\n        grid_x_shape: X shape of the ROI grid in `grid_ROI_table`.\n        update_omero_metadata: Whether to update Omero-channels metadata, to\n            make them Fractal-compatible.\n        overwrite: Whether new ROI tables (added when `add_image_ROI_table`\n            and/or `add_grid_ROI_table` are `True`) can overwite existing ones.\n    \"\"\"\n\n    # Preliminary checks\n    if len(input_paths) &gt; 1:\n        raise NotImplementedError\n\n    zarr_path = str(Path(input_paths[0]) / zarr_name)\n    logger.info(f\"Zarr path: {zarr_path}\")\n\n    zarrurls: dict = dict(plate=[], well=[], image=[])\n\n    root_group = zarr.open_group(zarr_path, mode=\"r\")\n    ngff_type = detect_ome_ngff_type(root_group)\n    grid_YX_shape = (grid_y_shape, grid_x_shape)\n\n    if ngff_type == \"plate\":\n        zarrurls[\"plate\"].append(zarr_name)\n        for well in root_group.attrs[\"plate\"][\"wells\"]:\n            well_path = well[\"path\"]\n            zarrurls[\"well\"].append(f\"{zarr_name}/{well_path}\")\n\n            well_group = zarr.open_group(zarr_path, path=well_path, mode=\"r\")\n            for image in well_group.attrs[\"well\"][\"images\"]:\n                image_path = image[\"path\"]\n                zarrurls[\"image\"].append(\n                    f\"{zarr_name}/{well_path}/{image_path}\"\n                )\n                _process_single_image(\n                    f\"{zarr_path}/{well_path}/{image_path}\",\n                    add_image_ROI_table,\n                    add_grid_ROI_table,\n                    update_omero_metadata,\n                    grid_YX_shape=grid_YX_shape,\n                    overwrite=overwrite,\n                )\n    elif ngff_type == \"well\":\n        zarrurls[\"well\"].append(zarr_name)\n        logger.warning(\n            \"Only OME-Zarr for plates are fully supported in Fractal; \"\n            f\"e.g. the current one ({ngff_type=}) cannot be \"\n            \"processed via the `maximum_intensity_projection` task.\"\n        )\n        for image in root_group.attrs[\"well\"][\"images\"]:\n            image_path = image[\"path\"]\n            zarrurls[\"image\"].append(f\"{zarr_name}/{image_path}\")\n            _process_single_image(\n                f\"{zarr_path}/{image_path}\",\n                add_image_ROI_table,\n                add_grid_ROI_table,\n                update_omero_metadata,\n                grid_YX_shape=grid_YX_shape,\n                overwrite=overwrite,\n            )\n    elif ngff_type == \"image\":\n        zarrurls[\"image\"].append(zarr_name)\n        logger.warning(\n            \"Only OME-Zarr for plates are fully supported in Fractal; \"\n            f\"e.g. the current one ({ngff_type=}) cannot be \"\n            \"processed via the `maximum_intensity_projection` task.\"\n        )\n        _process_single_image(\n            zarr_path,\n            add_image_ROI_table,\n            add_grid_ROI_table,\n            update_omero_metadata,\n            grid_YX_shape=grid_YX_shape,\n            overwrite=overwrite,\n        )\n\n    # Remove zarrurls keys pointing to empty lists\n    clean_zarrurls = {\n        key: value for key, value in zarrurls.items() if len(value) &gt; 0\n    }\n\n    return clean_zarrurls\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/maximum_intensity_projection/","title":"maximum_intensity_projection","text":"<p>Task for 3D-&gt;2D maximum-intensity projection.</p>"},{"location":"reference/fractal_tasks_core/tasks/maximum_intensity_projection/#fractal_tasks_core.tasks.maximum_intensity_projection.maximum_intensity_projection","title":"<code>maximum_intensity_projection(*, input_paths, output_path, component, metadata, overwrite=False)</code>","text":"<p>Perform maximum-intensity projection along Z axis.</p> <p>Note: this task stores the output in a new zarr file.</p> PARAMETER  DESCRIPTION <code>input_paths</code> <p>This parameter is not used by this task. This task only supports a single input path. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>Sequence[str]</code> </p> <code>output_path</code> <p>Path were the output of this task is stored. Example: <code>\"/some/path/\"</code> =&gt; puts the new OME-Zarr file in that folder. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>str</code> </p> <code>component</code> <p>Path to the OME-Zarr image in the OME-Zarr plate that is processed. Component is typically changed by the <code>copy_ome_zarr</code> task before, to point to a new mip Zarr file. Example: <code>\"some_plate_mip.zarr/B/03/0\"</code>. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>str</code> </p> <code>metadata</code> <p>Dictionary containing metadata about the OME-Zarr. This task requires the key <code>copy_ome_zarr</code> to be present in the metadata (as defined in <code>copy_ome_zarr</code> task). (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>overwrite</code> <p>If <code>True</code>, overwrite the task output.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>fractal_tasks_core/tasks/maximum_intensity_projection.py</code> <pre><code>@validate_arguments\ndef maximum_intensity_projection(\n    *,\n    input_paths: Sequence[str],\n    output_path: str,\n    component: str,\n    metadata: dict[str, Any],\n    overwrite: bool = False,\n) -&gt; dict[str, Any]:\n\"\"\"\n    Perform maximum-intensity projection along Z axis.\n\n    Note: this task stores the output in a new zarr file.\n\n    Args:\n        input_paths: This parameter is not used by this task.\n            This task only supports a single input path.\n            (standard argument for Fractal tasks, managed by Fractal server).\n        output_path: Path were the output of this task is stored.\n            Example: `\"/some/path/\"` =&gt; puts the new OME-Zarr file in that\n            folder.\n            (standard argument for Fractal tasks, managed by Fractal server).\n        component: Path to the OME-Zarr image in the OME-Zarr plate that\n            is processed. Component is typically changed by the `copy_ome_zarr`\n            task before, to point to a new mip Zarr file.\n            Example: `\"some_plate_mip.zarr/B/03/0\"`.\n            (standard argument for Fractal tasks, managed by Fractal server).\n        metadata: Dictionary containing metadata about the OME-Zarr.\n            This task requires the key `copy_ome_zarr` to be present in the\n            metadata (as defined in `copy_ome_zarr` task).\n            (standard argument for Fractal tasks, managed by Fractal server).\n        overwrite: If `True`, overwrite the task output.\n    \"\"\"\n\n    # Preliminary checks\n    if len(input_paths) &gt; 1:\n        raise NotImplementedError\n\n    plate, well = component.split(\".zarr/\")\n    zarrurl_old = metadata[\"copy_ome_zarr\"][\"sources\"][plate] + \"/\" + well\n    clean_output_path = Path(output_path).resolve()\n    zarrurl_new = (clean_output_path / component).as_posix()\n    logger.info(f\"{zarrurl_old=}\")\n    logger.info(f\"{zarrurl_new=}\")\n\n    # Read some parameters from metadata\n    ngff_image = load_NgffImageMeta(zarrurl_old)\n    num_levels = ngff_image.num_levels\n    coarsening_xy = ngff_image.coarsening_xy\n\n    # Load 0-th level\n    data_czyx = da.from_zarr(zarrurl_old + \"/0\")\n    num_channels = data_czyx.shape[0]\n    chunksize_y = data_czyx.chunksize[-2]\n    chunksize_x = data_czyx.chunksize[-1]\n    logger.info(f\"{num_channels=}\")\n    logger.info(f\"{chunksize_y=}\")\n    logger.info(f\"{chunksize_x=}\")\n    # Loop over channels\n    accumulate_chl = []\n    for ind_ch in range(num_channels):\n        # Perform MIP for each channel of level 0\n        mip_yx = da.stack([da.max(data_czyx[ind_ch], axis=0)], axis=0)\n        accumulate_chl.append(mip_yx)\n    accumulated_array = da.stack(accumulate_chl, axis=0)\n\n    # Write to disk (triggering execution)\n    try:\n        accumulated_array.to_zarr(\n            f\"{zarrurl_new}/0\",\n            overwrite=overwrite,\n            dimension_separator=\"/\",\n            write_empty_chunks=False,\n        )\n    except ContainsArrayError as e:\n        error_msg = (\n            f\"Cannot write array to zarr group at '{zarrurl_new}/0', \"\n            f\"with {overwrite=} (original error: {str(e)}).\\n\"\n            \"Hint: try setting overwrite=True.\"\n        )\n        logger.error(error_msg)\n        raise OverwriteNotAllowedError(error_msg)\n\n    # Starting from on-disk highest-resolution data, build and write to disk a\n    # pyramid of coarser levels\n    build_pyramid(\n        zarrurl=zarrurl_new,\n        overwrite=overwrite,\n        num_levels=num_levels,\n        coarsening_xy=coarsening_xy,\n        chunksize=(1, 1, chunksize_y, chunksize_x),\n    )\n\n    return {}\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/napari_workflows_wrapper/","title":"napari_workflows_wrapper","text":"<p>Wrapper of napari-workflows.</p>"},{"location":"reference/fractal_tasks_core/tasks/napari_workflows_wrapper/#fractal_tasks_core.tasks.napari_workflows_wrapper.OutOfTaskScopeError","title":"<code>OutOfTaskScopeError</code>","text":"<p>             Bases: <code>NotImplementedError</code></p> <p>Encapsulates features that are out-of-scope for the current wrapper task.</p> Source code in <code>fractal_tasks_core/tasks/napari_workflows_wrapper.py</code> <pre><code>class OutOfTaskScopeError(NotImplementedError):\n\"\"\"\n    Encapsulates features that are out-of-scope for the current wrapper task.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/napari_workflows_wrapper/#fractal_tasks_core.tasks.napari_workflows_wrapper.napari_workflows_wrapper","title":"<code>napari_workflows_wrapper(*, input_paths, output_path, component, metadata, workflow_file, input_specs, output_specs, input_ROI_table='FOV_ROI_table', level=0, relabeling=True, expected_dimensions=3, overwrite=True)</code>","text":"<p>Run a napari-workflow on the ROIs of a single OME-NGFF image.</p> <p>This task takes images and labels and runs a napari-workflow on them that can produce a label and tables as output.</p> <p>Examples of allowed entries for <code>input_specs</code> and <code>output_specs</code>:</p> <pre><code>input_specs = {\n    \"in_1\": {\"type\": \"image\", \"channel\": {\"wavelength_id\": \"A01_C02\"}},\n    \"in_2\": {\"type\": \"image\", \"channel\": {\"label\": \"DAPI\"}},\n    \"in_3\": {\"type\": \"label\", \"label_name\": \"label_DAPI\"},\n}\n\noutput_specs = {\n    \"out_1\": {\"type\": \"label\", \"label_name\": \"label_DAPI_new\"},\n    \"out_2\": {\"type\": \"dataframe\", \"table_name\": \"measurements\"},\n}\n</code></pre> PARAMETER  DESCRIPTION <code>input_paths</code> <p>List of input paths where the image data is stored as OME-Zarrs. Should point to the parent folder containing one or many OME-Zarr files, not the actual OME-Zarr file. Example: <code>[\"/some/path/\"]</code>. his task only supports a single input path. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>Sequence[str]</code> </p> <code>output_path</code> <p>This parameter is not used by this task. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>str</code> </p> <code>component</code> <p>Path to the OME-Zarr image in the OME-Zarr plate that is processed. Example: <code>\"some_plate.zarr/B/03/0\"</code>. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>str</code> </p> <code>metadata</code> <p>This parameter is not used by this task. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>workflow_file</code> <p>Absolute path to napari-workflows YAML file</p> <p> TYPE: <code>str</code> </p> <code>input_specs</code> <p>A dictionary of <code>NapariWorkflowsInput</code> values.</p> <p> TYPE: <code>dict[str, NapariWorkflowsInput]</code> </p> <code>output_specs</code> <p>A dictionary of <code>NapariWorkflowsOutput</code> values.</p> <p> TYPE: <code>dict[str, NapariWorkflowsOutput]</code> </p> <code>input_ROI_table</code> <p>Name of the ROI table over which the task loops to apply napari workflows. Examples: <code>FOV_ROI_table</code> =&gt; loop over the field of views; <code>organoid_ROI_table</code> =&gt; loop over the organoid ROI table (generated by another task); <code>well_ROI_table</code> =&gt; process the whole well as one image.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'FOV_ROI_table'</code> </p> <code>level</code> <p>Pyramid level of the image to be used as input for napari-workflows. Choose <code>0</code> to process at full resolution. Levels &gt; 0 are currently only supported for workflows that only have intensity images as input and only produce a label images as output.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>relabeling</code> <p>If <code>True</code>, apply relabeling so that label values are unique across all ROIs in the well.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>expected_dimensions</code> <p>Expected dimensions (either <code>2</code> or <code>3</code>). Useful when loading 2D images that are stored in a 3D array with shape <code>(1, size_x, size_y)</code> [which is the default way Fractal stores 2D images], but you want to make sure the napari workflow gets a 2D array to process. Also useful to set to <code>2</code> when loading a 2D OME-Zarr that is saved as <code>(size_x, size_y)</code>.</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> <code>overwrite</code> <p>If <code>True</code>, overwrite the task output.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>fractal_tasks_core/tasks/napari_workflows_wrapper.py</code> <pre><code>@validate_arguments\ndef napari_workflows_wrapper(\n    *,\n    # Default arguments for fractal tasks:\n    input_paths: Sequence[str],\n    output_path: str,\n    component: str,\n    metadata: dict[str, Any],\n    # Task-specific arguments:\n    workflow_file: str,\n    input_specs: dict[str, NapariWorkflowsInput],\n    output_specs: dict[str, NapariWorkflowsOutput],\n    input_ROI_table: str = \"FOV_ROI_table\",\n    level: int = 0,\n    relabeling: bool = True,\n    expected_dimensions: int = 3,\n    overwrite: bool = True,\n):\n\"\"\"\n    Run a napari-workflow on the ROIs of a single OME-NGFF image.\n\n    This task takes images and labels and runs a napari-workflow on them that\n    can produce a label and tables as output.\n\n    Examples of allowed entries for `input_specs` and `output_specs`:\n\n    ```\n    input_specs = {\n        \"in_1\": {\"type\": \"image\", \"channel\": {\"wavelength_id\": \"A01_C02\"}},\n        \"in_2\": {\"type\": \"image\", \"channel\": {\"label\": \"DAPI\"}},\n        \"in_3\": {\"type\": \"label\", \"label_name\": \"label_DAPI\"},\n    }\n\n    output_specs = {\n        \"out_1\": {\"type\": \"label\", \"label_name\": \"label_DAPI_new\"},\n        \"out_2\": {\"type\": \"dataframe\", \"table_name\": \"measurements\"},\n    }\n    ```\n\n    Args:\n        input_paths: List of input paths where the image data is stored as\n            OME-Zarrs. Should point to the parent folder containing one or many\n            OME-Zarr files, not the actual OME-Zarr file.\n            Example: `[\"/some/path/\"]`.\n            his task only supports a single input path.\n            (standard argument for Fractal tasks, managed by Fractal server).\n        output_path: This parameter is not used by this task.\n            (standard argument for Fractal tasks, managed by Fractal server).\n        component: Path to the OME-Zarr image in the OME-Zarr plate that is\n            processed.\n            Example: `\"some_plate.zarr/B/03/0\"`.\n            (standard argument for Fractal tasks, managed by Fractal server).\n        metadata: This parameter is not used by this task.\n            (standard argument for Fractal tasks, managed by Fractal server).\n        workflow_file: Absolute path to napari-workflows YAML file\n        input_specs: A dictionary of `NapariWorkflowsInput` values.\n        output_specs: A dictionary of `NapariWorkflowsOutput` values.\n        input_ROI_table: Name of the ROI table over which the task loops to\n            apply napari workflows.\n            Examples:\n            `FOV_ROI_table`\n            =&gt; loop over the field of views;\n            `organoid_ROI_table`\n            =&gt; loop over the organoid ROI table (generated by another task);\n            `well_ROI_table`\n            =&gt; process the whole well as one image.\n        level: Pyramid level of the image to be used as input for\n            napari-workflows. Choose `0` to process at full resolution.\n            Levels &gt; 0 are currently only supported for workflows that only\n            have intensity images as input and only produce a label images as\n            output.\n        relabeling: If `True`, apply relabeling so that label values are\n            unique across all ROIs in the well.\n        expected_dimensions: Expected dimensions (either `2` or `3`). Useful\n            when loading 2D images that are stored in a 3D array with shape\n            `(1, size_x, size_y)` [which is the default way Fractal stores 2D\n            images], but you want to make sure the napari workflow gets a 2D\n            array to process. Also useful to set to `2` when loading a 2D\n            OME-Zarr that is saved as `(size_x, size_y)`.\n        overwrite: If `True`, overwrite the task output.\n    \"\"\"\n    wf: napari_workflows.Worfklow = load_workflow(workflow_file)\n    logger.info(f\"Loaded workflow from {workflow_file}\")\n\n    # Validation of input/output specs\n    if not (set(wf.leafs()) &lt;= set(output_specs.keys())):\n        msg = f\"Some item of {wf.leafs()=} is not part of {output_specs=}.\"\n        logger.warning(msg)\n    if not (set(wf.roots()) &lt;= set(input_specs.keys())):\n        msg = f\"Some item of {wf.roots()=} is not part of {input_specs=}.\"\n        logger.error(msg)\n        raise ValueError(msg)\n    list_outputs = sorted(output_specs.keys())\n\n    # Characterization of workflow and scope restriction\n    input_types = [in_params.type for (name, in_params) in input_specs.items()]\n    output_types = [\n        out_params.type for (name, out_params) in output_specs.items()\n    ]\n    are_inputs_all_images = set(input_types) == {\"image\"}\n    are_outputs_all_labels = set(output_types) == {\"label\"}\n    are_outputs_all_dataframes = set(output_types) == {\"dataframe\"}\n    is_labeling_workflow = are_inputs_all_images and are_outputs_all_labels\n    is_measurement_only_workflow = are_outputs_all_dataframes\n    # Level-related constraint\n    logger.info(f\"This workflow acts at {level=}\")\n    logger.info(\n        f\"Is the current workflow a labeling one? {is_labeling_workflow}\"\n    )\n    if level &gt; 0 and not is_labeling_workflow:\n        msg = (\n            f\"{level=}&gt;0 is currently only accepted for labeling workflows, \"\n            \"i.e. those going from image(s) to label(s)\"\n        )\n        logger.error(msg)\n        raise OutOfTaskScopeError(msg)\n    # Relabeling-related (soft) constraint\n    if is_measurement_only_workflow and relabeling:\n        logger.warning(\n            \"This is a measurement-output-only workflow, setting \"\n            \"relabeling=False.\"\n        )\n        relabeling = False\n    if relabeling:\n        max_label_for_relabeling = 0\n\n    # Pre-processing of task inputs\n    if len(input_paths) &gt; 1:\n        raise NotImplementedError(\n            \"We currently only support a single input path\"\n        )\n    in_path = Path(input_paths[0]).as_posix()\n    label_dtype = np.uint32\n\n    # Read ROI table\n    zarrurl = f\"{in_path}/{component}\"\n    ROI_table = ad.read_zarr(f\"{in_path}/{component}/tables/{input_ROI_table}\")\n\n    # Load image metadata\n    ngff_image_meta = load_NgffImageMeta(zarrurl)\n    num_levels = ngff_image_meta.num_levels\n    coarsening_xy = ngff_image_meta.coarsening_xy\n\n    # Read pixel sizes from zattrs file\n    full_res_pxl_sizes_zyx = ngff_image_meta.get_pixel_sizes_zyx(level=0)\n\n    # Create list of indices for 3D FOVs spanning the entire Z direction\n    list_indices = convert_ROI_table_to_indices(\n        ROI_table,\n        level=level,\n        coarsening_xy=coarsening_xy,\n        full_res_pxl_sizes_zyx=full_res_pxl_sizes_zyx,\n    )\n    check_valid_ROI_indices(list_indices, input_ROI_table)\n    num_ROIs = len(list_indices)\n    logger.info(\n        f\"Completed reading ROI table {input_ROI_table},\"\n        f\" found {num_ROIs} ROIs.\"\n    )\n\n    # Input preparation: \"image\" type\n    image_inputs = [\n        (name, in_params)\n        for (name, in_params) in input_specs.items()\n        if in_params.type == \"image\"\n    ]\n    input_image_arrays = {}\n    if image_inputs:\n        img_array = da.from_zarr(f\"{in_path}/{component}/{level}\")\n        # Loop over image inputs and assign corresponding channel of the image\n        for (name, params) in image_inputs:\n            channel = get_channel_from_image_zarr(\n                image_zarr_path=f\"{in_path}/{component}\",\n                wavelength_id=params.channel.wavelength_id,\n                label=params.channel.label,\n            )\n            channel_index = channel.index\n            input_image_arrays[name] = img_array[channel_index]\n\n            # Handle dimensions\n            shape = input_image_arrays[name].shape\n            if expected_dimensions == 3 and shape[0] == 1:\n                logger.warning(\n                    f\"Input {name} has shape {shape} \"\n                    f\"but {expected_dimensions=}\"\n                )\n            if expected_dimensions == 2:\n                if len(shape) == 2:\n                    # We already load the data as a 2D array\n                    pass\n                elif shape[0] == 1:\n                    input_image_arrays[name] = input_image_arrays[name][\n                        0, :, :\n                    ]\n                else:\n                    msg = (\n                        f\"Input {name} has shape {shape} \"\n                        f\"but {expected_dimensions=}\"\n                    )\n                    logger.error(msg)\n                    raise ValueError(msg)\n            logger.info(f\"Prepared input with {name=} and {params=}\")\n        logger.info(f\"{input_image_arrays=}\")\n\n    # Input preparation: \"label\" type\n    label_inputs = [\n        (name, in_params)\n        for (name, in_params) in input_specs.items()\n        if in_params.type == \"label\"\n    ]\n    if label_inputs:\n        # Set target_shape for upscaling labels\n        if not image_inputs:\n            logger.warning(\n                f\"{len(label_inputs)=} but num_image_inputs=0. \"\n                \"Label array(s) will not be upscaled.\"\n            )\n            upscale_labels = False\n        else:\n            target_shape = list(input_image_arrays.values())[0].shape\n            upscale_labels = True\n        # Loop over label inputs and load corresponding (upscaled) image\n        input_label_arrays = {}\n        for (name, params) in label_inputs:\n            label_name = params.label_name\n            label_array_raw = da.from_zarr(\n                f\"{in_path}/{component}/labels/{label_name}/{level}\"\n            )\n            input_label_arrays[name] = label_array_raw\n\n            # Handle dimensions\n            shape = input_label_arrays[name].shape\n            if expected_dimensions == 3 and shape[0] == 1:\n                logger.warning(\n                    f\"Input {name} has shape {shape} \"\n                    f\"but {expected_dimensions=}\"\n                )\n            if expected_dimensions == 2:\n                if len(shape) == 2:\n                    # We already load the data as a 2D array\n                    pass\n                elif shape[0] == 1:\n                    input_label_arrays[name] = input_label_arrays[name][\n                        0, :, :\n                    ]\n                else:\n                    msg = (\n                        f\"Input {name} has shape {shape} \"\n                        f\"but {expected_dimensions=}\"\n                    )\n                    logger.error(msg)\n                    raise ValueError(msg)\n\n            if upscale_labels:\n                # Check that dimensionality matches the image\n                if len(input_label_arrays[name].shape) != len(target_shape):\n                    raise ValueError(\n                        f\"Label {name} has shape \"\n                        f\"{input_label_arrays[name].shape}. \"\n                        \"But the corresponding image has shape \"\n                        f\"{target_shape}. Those dimensionalities do not \"\n                        f\"match. Is {expected_dimensions=} the correct \"\n                        \"setting?\"\n                    )\n                if expected_dimensions == 3:\n                    upscaling_axes = [1, 2]\n                else:\n                    upscaling_axes = [0, 1]\n                input_label_arrays[name] = upscale_array(\n                    array=input_label_arrays[name],\n                    target_shape=target_shape,\n                    axis=upscaling_axes,\n                    pad_with_zeros=True,\n                )\n\n            logger.info(f\"Prepared input with {name=} and {params=}\")\n        logger.info(f\"{input_label_arrays=}\")\n\n    # Output preparation: \"label\" type\n    label_outputs = [\n        (name, out_params)\n        for (name, out_params) in output_specs.items()\n        if out_params.type == \"label\"\n    ]\n    if label_outputs:\n        # Preliminary scope checks\n        if len(label_outputs) &gt; 1:\n            raise OutOfTaskScopeError(\n                \"Multiple label outputs would break label-inputs-only \"\n                f\"workflows (found {len(label_outputs)=}).\"\n            )\n        if len(label_outputs) &gt; 1 and relabeling:\n            raise OutOfTaskScopeError(\n                \"Multiple label outputs would break relabeling in labeling+\"\n                f\"measurement workflows (found {len(label_outputs)=}).\"\n            )\n\n        # We only support two cases:\n        # 1. If there exist some input images, then use the first one to\n        #    determine output-label array properties\n        # 2. If there are no input images, but there are input labels, then (A)\n        #    re-load the pixel sizes and re-build ROI indices, and (B) use the\n        #    first input label to determine output-label array properties\n        if image_inputs:\n            reference_array = list(input_image_arrays.values())[0]\n        elif label_inputs:\n            reference_array = list(input_label_arrays.values())[0]\n            # Re-load pixel size, matching to the correct level\n            input_label_name = label_inputs[0][1].label_name\n            ngff_label_image_meta = load_NgffImageMeta(\n                f\"{in_path}/{component}/labels/{input_label_name}\"\n            )\n            full_res_pxl_sizes_zyx = ngff_label_image_meta.get_pixel_sizes_zyx(\n                level=0\n            )\n            # Create list of indices for 3D FOVs spanning the whole Z direction\n            list_indices = convert_ROI_table_to_indices(\n                ROI_table,\n                level=level,\n                coarsening_xy=coarsening_xy,\n                full_res_pxl_sizes_zyx=full_res_pxl_sizes_zyx,\n            )\n            check_valid_ROI_indices(list_indices, input_ROI_table)\n            num_ROIs = len(list_indices)\n            logger.info(\n                f\"Re-create ROI indices from ROI table {input_ROI_table}, \"\n                f\"using {full_res_pxl_sizes_zyx=}. \"\n                \"This is necessary because label-input-only workflows may \"\n                \"have label inputs that are at a different resolution and \"\n                \"are not upscaled.\"\n            )\n        else:\n            msg = (\n                \"Missing image_inputs and label_inputs, we cannot assign\"\n                \" label output properties\"\n            )\n            raise OutOfTaskScopeError(msg)\n\n        # Extract label properties from reference_array, and make sure they are\n        # for three dimensions\n        label_shape = reference_array.shape\n        label_chunksize = reference_array.chunksize\n        if len(label_shape) == 2 and len(label_chunksize) == 2:\n            if expected_dimensions == 3:\n                raise ValueError(\n                    f\"Something wrong: {label_shape=} but \"\n                    f\"{expected_dimensions=}\"\n                )\n            label_shape = (1, label_shape[0], label_shape[1])\n            label_chunksize = (1, label_chunksize[0], label_chunksize[1])\n        logger.info(f\"{label_shape=}\")\n        logger.info(f\"{label_chunksize=}\")\n\n        # Loop over label outputs and (1) set zattrs, (2) create zarr group\n        output_label_zarr_groups: dict[str, Any] = {}\n        for (name, out_params) in label_outputs:\n\n            # (1a) Rescale OME-NGFF datasets (relevant for level&gt;0)\n            if not ngff_image_meta.multiscale.axes[0].name == \"c\":\n                raise ValueError(\n                    \"Cannot set `remove_channel_axis=True` for multiscale \"\n                    f\"metadata with axes={ngff_image_meta.multiscale.axes}. \"\n                    'First axis should have name \"c\".'\n                )\n            new_datasets = rescale_datasets(\n                datasets=[\n                    ds.dict() for ds in ngff_image_meta.multiscale.datasets\n                ],\n                coarsening_xy=coarsening_xy,\n                reference_level=level,\n                remove_channel_axis=True,\n            )\n\n            # (1b) Prepare attrs for label group\n            label_name = out_params.label_name\n            label_attrs = {\n                \"image-label\": {\n                    \"version\": __OME_NGFF_VERSION__,\n                    \"source\": {\"image\": \"../../\"},\n                },\n                \"multiscales\": [\n                    {\n                        \"name\": label_name,\n                        \"version\": __OME_NGFF_VERSION__,\n                        \"axes\": [\n                            ax.dict()\n                            for ax in ngff_image_meta.multiscale.axes\n                            if ax.type != \"channel\"\n                        ],\n                        \"datasets\": new_datasets,\n                    }\n                ],\n            }\n\n            # (2) Prepare label group\n            zarrurl = f\"{in_path}/{component}\"\n            image_group = zarr.group(zarrurl)\n            label_group = prepare_label_group(\n                image_group,\n                label_name,\n                overwrite=overwrite,\n                label_attrs=label_attrs,\n                logger=logger,\n            )\n            logger.info(\n                \"Helper function `prepare_label_group` returned \"\n                f\"{label_group=}\"\n            )\n\n            # (3) Create zarr group at level=0\n            store = zarr.storage.FSStore(\n                f\"{in_path}/{component}/labels/{label_name}/0\"\n            )\n            mask_zarr = zarr.create(\n                shape=label_shape,\n                chunks=label_chunksize,\n                dtype=label_dtype,\n                store=store,\n                overwrite=overwrite,\n                dimension_separator=\"/\",\n            )\n            output_label_zarr_groups[name] = mask_zarr\n            logger.info(f\"Prepared output with {name=} and {out_params=}\")\n        logger.info(f\"{output_label_zarr_groups=}\")\n\n    # Output preparation: \"dataframe\" type\n    dataframe_outputs = [\n        (name, out_params)\n        for (name, out_params) in output_specs.items()\n        if out_params.type == \"dataframe\"\n    ]\n    output_dataframe_lists: dict[str, list] = {}\n    for (name, out_params) in dataframe_outputs:\n        output_dataframe_lists[name] = []\n        logger.info(f\"Prepared output with {name=} and {out_params=}\")\n        logger.info(f\"{output_dataframe_lists=}\")\n\n    #####\n\n    for i_ROI, indices in enumerate(list_indices):\n        s_z, e_z, s_y, e_y, s_x, e_x = indices[:]\n        region = (slice(s_z, e_z), slice(s_y, e_y), slice(s_x, e_x))\n\n        logger.info(f\"ROI {i_ROI+1}/{num_ROIs}: {region=}\")\n\n        # Always re-load napari worfklow\n        wf = load_workflow(workflow_file)\n\n        # Set inputs\n        for input_name in input_specs.keys():\n            input_type = input_specs[input_name].type\n\n            if input_type == \"image\":\n                wf.set(\n                    input_name,\n                    load_region(\n                        input_image_arrays[input_name],\n                        region,\n                        compute=True,\n                        return_as_3D=False,\n                    ),\n                )\n            elif input_type == \"label\":\n                wf.set(\n                    input_name,\n                    load_region(\n                        input_label_arrays[input_name],\n                        region,\n                        compute=True,\n                        return_as_3D=False,\n                    ),\n                )\n\n        # Get outputs\n        outputs = wf.get(list_outputs)\n\n        # Iterate first over dataframe outputs (to use the correct\n        # max_label_for_relabeling, if needed)\n        for ind_output, output_name in enumerate(list_outputs):\n            if output_specs[output_name].type != \"dataframe\":\n                continue\n            df = outputs[ind_output]\n            if relabeling:\n                df[\"label\"] += max_label_for_relabeling\n                logger.info(\n                    f'ROI {i_ROI+1}/{num_ROIs}: Relabeling \"{name}\" dataframe'\n                    \"output, with {max_label_for_relabeling=}\"\n                )\n\n            # Append the new-ROI dataframe to the all-ROIs list\n            output_dataframe_lists[output_name].append(df)\n\n        # After all dataframe outputs, iterate over label outputs (which\n        # actually can be only 0 or 1)\n        for ind_output, output_name in enumerate(list_outputs):\n            if output_specs[output_name].type != \"label\":\n                continue\n            mask = outputs[ind_output]\n\n            # Check dimensions\n            if len(mask.shape) != expected_dimensions:\n                msg = (\n                    f\"Output {output_name} has shape {mask.shape} \"\n                    f\"but {expected_dimensions=}\"\n                )\n                logger.error(msg)\n                raise ValueError(msg)\n            elif expected_dimensions == 2:\n                mask = np.expand_dims(mask, axis=0)\n\n            # Sanity check: issue warning for non-consecutive labels\n            unique_labels = np.unique(mask)\n            num_unique_labels_in_this_ROI = len(unique_labels)\n            if np.min(unique_labels) == 0:\n                num_unique_labels_in_this_ROI -= 1\n            num_labels_in_this_ROI = int(np.max(mask))\n            if num_labels_in_this_ROI != num_unique_labels_in_this_ROI:\n                logger.warning(\n                    f'ROI {i_ROI+1}/{num_ROIs}: \"{name}\" label output has'\n                    f\"non-consecutive labels: {num_labels_in_this_ROI=} but\"\n                    f\"{num_unique_labels_in_this_ROI=}\"\n                )\n\n            if relabeling:\n                mask[mask &gt; 0] += max_label_for_relabeling\n                logger.info(\n                    f'ROI {i_ROI+1}/{num_ROIs}: Relabeling \"{name}\" label '\n                    f\"output, with {max_label_for_relabeling=}\"\n                )\n                max_label_for_relabeling += num_labels_in_this_ROI\n                logger.info(\n                    f\"ROI {i_ROI+1}/{num_ROIs}: label-number update with \"\n                    f\"{num_labels_in_this_ROI=}; \"\n                    f\"new {max_label_for_relabeling=}\"\n                )\n\n            da.array(mask).to_zarr(\n                url=output_label_zarr_groups[output_name],\n                region=region,\n                compute=True,\n                overwrite=overwrite,\n            )\n        logger.info(f\"ROI {i_ROI+1}/{num_ROIs}: output handling complete\")\n\n    # Output handling: \"dataframe\" type (for each output, concatenate ROI\n    # dataframes, clean up, and store in a AnnData table on-disk)\n    for (name, out_params) in dataframe_outputs:\n        table_name = out_params.table_name\n        # Concatenate all FOV dataframes\n        list_dfs = output_dataframe_lists[name]\n        if len(list_dfs) == 0:\n            measurement_table = ad.AnnData()\n        else:\n            df_well = pd.concat(list_dfs, axis=0, ignore_index=True)\n            # Extract labels and drop them from df_well\n            labels = pd.DataFrame(df_well[\"label\"].astype(str))\n            df_well.drop(labels=[\"label\"], axis=1, inplace=True)\n            # Convert all to float (warning: some would be int, in principle)\n            measurement_dtype = np.float32\n            df_well = df_well.astype(measurement_dtype)\n            df_well.index = df_well.index.map(str)\n            # Convert to anndata\n            measurement_table = ad.AnnData(df_well, dtype=measurement_dtype)\n            measurement_table.obs = labels\n\n        # Write to zarr group\n        image_group = zarr.group(f\"{in_path}/{component}\")\n        table_attrs = dict(\n            type=\"feature_table\",\n            region=dict(path=f\"../labels/{out_params.label_name}\"),\n            instance_key=\"label\",\n        )\n        write_table(\n            image_group,\n            table_name,\n            measurement_table,\n            overwrite=overwrite,\n            table_attrs=table_attrs,\n        )\n\n    # Output handling: \"label\" type (for each output, build and write to disk\n    # pyramid of coarser levels)\n    for (name, out_params) in label_outputs:\n        label_name = out_params.label_name\n        build_pyramid(\n            zarrurl=f\"{zarrurl}/labels/{label_name}\",\n            overwrite=overwrite,\n            num_levels=num_levels,\n            coarsening_xy=coarsening_xy,\n            chunksize=label_chunksize,\n            aggregation_function=np.max,\n        )\n\n    return {}\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/napari_workflows_wrapper_models/","title":"napari_workflows_wrapper_models","text":""},{"location":"reference/fractal_tasks_core/tasks/napari_workflows_wrapper_models/#fractal_tasks_core.tasks.napari_workflows_wrapper_models.NapariWorkflowsInput","title":"<code>NapariWorkflowsInput</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>A value of the <code>input_specs</code> argument in <code>napari_workflows_wrapper</code>.</p> ATTRIBUTE DESCRIPTION <code>type</code> <p>Input type (either <code>image</code> or <code>label</code>).</p> <p> TYPE: <code>Literal['image', 'label']</code> </p> <code>label_name</code> <p>Label name (for label inputs only).</p> <p> TYPE: <code>Optional[str]</code> </p> <code>channel</code> <p><code>ChannelInputModel</code> object (for image inputs only).</p> <p> TYPE: <code>Optional[ChannelInputModel]</code> </p> Source code in <code>fractal_tasks_core/tasks/napari_workflows_wrapper_models.py</code> <pre><code>class NapariWorkflowsInput(BaseModel):\n\"\"\"\n    A value of the `input_specs` argument in `napari_workflows_wrapper`.\n\n    Attributes:\n        type: Input type (either `image` or `label`).\n        label_name: Label name (for label inputs only).\n        channel: `ChannelInputModel` object (for image inputs only).\n    \"\"\"\n\n    type: Literal[\"image\", \"label\"]\n    label_name: Optional[str]\n    channel: Optional[ChannelInputModel]\n\n    @validator(\"label_name\", always=True)\n    def label_name_is_present(cls, v, values):\n\"\"\"\n        Check that label inputs have `label_name` set.\n        \"\"\"\n        _type = values.get(\"type\")\n        if _type == \"label\" and not v:\n            raise ValueError(\n                f\"Input item has type={_type} but label_name={v}.\"\n            )\n        return v\n\n    @validator(\"channel\", always=True)\n    def channel_is_present(cls, v, values):\n\"\"\"\n        Check that image inputs have `channel` set.\n        \"\"\"\n        _type = values.get(\"type\")\n        if _type == \"image\" and not v:\n            raise ValueError(f\"Input item has type={_type} but channel={v}.\")\n        return v\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/napari_workflows_wrapper_models/#fractal_tasks_core.tasks.napari_workflows_wrapper_models.NapariWorkflowsInput.channel_is_present","title":"<code>channel_is_present(v, values)</code>","text":"<p>Check that image inputs have <code>channel</code> set.</p> Source code in <code>fractal_tasks_core/tasks/napari_workflows_wrapper_models.py</code> <pre><code>@validator(\"channel\", always=True)\ndef channel_is_present(cls, v, values):\n\"\"\"\n    Check that image inputs have `channel` set.\n    \"\"\"\n    _type = values.get(\"type\")\n    if _type == \"image\" and not v:\n        raise ValueError(f\"Input item has type={_type} but channel={v}.\")\n    return v\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/napari_workflows_wrapper_models/#fractal_tasks_core.tasks.napari_workflows_wrapper_models.NapariWorkflowsInput.label_name_is_present","title":"<code>label_name_is_present(v, values)</code>","text":"<p>Check that label inputs have <code>label_name</code> set.</p> Source code in <code>fractal_tasks_core/tasks/napari_workflows_wrapper_models.py</code> <pre><code>@validator(\"label_name\", always=True)\ndef label_name_is_present(cls, v, values):\n\"\"\"\n    Check that label inputs have `label_name` set.\n    \"\"\"\n    _type = values.get(\"type\")\n    if _type == \"label\" and not v:\n        raise ValueError(\n            f\"Input item has type={_type} but label_name={v}.\"\n        )\n    return v\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/napari_workflows_wrapper_models/#fractal_tasks_core.tasks.napari_workflows_wrapper_models.NapariWorkflowsOutput","title":"<code>NapariWorkflowsOutput</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>A value of the <code>output_specs</code> argument in <code>napari_workflows_wrapper</code>.</p> ATTRIBUTE DESCRIPTION <code>type</code> <p>Output type (either <code>label</code> or <code>dataframe</code>).</p> <p> TYPE: <code>Literal['label', 'dataframe']</code> </p> <code>label_name</code> <p>Label name (for label outputs, it is used as the name of the label; for dataframe outputs, it is used to fill the <code>region[\"path\"]</code> field).</p> <p> TYPE: <code>str</code> </p> <code>table_name</code> <p>Table name (for dataframe outputs only).</p> <p> TYPE: <code>Optional[str]</code> </p> Source code in <code>fractal_tasks_core/tasks/napari_workflows_wrapper_models.py</code> <pre><code>class NapariWorkflowsOutput(BaseModel):\n\"\"\"\n    A value of the `output_specs` argument in `napari_workflows_wrapper`.\n\n    Attributes:\n        type: Output type (either `label` or `dataframe`).\n        label_name: Label name (for label outputs, it is used as the name of\n            the label; for dataframe outputs, it is used to fill the\n            `region[\"path\"]` field).\n        table_name: Table name (for dataframe outputs only).\n    \"\"\"\n\n    type: Literal[\"label\", \"dataframe\"]\n    label_name: str\n    table_name: Optional[str] = None\n\n    @validator(\"table_name\", always=True)\n    def table_name_only_for_dataframe_type(cls, v, values):\n\"\"\"\n        Check that table_name is set only for dataframe outputs.\n        \"\"\"\n        _type = values.get(\"type\")\n        if (_type == \"dataframe\" and (not v)) or (_type != \"dataframe\" and v):\n            raise ValueError(\n                f\"Output item has type={_type} but table_name={v}.\"\n            )\n        return v\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/napari_workflows_wrapper_models/#fractal_tasks_core.tasks.napari_workflows_wrapper_models.NapariWorkflowsOutput.table_name_only_for_dataframe_type","title":"<code>table_name_only_for_dataframe_type(v, values)</code>","text":"<p>Check that table_name is set only for dataframe outputs.</p> Source code in <code>fractal_tasks_core/tasks/napari_workflows_wrapper_models.py</code> <pre><code>@validator(\"table_name\", always=True)\ndef table_name_only_for_dataframe_type(cls, v, values):\n\"\"\"\n    Check that table_name is set only for dataframe outputs.\n    \"\"\"\n    _type = values.get(\"type\")\n    if (_type == \"dataframe\" and (not v)) or (_type != \"dataframe\" and v):\n        raise ValueError(\n            f\"Output item has type={_type} but table_name={v}.\"\n        )\n    return v\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/yokogawa_to_ome_zarr/","title":"yokogawa_to_ome_zarr","text":"<p>Task that writes image data to an existing OME-NGFF zarr array.</p>"},{"location":"reference/fractal_tasks_core/tasks/yokogawa_to_ome_zarr/#fractal_tasks_core.tasks.yokogawa_to_ome_zarr.sort_fun","title":"<code>sort_fun(filename)</code>","text":"<p>Takes a string (filename of a Yokogawa image), extract site and z-index metadata and returns them as a list of integers.</p> PARAMETER  DESCRIPTION <code>filename</code> <p>Name of the image file.</p> <p> TYPE: <code>str</code> </p> Source code in <code>fractal_tasks_core/tasks/yokogawa_to_ome_zarr.py</code> <pre><code>def sort_fun(filename: str) -&gt; list[int]:\n\"\"\"\n    Takes a string (filename of a Yokogawa image), extract site and\n    z-index metadata and returns them as a list of integers.\n\n    Args:\n        filename: Name of the image file.\n    \"\"\"\n\n    filename_metadata = parse_filename(filename)\n    site = int(filename_metadata[\"F\"])\n    z_index = int(filename_metadata[\"Z\"])\n    return [site, z_index]\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/yokogawa_to_ome_zarr/#fractal_tasks_core.tasks.yokogawa_to_ome_zarr.yokogawa_to_ome_zarr","title":"<code>yokogawa_to_ome_zarr(*, input_paths, output_path, component, metadata, overwrite=False)</code>","text":"<p>Convert Yokogawa output (png, tif) to zarr file.</p> <p>This task is typically run after Create OME-Zarr or Create OME-Zarr Multiplexing and populates the empty OME-Zarr files that were prepared.</p> PARAMETER  DESCRIPTION <code>input_paths</code> <p>List of input paths where the OME-Zarrs. Should point to the parent folder containing one or many OME-Zarr files, not the actual OME-Zarr file. Example: <code>[\"/some/path/\"]</code>. This task only supports a single input path. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>Sequence[str]</code> </p> <code>output_path</code> <p>Unclear. Should be the same as <code>input_path</code>. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>str</code> </p> <code>component</code> <p>Path to the OME-Zarr image in the OME-Zarr plate that is processed. Example: <code>\"some_plate.zarr/B/03/0\"</code> (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>str</code> </p> <code>metadata</code> <p>Dictionary containing metadata about the OME-Zarr. This task requires the following elements to be present in the metadata. <code>original_paths</code>: list of paths that correspond to the <code>input_paths</code> of the <code>create_ome_zarr</code> task (=&gt; where the microscopy image are stored); <code>num_levels (int)</code>: number of pyramid levels in the image (this determines how many pyramid levels are built for the segmentation); <code>coarsening_xy (int)</code>: coarsening factor in XY of the downsampling when building the pyramid; <code>image_extension</code>: filename extension of images (e.g. <code>\"tif\"</code> or <code>\"png\"</code>); <code>image_glob_patterns</code>: parameter of <code>create_ome_zarr</code> task (if specified, only parse images with filenames that match with all these patterns). (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>overwrite</code> <p>If <code>True</code>, overwrite the task output.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>fractal_tasks_core/tasks/yokogawa_to_ome_zarr.py</code> <pre><code>@validate_arguments\ndef yokogawa_to_ome_zarr(\n    *,\n    input_paths: Sequence[str],\n    output_path: str,\n    component: str,\n    metadata: dict[str, Any],\n    overwrite: bool = False,\n):\n\"\"\"\n    Convert Yokogawa output (png, tif) to zarr file.\n\n    This task is typically run after Create OME-Zarr or\n    Create OME-Zarr Multiplexing and populates the empty OME-Zarr files that\n    were prepared.\n\n    Args:\n        input_paths: List of input paths where the OME-Zarrs. Should point to\n            the parent folder containing one or many OME-Zarr files, not the\n            actual OME-Zarr file. Example: `[\"/some/path/\"]`.\n            This task only supports a single input path.\n            (standard argument for Fractal tasks,\n            managed by Fractal server).\n        output_path: Unclear. Should be the same as `input_path`.\n            (standard argument for Fractal tasks, managed by Fractal server).\n        component: Path to the OME-Zarr image in the OME-Zarr plate that is\n            processed. Example: `\"some_plate.zarr/B/03/0\"`\n            (standard argument for Fractal tasks, managed by Fractal server).\n        metadata: Dictionary containing metadata about the OME-Zarr. This task\n            requires the following elements to be present in the metadata.\n            `original_paths`:\n            list of paths that correspond to the `input_paths` of the\n            `create_ome_zarr` task (=&gt; where the microscopy image are stored);\n            `num_levels (int)`:\n            number of pyramid levels in the image (this determines how many\n            pyramid levels are built for the segmentation);\n            `coarsening_xy (int)`:\n            coarsening factor in XY of the downsampling when building the\n            pyramid;\n            `image_extension`:\n            filename extension of images (e.g. `\"tif\"` or `\"png\"`);\n            `image_glob_patterns`:\n            parameter of `create_ome_zarr` task (if specified, only parse\n            images with filenames that match with all these patterns).\n            (standard argument for Fractal tasks, managed by Fractal server).\n        overwrite: If `True`, overwrite the task output.\n    \"\"\"\n\n    # Preliminary checks\n    if len(input_paths) &gt; 1:\n        raise NotImplementedError\n    zarrurl = Path(input_paths[0]).as_posix() + f\"/{component}\"\n\n    # Read attributes from NGFF metadata\n    ngff_image_meta = load_NgffImageMeta(zarrurl)\n    num_levels = ngff_image_meta.num_levels\n    coarsening_xy = ngff_image_meta.coarsening_xy\n    full_res_pxl_sizes_zyx = ngff_image_meta.get_pixel_sizes_zyx(level=0)\n    logger.info(f\"NGFF image has {num_levels=}\")\n    logger.info(f\"NGFF image has {coarsening_xy=}\")\n    logger.info(\n        f\"NGFF image has full-res pixel sizes {full_res_pxl_sizes_zyx}\"\n    )\n\n    parameters = get_parameters_from_metadata(\n        keys=[\n            \"original_paths\",\n            \"image_extension\",\n            \"image_glob_patterns\",\n        ],\n        metadata=metadata,\n        # FIXME: Why rely on output_path here, when we use the input path for\n        # the zarr_url? That just means that different input &amp; output paths\n        # don't work, no?\n        image_zarr_path=(Path(output_path) / component),\n    )\n    original_path_list = parameters[\"original_paths\"]\n    image_extension = parameters[\"image_extension\"]\n    image_glob_patterns = parameters[\"image_glob_patterns\"]\n\n    channels: list[OmeroChannel] = get_omero_channel_list(\n        image_zarr_path=zarrurl\n    )\n    wavelength_ids = [c.wavelength_id for c in channels]\n\n    in_path = Path(original_path_list[0])\n\n    # Define well\n    component_split = component.split(\"/\")\n    well_row = component_split[1]\n    well_column = component_split[2]\n    well_ID = well_row + well_column\n\n    # Read useful information from ROI table\n    adata = read_zarr(f\"{zarrurl}/tables/FOV_ROI_table\")\n    fov_indices = convert_ROI_table_to_indices(\n        adata,\n        full_res_pxl_sizes_zyx=full_res_pxl_sizes_zyx,\n    )\n    check_valid_ROI_indices(fov_indices, \"FOV_ROI_table\")\n    adata_well = read_zarr(f\"{zarrurl}/tables/well_ROI_table\")\n    well_indices = convert_ROI_table_to_indices(\n        adata_well,\n        full_res_pxl_sizes_zyx=full_res_pxl_sizes_zyx,\n    )\n    check_valid_ROI_indices(well_indices, \"well_ROI_table\")\n    if len(well_indices) &gt; 1:\n        raise ValueError(f\"Something wrong with {well_indices=}\")\n\n    # FIXME: Put back the choice of columns by name? Not here..\n\n    max_z = well_indices[0][1]\n    max_y = well_indices[0][3]\n    max_x = well_indices[0][5]\n\n    # Load a single image, to retrieve useful information\n    patterns = [f\"*_{well_ID}_*.{image_extension}\"]\n    if image_glob_patterns:\n        patterns.extend(image_glob_patterns)\n    tmp_images = glob_with_multiple_patterns(\n        folder=str(in_path),\n        patterns=patterns,\n    )\n    sample = imread(tmp_images.pop())\n\n    # Initialize zarr\n    chunksize = (1, 1, sample.shape[1], sample.shape[2])\n    try:\n        canvas_zarr = zarr.create(\n            shape=(len(wavelength_ids), max_z, max_y, max_x),\n            chunks=chunksize,\n            dtype=sample.dtype,\n            store=zarr.storage.FSStore(zarrurl + \"/0\"),\n            overwrite=overwrite,\n            dimension_separator=\"/\",\n        )\n    except ContainsArrayError as e:\n        error_msg = (\n            f\"Cannot create a zarr group at '{zarrurl}/0', \"\n            f\"with {overwrite=} (original error: {str(e)}).\\n\"\n            \"Hint: try setting overwrite=True.\"\n        )\n        logger.error(error_msg)\n        raise OverwriteNotAllowedError(error_msg)\n\n    # Loop over channels\n    for i_c, wavelength_id in enumerate(wavelength_ids):\n        A, C = wavelength_id.split(\"_\")\n\n        patterns = [f\"*_{well_ID}_*{A}*{C}*.{image_extension}\"]\n        if image_glob_patterns:\n            patterns.extend(image_glob_patterns)\n        filenames_set = glob_with_multiple_patterns(\n            folder=str(in_path),\n            patterns=patterns,\n        )\n        filenames = sorted(list(filenames_set), key=sort_fun)\n        if len(filenames) == 0:\n            raise ValueError(\n                \"Error in yokogawa_to_ome_zarr: len(filenames)=0.\\n\"\n                f\"  in_path: {in_path}\\n\"\n                f\"  image_extension: {image_extension}\\n\"\n                f\"  well_ID: {well_ID}\\n\"\n                f\"  wavelength_id: {wavelength_id},\\n\"\n                f\"  patterns: {patterns}\"\n            )\n        # Loop over 3D FOV ROIs\n        for indices in fov_indices:\n            s_z, e_z, s_y, e_y, s_x, e_x = indices[:]\n            region = (\n                slice(i_c, i_c + 1),\n                slice(s_z, e_z),\n                slice(s_y, e_y),\n                slice(s_x, e_x),\n            )\n            FOV_3D = da.concatenate(\n                [imread(img) for img in filenames[:e_z]],\n            )\n            FOV_4D = da.expand_dims(FOV_3D, axis=0)\n            filenames = filenames[e_z:]\n            da.array(FOV_4D).to_zarr(\n                url=canvas_zarr,\n                region=region,\n                compute=True,\n            )\n\n    # Starting from on-disk highest-resolution data, build and write to disk a\n    # pyramid of coarser levels\n    build_pyramid(\n        zarrurl=zarrurl,\n        overwrite=overwrite,\n        num_levels=num_levels,\n        coarsening_xy=coarsening_xy,\n        chunksize=chunksize,\n    )\n\n    # Deprecated: Delete images (optional)\n    # if delete_input:\n    #     for f in filenames:\n    #         try:\n    #             os.remove(f)\n    #         except OSError as e:\n    #             logging.info(\"Error: %s : %s\" % (f, e.strerror))\n\n    return {}\n</code></pre>"},{"location":"run_tasks/","title":"Run tasks","text":"<p>There are several ways to run <code>fractal-tasks-core</code> tasks:</p> <ul> <li>Within Fractal;</li> <li>From Python scripts.</li> </ul>"},{"location":"run_tasks/tasks_in_fractal/","title":"Within Fractal","text":"<p>Thanks to the package manifest and to their structure, the tasks in <code>fractal_tasks_core.tasks</code> can be run within the Fractal platform; this consists in a backend server which can be accessed by one of the two available clients (a command-line client and a web-client).</p> <p>The <code>fractal-demos</code> repository lists a set of relevant examples, including:</p> <ul> <li>How to set up a <code>fractal-server</code> instance;</li> <li>How to set up a <code>fractal-client</code> command-line client;</li> <li>How to use the command-line client to submit a series of typical workflows (based on <code>fractal-tasks-core</code> tasks) to Fractal; see folders from 01 to 10 in the <code>examples</code> folder.</li> </ul>"},{"location":"run_tasks/tasks_in_scripts/","title":"From Python scripts","text":"<p>The <code>fractal-tasks-core</code> GitHub repository includes an examples folder, listing a few examples of how to run <code>fractal-tasks-core</code> tasks from a standard Python script (instead of using the Fractal platform).</p> <p>What follows is the content of examples/README.md:</p>"},{"location":"run_tasks/tasks_in_scripts/#examples","title":"Examples","text":"<p>This <code>examples</code> folder offers a few examples of how to run <code>fractal-tasks-core</code> tasks as part of a Python script.</p>"},{"location":"run_tasks/tasks_in_scripts/#notes","title":"Notes","text":"<ul> <li>This folder is not always kept up-to-date. If you encounter any unexpected   problem, please open a new issue on the <code>fractal-tasks-core</code> GitHub repository.</li> <li>Examples from 01 to 09 are currently aligned with fractal-tasks-core 0.10.0.</li> </ul>"},{"location":"run_tasks/tasks_in_scripts/#general-instructions","title":"General instructions","text":"<p>The following instructions are valid for all examples; check the specific <code>README.md</code> files in each folder for more specific details.</p> <ol> <li> <p>Set up the correct environment via <pre><code>pip install fractal-tasks-core[fractal-tasks]\n</code></pre> (note: this can be done e.g. from a venv or from a conda environment).</p> </li> <li> <p>Download the example data from Zenodo, if necessary, via <pre><code>pip install zenodo-get\n./fetch_test_data_from_zenodo.sh\n</code></pre></p> </li> <li> <p>Enter one of the example folders, remove the <code>tmp_out</code> temporary output    folder (if present), and run one of the <code>run_workflow</code> Python scripts.</p> </li> <li> <p>View the output OME-Zarr in the <code>tmp_out</code> folder with    napari, which can be installed via <code>pip install    napari[pyqt5] napari-ome-zarr</code>.</p> </li> </ol>"},{"location":"version_updates/","title":"Release-update details","text":"<ul> <li>From version 0.13.1 to 0.14.0</li> </ul>"},{"location":"version_updates/v0_14_0/","title":"From version 0.13.1 to 0.14.0","text":""},{"location":"version_updates/v0_14_0/#package-structure","title":"Package structure","text":"<p>Version 0.14.0 includes a large refactor of the <code>fractal_tasks_core</code> package, leading to this new structure: <pre><code>fractal_tasks_core/\n\u251c\u2500\u2500 cellvoyager\n\u2502   \u251c\u2500\u2500 filenames.py\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 metadata.py\n\u251c\u2500\u2500 ngff\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 specs.py\n\u2502   \u2514\u2500\u2500 zarr_utils.py\n\u251c\u2500\u2500 roi\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 load_region.py\n\u2502   \u251c\u2500\u2500 _overlaps_common.py\n\u2502   \u251c\u2500\u2500 v1_checks.py\n\u2502   \u251c\u2500\u2500 v1_overlaps.py\n\u2502   \u2514\u2500\u2500 v1.py\n\u251c\u2500\u2500 tables\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 v1.py\n\u251c\u2500\u2500 tasks\n\u2502   \u251c\u2500\u2500 apply_registration_to_image.py\n\u2502   \u251c\u2500\u2500 apply_registration_to_ROI_tables.py\n\u2502   \u251c\u2500\u2500 calculate_registration_image_based.py\n\u2502   \u251c\u2500\u2500 cellpose_segmentation.py\n\u2502   \u251c\u2500\u2500 compress_tif.py\n\u2502   \u251c\u2500\u2500 copy_ome_zarr.py\n\u2502   \u251c\u2500\u2500 create_ome_zarr_multiplex.py\n\u2502   \u251c\u2500\u2500 create_ome_zarr.py\n\u2502   \u251c\u2500\u2500 illumination_correction.py\n\u2502   \u251c\u2500\u2500 import_ome_zarr.py\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 maximum_intensity_projection.py\n\u2502   \u251c\u2500\u2500 napari_workflows_wrapper_models.py\n\u2502   \u251c\u2500\u2500 napari_workflows_wrapper.py\n\u2502   \u251c\u2500\u2500 _utils.py\n\u2502   \u2514\u2500\u2500 yokogawa_to_ome_zarr.py\n\u251c\u2500\u2500 __FRACTAL_MANIFEST__.json\n\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 channels.py\n\u251c\u2500\u2500 labels.py\n\u251c\u2500\u2500 masked_loading.py\n\u251c\u2500\u2500 pyramids.py\n\u251c\u2500\u2500 upscale_array.py\n\u251c\u2500\u2500 utils.py\n\u2514\u2500\u2500 zarr_utils.py\n</code></pre></p>"},{"location":"version_updates/v0_14_0/#imports","title":"Imports","text":"<p>This refactor changed several <code>import</code> statements; find below a list (grouped by their original paths) of the old/new forms.</p> <p>\u26a0\ufe0f WARNING: This is a manually-curated list, please do open an issue if you spot an error!</p>"},{"location":"version_updates/v0_14_0/#channels","title":"Channels","text":"<pre><code>-from fractal_tasks_core.lib_channels import ChannelNotFoundError\n+from fractal_tasks_core.channels import ChannelNotFoundError\n\n-from fractal_tasks_core.lib_channels import OmeroChannel\n+from fractal_tasks_core.channels import OmeroChannel\n\n-from fractal_tasks_core.lib_channels import check_unique_wavelength_ids\n+from fractal_tasks_core.channels import check_unique_wavelength_ids\n\n-from fractal_tasks_core.lib_channels import check_well_channel_labels\n+from fractal_tasks_core.channels import check_well_channel_labels\n\n-from fractal_tasks_core.lib_channels import define_omero_channels\n+from fractal_tasks_core.channels import define_omero_channels\n\n-from fractal_tasks_core.lib_channels import get_channel_from_image_zarr\n+from fractal_tasks_core.channels import get_channel_from_image_zarr\n\n-from fractal_tasks_core.lib_channels import get_omero_channel_list\n+from fractal_tasks_core.channels import get_omero_channel_list\n\n-from fractal_tasks_core.lib_channels import update_omero_channels\n+from fractal_tasks_core.channels import update_omero_channels\n</code></pre>"},{"location":"version_updates/v0_14_0/#input-models","title":"Input models","text":"<pre><code># \u26a0\ufe0f WARNING: note the new name\n-from fractal_tasks_core.lib_input_models import Channel\n+from fractal_tasks_core.channels import ChannelInputModel\n\n-from fractal_tasks_core.lib_input_models import NapariWorkflowsInput\n+from fractal_tasks_core.tasks.napari_workflows_wrapper_models import NapariWorkflowsInput\n\n-from fractal_tasks_core.lib_input_models import NapariWorkflowsOutput\n+from fractal_tasks_core.tasks.napari_workflows_wrapper_models import NapariWorkflowsOutput\n</code></pre>"},{"location":"version_updates/v0_14_0/#cellvoyager-converter-utils","title":"CellVoyager converter utils","text":"<pre><code>-from fractal_tasks_core.lib_glob import glob_with_multiple_patterns\n+from fractal_tasks_core.cellvoyager.filenames import glob_with_multiple_patterns\n\n-from fractal_tasks_core.lib_parse_filename_metadata import parse_filename\n+from fractal_tasks_core.cellvoyager.filenames import parse_filename\n\n-from fractal_tasks_core.lib_metadata_parsing import parse_yokogawa_metadata\n+from fractal_tasks_core.cellvoyager.metadata import parse_yokogawa_metadata\n</code></pre>"},{"location":"version_updates/v0_14_0/#ngff-specs-and-validation","title":"NGFF specs and validation","text":"<pre><code>-from fractal_tasks_core.lib_ngff import detect_ome_ngff_type\n+from fractal_tasks_core.ngff import detect_ome_ngff_type\n\n-from fractal_tasks_core.lib_ngff import NgffImageMeta\n+from fractal_tasks_core.ngff import NgffImageMeta\n\n-from fractal_tasks_core.lib_ngff import load_NgffImageMeta\n+from fractal_tasks_core.ngff import load_NgffImageMeta\n\n-from fractal_tasks_core.lib_ngff import load_NgffWellMeta\n+from fractal_tasks_core.ngff import load_NgffWellMeta\n</code></pre>"},{"location":"version_updates/v0_14_0/#pyramids","title":"Pyramids","text":"<pre><code>-from fractal_tasks_core.lib_pyramid_creation import build_pyramid\n+from fractal_tasks_core.pyramids import build_pyramid\n</code></pre>"},{"location":"version_updates/v0_14_0/#regions-of-interest","title":"Regions of interest","text":"<pre><code>-from fractal_tasks_core.lib_regions_of_interest import are_ROI_table_columns_valid\n+from fractal_tasks_core.roi import are_ROI_table_columns_valid\n\n-from fractal_tasks_core.lib_regions_of_interest import array_to_bounding_box_table\n+from fractal_tasks_core.roi import array_to_bounding_box_table\n\n-from fractal_tasks_core.lib_regions_of_interest import check_valid_ROI_indices\n+from fractal_tasks_core.roi import check_valid_ROI_indices\n\n-from fractal_tasks_core.lib_regions_of_interest import convert_ROI_table_to_indices\n+from fractal_tasks_core.roi import convert_ROI_table_to_indices\n\n-from fractal_tasks_core.lib_regions_of_interest import convert_ROIs_from_3D_to_2D\n+from fractal_tasks_core.roi import convert_ROIs_from_3D_to_2D\n\n-from fractal_tasks_core.lib_regions_of_interest import convert_indices_to_regions\n+from fractal_tasks_core.roi import convert_indices_to_regions\n\n-from fractal_tasks_core.lib_regions_of_interest import empty_bounding_box_table\n+from fractal_tasks_core.roi import empty_bounding_box_table\n\n-from fractal_tasks_core.lib_ROI_overlaps import find_overlaps_in_ROI_indices\n+from fractal_tasks_core.roi import find_overlaps_in_ROI_indices\n\n-from fractal_tasks_core.lib_regions_of_interest import get_image_grid_ROIs\n+from fractal_tasks_core.roi import get_image_grid_ROIs\n\n-from fractal_tasks_core.lib_ROI_overlaps import get_overlapping_pairs_3D\n+from fractal_tasks_core.roi import get_overlapping_pairs_3D\n\n-from fractal_tasks_core.lib_regions_of_interest import get_single_image_ROI\n+from fractal_tasks_core.roi import get_single_image_ROI\n\n-from fractal_tasks_core.lib_regions_of_interest import is_ROI_table_valid\n+from fractal_tasks_core.roi import is_ROI_table_valid\n\n-from fractal_tasks_core.lib_regions_of_interest import is_standard_roi_table\n+from fractal_tasks_core.roi import is_standard_roi_table\n\n-from fractal_tasks_core.lib_regions_of_interest import load_region\n+from fractal_tasks_core.roi import load_region\n\n-from fractal_tasks_core.lib_regions_of_interest import prepare_FOV_ROI_table\n+from fractal_tasks_core.roi import prepare_FOV_ROI_table\n\n-from fractal_tasks_core.lib_regions_of_interest import prepare_well_ROI_table\n+from fractal_tasks_core.roi import prepare_well_ROI_table\n\n-from fractal_tasks_core.lib_ROI_overlaps import remove_FOV_overlaps\n+from fractal_tasks_core.roi import remove_FOV_overlaps\n</code></pre>"},{"location":"version_updates/v0_14_0/#other","title":"Other","text":"<pre><code>-from fractal_tasks_core.lib_tables import write_table\n+from fractal_tasks_core.tables import write_table\n\n-from fractal_tasks_core.lib_masked_loading import masked_loading_wrapper\n+from fractal_tasks_core.masked_loading import masked_loading_wrapper\n\n-from fractal_tasks_core.lib_upscale_array import upscale_array\n+from fractal_tasks_core.upscale_array import upscale_array\n\n-from fractal_tasks_core.lib_write import OverwriteNotAllowedError\n+from fractal_tasks_core.zarr_utils import OverwriteNotAllowedError\n\n-from fractal_tasks_core.lib_write import open_zarr_group_with_overwrite\n+from fractal_tasks_core.zarr_utils import open_zarr_group_with_overwrite\n\n-from fractal_tasks_core.lib_write import prepare_label_group\n+from fractal_tasks_core.labels import prepare_label_group\n\n-from fractal_tasks_core.lib_zattrs_utils import get_table_path_dict\n+from fractal_tasks_core.utils import get_table_path_dict\n\n-from fractal_tasks_core.lib_zattrs_utils import rescale_datasets\n+from fractal_tasks_core.utils import rescale_datasets\n\n-from fractal_tasks_core.lib_read_fractal_metadata import get_parameters_from_metadata\n+from fractal_tasks_core.utils import get_parameters_from_metadata\n</code></pre>"}]}